- en: 1.2 Built-in Types of Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/python/12types](https://introcs.cs.princeton.edu/python/12types)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A *data type* is a set of values and a set of operations defined on those values.
    Many data types are built into the Python language. In this section, we consider
    Python's built-in data types `int` (for integers), `float` (for floating-point
    numbers), `str` (for sequences of characters) and `bool` (for true-false values).
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Built-In Data Types](../Images/50e0a3e3eb3c358a5904fce92f81dd40.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To talk about data types, we need to introduce some terminology. To do so,
    we start with the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code creates three *objects*, each of type `int`, using the *literals*
    `1234` and `99` and the *expression* `a + b`, and *binds* *variables* `a`, `b`,
    and `c` to those objects using *assignment statements*. The end result is that
    variable `c` is bound to an object of type `int` whose value is `1333`.
  prefs: []
  type: TYPE_NORMAL
- en: Objects.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All data values in a Python program are represented by *objects* and relationships
    among objects. An object is an in-computer-memory representation of a value from
    a particular data type. Each object is characterized by its *identity*, *type*,
    and *value*.
  prefs: []
  type: TYPE_NORMAL
- en: The *identity* uniquely identifies an object. You should think of it as the
    location in the computer's memory (or memory address) where the object is stored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *type* of an object completely specifies its behavior — the set of values
    it might represent and the set of operations that can be performed on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *value* of an object is the data-type value that it represents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each object stores one value; for example, an object of type `int` can store
    the value `1234` or the value `99` or the value `1333`. Different objects may
    store the same value. For example, one object of type `str` might store the value
    `'hello'`, and another object of type `str` also might store the same value `'hello'`.
    We can apply to an object any of the operations defined by its type (and only
    those operations). For example, we can multiply two `int` objects but not two
    `str` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Object references.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *object reference* is nothing more than a concrete representation of the
    object's identity (the memory address where the object is stored). Python programs
    use object references either to access the object's value or to manipulate the
    object references themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Literals.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *literal* is a Python-code representation of a data-type value. It creates
    an object with the specified value.
  prefs: []
  type: TYPE_NORMAL
- en: Operators.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *operator* is a Python-code representation of a data-type operation. For
    example, Python uses `+` and `*` to represent addition and multiplication for
    integers and floating-point numbers; Python uses `and`, `or`, and `not` to represent
    boolean operations; and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An *identifier* is a Python-code representation of a name. Each identifier
    is a sequence of letters, digits, and underscores, the first of which is not a
    digit. The following keywords are reserved and you cannot use them as identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Variable](../Images/6012b40051af7943536d89c1036e0d8e.png)'
  prefs: []
  type: TYPE_IMG
- en: Variables.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *variable* is a name for an object reference. We use variables to keep track
    of changing values as a computation unfolds. We use diagrams like the one at right
    to show the binding of a variable to an object. ![Anatomy of an Expression](../Images/0210f07be6e464baf22ec59668860b86.png)
  prefs: []
  type: TYPE_NORMAL
- en: Expressions.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *expression* is a combination of literals, variables, and operators that
    Python evaluates to produce an object. Each operand can be any expression, perhaps
    within parentheses. For example, we can compose expressions like `4 * (x - 3)`
    or `5 * x - 6` and Python will understand what we mean.
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression is shorthand for a sequence of operations. Python''s *precedence
    rules* specify the order in which the operations should be applied. For arithmetic
    operations, multiplication and division are performed before addition and subtraction,
    so that `a - b * c` and `a - (b * c)` represent the same sequence of operations.
    When arithmetic operators have the same precedence, they are left associative,
    which means that `a - b - c` and `(a - b) - c` represent the same sequence of
    operations. You can use parentheses to override the rules, so you can write `a
    - (b - c)` if that is what you want. For full details see [Appendix A: Operator
    Precedence in Python](../appendix_precedence).'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment statements.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An *assignment statement* is a directive to Python to bind the variable on
    the left side of the = operator to the object produced by evaluating the expression
    on the right side. For example, when we write `c = a + b`, we are expressing this
    action: "associate the variable `c` with the sum of the values associated with
    the variables `a` and `b`."'
  prefs: []
  type: TYPE_NORMAL
- en: Informal trace.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Trace](../Images/8e6dde2b4136f7417811a4d4ece04f6f.png)An effective way to
    keep track of the values associated with variables is to use a table like the
    one at right, with one line giving the values after each statement has been executed.
    Such a table is called a *trace*.'
  prefs: []
  type: TYPE_NORMAL
- en: Object-level trace.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a more complete understanding, we sometimes keep track of objects and references
    in traces. The object-level trace at right illustrates the full effect of our
    three assignment statements: ![TraceFormal](../Images/8348c214392c562b564ea94cf22add6a.png)'
  prefs: []
  type: TYPE_NORMAL
- en: The statement `a = 1234` creates an `int` object whose value is `1234`; it then
    binds the variable `a` to this new int object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statement `b = 99` creates an int object whose value is `99`; it then binds
    the variable `b` to this new `int` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statement `c = a + b` creates the int object whose value is `1333` as the
    sum of the value of the `int` object bound to `a` and the value of the `int` object
    bound to `b`; it then binds the variable `c` to the new `int` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `str` data type represents strings, for use in text processing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Str Data Type](../Images/f4736aed039e1c6e012186a3cdf8efe2.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '![Ruler](../Images/d699e251e32cf294c2122790f39c2976.png)'
  prefs: []
  type: TYPE_IMG
- en: The value of a `str` object is a sequence of characters. You can specify a `str`
    literal by enclosing a sequence of characters in matching single quotes. You can
    concatenate two strings using the operator `+`. As an example, [ruler.py](ruler.py.html)
    computes a table of values of the ruler function that describes the relative lengths
    of the marks on a ruler.
  prefs: []
  type: TYPE_NORMAL
- en: Converting numbers to strings for output.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python provides the built-in function `str()` to convert numbers to strings.
    Our most frequent use of the string concatenation operator is to chain together
    the results of a computation for output with `stdio.write()` and `stdio.writeln()`,
    often in conjunction with the `str()` function, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If `a` and `b` are `int` objects whose values are `1234` and `99`, respectively,
    then that statement writes the line of output `1234 + 99 = 1333`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting strings to numbers for input.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python also provides built-in functions to convert strings (such as the ones
    we type as command-line arguments) to numeric objects. We use the Python built-in
    functions `int()` and `float()` for this purpose. If the user types `1234` as
    the first command-line argument, then the code `int(sys.argv[1])` evaluates to
    the `int` object whose value is `1234`.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `int` data type represents integers or natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Int Data Type](../Images/b8b24f8e09a3cb310d191cfa95bcdcd5.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Python includes operators for common arithmetic operations on integers, including
    `+` for addition, `-` for subtraction, `*` for multiplication, `//` for floored
    division, `%` for remainder, and `**` for exponentiation. All of these operators
    are defined just as in grade school (keeping in mind that the floored division
    operator results in an integer). Program [intops.py](intops.py.html) illustrates
    basic operations for manipulating `int` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Division in Python 2.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python 3, the `/` operator has the same behavior as the floating-point division
    operator when both its operands are integers. In Python 2, the `/` operator has
    the same behavior as the floored division operator `//` when both its operands
    are integers. For example, `17 / 2` evaluates to `8.5` in Python 3 and to `8`
    in Python 2\. For compatibility among Python versions, we do not use the `/` operator
    with two `int` operands in this booksite. |
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Floating-Point Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `float` data type is for representing floating-point numbers, for use in
    scientific and commercial applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Float Data Type](../Images/ca6bcdf5288a45ffc225e6afb1b82a49.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Python includes operators for common arithmetic operations on floats, including
    + for addition, - for subtraction, * for multiplication, / for division, and **
    for exponentiation. Program [floatops.py](floatops.py.html) illustrates the basic
    operations for manipulating `float` objects. Program [quadratic.py](quadratic.py.html)
    shows the use of `float` objects in computing the two roots of a quadratic equation
    using the quadratic formula.
  prefs: []
  type: TYPE_NORMAL
- en: We use floating-point numbers to represent real numbers, but they are decidedly
    not the same as real numbers! There are infinitely many real numbers, but we can
    represent only a finite number of floating-point numbers in any digital computer.
    For example, `5.0/2.0` evaluates to `2.5` but `5.0/3.0` evaluates to `1.6666666666666667`.
    Typically, floating-point numbers have 15–17 decimal digits of *precision*.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the `math.sqrt()` function in the [quadratic.py](quadratic.py.html)
    program. The standard `math` module defines trigonometric functions, logarithm/exponential
    functions, and other common mathematical functions. To use the `math` module,
    place the statement `import math` near the beginning of the program and then call
    functions using syntax such as `math.sqrt(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `bool` data type has just two values: `True` and `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bool Data Type](../Images/f42cabd8eb0f4912c0b24646b9ee05f3.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'The apparent simplicity is deceiving — booleans lie at the foundation of computer
    science. The most important operators defined for booleans are the *logical ooperators*:
    `and`, `or`, and `not`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a` and `b` is `True` if both operands are `True`, and `False` if either is
    `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a` or `b` is `False` if both operands are `False`, and `True` if either is
    `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not a` is `True` if `a` is `False`, and `False` if `a` is `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can formally specify the definition of each operation using truth tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boolean operators](../Images/450d6ca06d9a122100d8e5b6cc457cfd.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The comparison operators `==`, `!=`, `<`, `<=`, `>`, and `>=` are defined for
    both integers and floats, and evaluate to a boolean result.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4e02906da68392a72f69b28a72a8effa.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: The program [leapyear.py](leapyear.py.html) shows the use of boolean expressions
    and comparison operations to compute whether a given year is a leap year. Section
    1.3 of this booksite describes more common uses of the comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Functions and APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Api](../Images/2964e30b7dbaf2796aa7fdb8e9e3c37b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have seen, many programming tasks involve using *functions*. We distinguish
    three kinds of functions: *built-in functions* (such as `int()`, `float()`, and
    `str()`) that you can use directly in any Python program, *standard functions*
    (such as `math.sqrt()`) that are defined in a Python standard module and are available
    in any program that imports the module, and booksite functions (such as `stdio.write()`
    and `stdio.writeln()`) that are defined in this booksite modules and available
    for you to use after you have made them available to Python and imported them.
    We describe some more useful functions in this section. In later chapters, you
    will learn not just how to use other functions, but how to define and use your
    own functions.'
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, we summarize the functions that you need to know how to use
    in tables like the one shown on the right. Such a table is known as an *application
    programming interface (API)*. The table below shows some typical function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Type Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We often find ourselves converting data from one type to another using one of
    the following approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit type conversion.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Call functions such as `int()`, `float()`, `str()`, and `round()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Type conversion API](../Images/5dbb12bca9ae78946f2eeb4c75fdb10e.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Implicit type conversion (from integer to float).
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use an integer where a float is expected, because Python automatically
    converts integers to floats when appropriate. For example, `10/4.0` evaluates
    to `2.5` because `4.0` is a float and both operands need to be of the same type;
    thus, `10` is converted to a float and then the result of dividing two floats
    is a float. This kind of conversion is called *automatic promotion* or *coercion*.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you issue the command `python` (that is, the word `python` stand-alone, with
    no following file name) in your terminal window, Python identifies itself and
    writes a `>>>` prompt. At that point you can type a Python statement and Python
    will execute it. Or, you can type a Python expression and Python will evaluate
    it and write the resulting value. Or, you can type `help()` to get access to Python's
    extensive interactive documentation. This is a convenient way to test new constructs
    and access documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '![InteractivePython1](../Images/2828a17c80c6751c06262b0dec6f3199.png) ![InteractivePython2](../Images/a05292f8cb7153ced84277b1f1affb9d.png)'
  prefs: []
  type: TYPE_IMG
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Q & A: Strings'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** How does Python store strings internally?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Strings are sequences of characters that are encoded with Unicode, a
    modern standard for encoding text. Unicode supports over 100,000 different characters,
    including more than 100 different languages plus mathematical and musical symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Which data type does Python provide for characters?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Python has no special data type for characters. A character is simply
    a string consisting of one element, such as `''A''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I compare strings using comparison operators such as `==` and <
    or built-in functions such as `max()` and `min()`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes. Informally, Python uses *lexicographic order* to compare two strings,
    like words in a book index or dictionary. For example, `''hello''` and `''hello''`
    are equal, `''hello''` and `''goodbye''` are unequal, and `''goodbye''` is less
    than `''hello''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I use matching double quotes for string literals instead of single
    quotes?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes. For example, `''hello''` and `"hello"` are identical literals.
    Double quotes are useful to specify a string that contains single quotes, so that
    you don''t need to escape them. For example, `''Python\''s''` and `"Python''s"`
    are identical string literals. You can also use matching triple quotes for multiline
    strings. For example, the following creates a two-line string and assigns it to
    the variable `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this booksite, we do not use double or triple quotes to delimit string literals.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Strings in Python 2.** Python 2 uses ASCII instead of Unicode to encode
    characters. ASCII is a legacy standard that supports 128 characters, including
    the English alphabet, numbers, and punctuation. Python 2 offers a separate data
    type unicode for strings composed of Unicode characters, but many Python 2 libraries
    do not support it. |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Q & A: Integers'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** How does Python store integers internally?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The simplest representation is for small positive integers, where the
    binary number system is used to represent each integer with a fixed amount of
    computer memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What''s the binary number system?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** In the binary number system, we represent an integer as a sequence of
    bits. A bit is a single binary (base 2) digit — either 0 or 1 — and is the basis
    for representing information in computers. In this case the bits are coefficients
    of powers of 2\. Specifically, the sequence of bits *b[n]b[n-1]...b[2]b[1]b[0]*
    represents the integer'
  prefs: []
  type: TYPE_NORMAL
- en: '*b[n]2^n + b[n-1]2^(n-1) + ... + b[2]2² + b[1]2¹ + b[0]2⁰*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, 1100011 represents the integer
  prefs: []
  type: TYPE_NORMAL
- en: 99 = 1 · 64 + 1 · 32 + 0 · 16 + 0 · 8 + 0 · 4 + 1 · 2 + 1 · 1.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The more familiar decimal number system is the same except that the digits are
    between zero and 9 and we use powers of 10\. Converting a number to binary is
    an interesting computational problem that we will consider in the next section.
    For small integers, Python uses a fixed number of bits, typically dictated by
    a basic design parameter of your computer —usually 32 or 64\. For example, the
    integer 99 might be represented with the 32 bits `00000000000000000000000001100011`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How about negative numbers?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Small negative numbers are handled with a convention known as *two''s
    complement*, which we need not consider in detail. The definition of "small" depends
    on the underlying computer system. On older 32-bit machines, "small" typically
    covers the range -2147483648 (-2^(31)) to 2147483647 (2^(31) - 1). On newer 64-bit
    machines, "small" typically covers the range -2^(63) to 2^(63) - 1, in which case
    "small" is not so small! If an integer is not "small," then Python automatically
    uses a more elaborate representation whose range is limited only by the amount
    of memory available on your computer system. Note that details of these internal
    representations are hidden from your programs, so you can use them in systems
    with different representations without having to change them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What does the expression `1/0` evaluate to in Python?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** It raises a `ZeroDivisionError` at run time. Note: The easiest way to
    answer such questions is to use Python''s interactive mode. Try it!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How do the floored division operator `//` and remainder operator `%`
    work on negative operands?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Try them and see! `-47 // 5` evaluates to `-10` and `-47 % 5` evaluates
    to `3`. Generalizing, the floored division operator `//` yields the floored quotient;
    that is, the quotient is rounded toward minus infinity. The behavior of the remainder
    operator `%` is more complicated. In Python, if `a` and `b` are integers, then
    the expression `a % b` evaluates to an integer that has the same sign as `b`.
    This implies that `b * (a // b) + a % b == a` for any integers `a` and `b`. In
    some other languages (such as Java), the expression `a % b` evaluates to an integer
    that has the same sign as `a`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How does the exponentiation operator `**` work with negative operands?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Try it out and see for yourself. Note that the `**` operator has higher
    precedence than a unary plus/minus operator on its left but lower precedence than
    a unary plus/minus operator on its right. For example, `-3**4` evaluates to `-81`
    (and not `81`). Also, it can result in an object of a different type. For example,
    `10**-2` evaluates to the float `0.01` and `(-10)**(10**-2)` evaluates to a complex
    number in Python 3 (but raises a run-time error in Python 2).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Why does `10^6` evaluate to `12` instead of `1000000`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The `^` operator is not an exponentiation operator, which you must have
    been thinking. Instead, it is an operator that we do not use in this book. You
    want the literal `1000000`. You could use the expression `10**6`, but it is wasteful
    to use an expression (which requires evaluation at run time) when a literal would
    suffice.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Integers in Python 2**. Python 2 supports two separate types for integers
    — `int` (for small integers) and `long` (for larger integers). Python 2 automatically
    promotes from type `int` to `long` whenever necessary. |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Q & A: Floating point numbers'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** Why is the type for real numbers named `float`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The decimal point can "float" across the digits that make up the real
    number. In contrast, with integers the (implicit) decimal point is fixed after
    the least significant digit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How does Python store floating-point numbers internally?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Generally, Python uses the representation that is natural for the underlying
    computer system. Most modern computer systems store floating-point numbers as
    defined by the IEEE 754 standard. That standard specifies that a floating-point
    number is stored using three fields: sign, mantissa, and exponent. If you are
    interested, see the the Wikipedia [IEEE floating point]( http://en.wikipedia.org/wiki/IEEE_floating_point)
    page for more details. The IEEE 754 standard also specifies how special floating-point
    values — positive zero, negative zero, positive infinity, negative infinity, and
    `NaN` (not a number) — should be handled. For example, it specifies that `-0.0/3.0`
    should evaluate to `-0.0`, `1.0/0.0` should evaluate to positive infinity, and
    `0.0/0.0` should evaluate to `NaN`. You can use the (rather unusual) expressions
    `float(''inf'')` and `float(''-inf'')` for positive and negative infinity in some
    simple calculations, but Python does not conform to this part of the IEEE 754
    standard. For example, in Python, `-0.0/3.0` correctly evaluates to `-0.0`, but
    both `1.0/0.0` and `0.0/0.0` raise a `ZeroDivisionError` at run time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Fifteen digits for floating-point numbers certainly seems enough to
    me. Do I really need to worry much about precision?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, because you are used to mathematics based on real numbers with
    infinite precision, whereas the computer always deals with approximations. For
    example, in IEEE 754 floating point, the expression `(0.1 + 0.1 == 0.2)` evaluates
    to `True` but `(0.1 + 0.1 + 0.1 == 0.3)` evaluates to `False`! Pitfalls like this
    are not at all unusual in scientific computing. Novice programmers should avoid
    comparing two floating-point numbers for equality.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** It is annoying to see all those digits when writing a float. Is it possible
    to get `stdio.write()` and `stdio.writeln()` to write just two or three digits
    after the decimal point?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** The booksite function `stdio.writef()` is one way to do the job — it
    is similar to the basic formatted writing function in the C programming language
    and many other modern languages, as discussed in Section 1.5\. Until then, we
    will live with the extra digits (which is not all bad, since doing so helps us
    to get used to the different types of numbers).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I apply the floored division operator `//` to two float operands?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, it produces the floored division of its operands. That is, the
    result is the quotient in which digits after the decimal place are removed. We
    do not use the floored division operator on floats in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** What does `round()` return if the fractional part of its argument is
    `0.5`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** In Python 3, it returns the nearest even integer, so `round(2.5)` is
    `2`, `round(3.5)` is `4`, and `round(-2.5)` is `-2`. But in Python 2, the `round()`
    function rounds away from zero (and returns a float), so `round(2.5)` is `3.0`,
    `round(3.5)` is `4.0`, and `round(-2.5)` is `-3.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I compare a `float` to an `int`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Not without doing a type conversion, but remember that Python does the
    requisite type conversion automatically. For example, if `x` is the integer `3`,
    then the expression `(x < 3.1)` evaluates to `True` because Python promotes the
    integer `3` to generate the float `3.0` and then compares `3.0` with `3.1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Are there functions in Python''s `math` module for other trigonometric
    functions, such as arc sine, hyperbolic sine, and secant?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, Python''s `math` module includes inverse trigonometric functions
    and hyperbolic functions. However, there are no functions for secant, cosecant,
    and cotangent because you could use `math.sin()`, `math.cos()`, and `math.tan()`
    to compute them easily. Choosing which functions to include in an API is a tradeoff
    between the convenience of having every function that you need and the annoyance
    of having to find one of the few that you need in a long list. No choice will
    satisfy all users, and the Python designers have many users to satisfy. Note that
    there are plenty of redundancies even in the APIs that we have listed. For example,
    you could use `math.sin(x) / math.cos(x)` instead of `math.tan(x)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Q & A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** What happens if I access a variable that I haven''t bound to an object?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Python will raise a `NameError` at run time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How can I determine the type of a variable?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** That''s a trick question. Unlike variables in many programming languages
    (such as Java), a Python variable does not have a type. Instead, it is the object
    to which a variable is bound that has a type. You can bind the same variable to
    objects of different types, as in this code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, for clarity, it's usually a bad idea to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** How can I determine the type, identity, and value of an object?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Python provides built-in functions for this purpose. The function `type()`
    returns the type of an object; the function `id()` returns the identity of an
    object; the function `repr()` returns an unambiguous string representation of
    an object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will rarely use these functions in ordinary programming, but you may find
    them useful when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Is there a difference between `=` and `==` ?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, they are quite different! The first specifies an assignment to
    a variable, and the second is a comparison operator that produces a boolean result.
    Your ability to understand this answer is a sure test of whether you understood
    the material in this section. Think about how you might explain the difference
    to a friend.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Will `a < b < c` test whether the three numbers `a`, `b`, and `c` are
    in order?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, Python supports arbitrary chaining of comparisons such as `a <
    b < c` that behave according to standard mathematical conventions. However, in
    many programming languages (such as Java) the expression `a < b < c` is illegal
    because the subexpression `a < b` evaluates to a boolean and that boolean is then
    compared with a number, which is meaningless. We do not use chained comparisons
    in this book; instead we prefer expressions such as `(a < b) and (b < c)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Will `a = b = c = 17` set the three variables to 17?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, even though Python assignment statements are not expressions, Python
    supports arbitrary chaining of assignment statements. We do not use chained assignments
    in the book because many Python programmers consider it poor style.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I use the logical operators `and`, `or`, and `not` with operands
    that are not booleans?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, but for clarity it''s usually a bad idea to do so. In this context,
    Python considers `0`, `0.0`, and the empty string `''''` to mean `False`, and
    any other integer, float, or string to mean `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I use arithmetic operators with boolean operands?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, but again it''s bad form to do so. When you use boolean operands
    with arithmetic operators, they are promoted to integers: `0` for `False` and
    `1` for `True`. For example, `(False - True - True) * True` evaluates to the `int`
    value `-2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Can I name a variable `max`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Yes, but if you do, then you won''t be able to use the built-in function
    `max()`. The same holds for `min()`, `sum()`, `float()`, `eval()`, `open()`, `id()`,
    `type()`, `file()`, and other built-in functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose that `a` and `b` are integers. What does the following sequence of statements
    do? Draw an object-level trace of this computation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: The sequence sets `a`, `b`, and `t` to the original value of `a`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a program that uses `math.sin()` and `math.cos()` to check that the
    value of *cos² θ + sin² θ* is approximately `1.0` for any θ entered as a command-line
    argument. Just write the value. Why are the values not always exactly `1.0`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution (from Hassan Alam and Lee Jong Gil):*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Suppose that `a` and `b` are booleans. Show that this expression evaluates
    to `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Suppose that `a` and `b` are integers. Simplify the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution:* `a == b`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What does each of these statements write? Explain each outcome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Explain how to use [quadratic.py](quadratic.py.html) to find the square root
    of a number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution:* To find the square root of `c`, find the roots of `x² + 0x - c`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What does `stdio.writeln((1.0 + 2 + 3 + 4) / 4)` write?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose that `a` is `3.14159`. What do each of these statements write? Explain
    each outcome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Describe the effect of writing `sqrt` instead of `math.sqrt` in [quadratic.py](quadratic.py.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does (math.sqrt(2) * math.sqrt(2) == 2) evaluate to True or False?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that takes two positive integers as command-line arguments
    and writes `True` if either evenly divides the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a program that takes three positive integers as command-line arguments
    and writes `False` if any one of them is greater than or equal to the sum of the
    other two and `True` otherwise. (Note: This computation tests whether the three
    numbers could be the lengths of the sides of some triangle.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the value of `a` after the execution of each of the following sequences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A physics student gets unexpected results when using the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: to compute values according to the formula *F = Gm[1]m[2] / r²*. Explain the
    problem and correct the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution:* The code divides by `r`, and then multiplies by `r`. Instead it
    should divide by `r` squared. Use parentheses:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or use the exponentiation operator:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, better still for the sake of clarity, use both parentheses and the exponentiation
    operator:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Suppose that `x` and `y` are two floats that represent the Cartesian coordinates
    of a point *(x, y)* in the plane. Give an expression that evaluates to the distance
    of the point from the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution:* `math.sqrt(x*x + y*y)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a program that takes two integers `a` and `b` from the command line
    and writes a random integer between `a` and `b`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that writes the sum of two random integers between 1 and 6
    (such as you might get when rolling dice).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [sumoftwodice.py](sumoftwodice.py.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Compose a program that takes a float `t` from the command line and writes the
    value of *sin(2t) + sin(3t)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compose a program that takes three floats *x[0]*, *v[0]*, and *t* from the
    command line, evaluates *x[0] + v[0]t - Gt² / 2*, and writes the result. (*Note*:
    *G* is the constant 9.80665\. This value is the displacement in meters after *t*
    seconds when an object is thrown straight up from initial position *x[0]* at velocity
    *v[0]* meters per second.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program that takes two integers `m` and `d` from the command line
    and writes `True` if day *d* of month *m* is between March 20 and June 20, and
    False otherwise. (Interpret *m* with 1 for January, 2 for February, and so forth.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [spring.py](spring.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Continuously compounded interest.** Compose a program that calculates and
    writes the amount of money you would have if you invested it at a given interest
    rate compounded continuously, taking the number of years *t*, the principal *P*,
    and the annual interest rate *r* as commmand-line arguments. The desired value
    is given by the formula *pe^(rt)*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Wind chill.** Given the temperature *t* (in Fahrenheit) and the wind speed
    *v* (in miles per hour), the National Weather Service defines the effective temperature
    (the [wind chill](http://www.nws.noaa.gov/om/windchill/index.shtml)) to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| *w* = 35.74 + 0.6215 *t* + (0.4275 *t* - 35.75) *v*^(0.16) |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: 'Compose a program that takes two floats `t` and `v` from the command-line and
    writes the wind chill. *Note*: the formula is not valid if *t* is larger than
    50 in absolute value or if *v* is larger than 120 or less than 3 (you may assume
    that the values you get are in that range).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: See [windchill.py](windchill.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Polar](../Images/eeaa12f3fec9b21411bef3325e0087e5.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Polar coordinates.** Compose a program that converts from Cartesian to [polar
    coordinates](http://mathworld.wolfram.com/PolarCoordinates.html). Your program
    should accept two floats `x` and `y` from the command-line and write the polar
    coordinates *r* and *θ*. Use the Python function `math.atan2(y, x)`, which computes
    the arctangent value of *y/x* that is in the range from *-π* to `π`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [polar.py](polar.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Gaussian random numbers.** One way to generate a random number taken from
    the Gaussian distribution is to use the *Box-Muller* formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| *Z* = sin(2 π *v*) (-2 ln *u*)^(1/2) |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: where *u* and *v* are real numbers between 0 and 1 generated by the `random.random()`
    function. Compose a program that writes a standard Gaussian random variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Order check.** Compose a program that takes three floats `x`, `y`, and `z`
    as command-line arguments and writes `True` if the values are strictly ascending
    or descending (`x < y < z` or `x > y > z`), and `False` otherwise.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Day of the week.** Compose a program that accepts a date as input and writes
    the day of the week on which that date falls. Your program should accept three
    command-line arguments: `m` (month), `d` (day), and `y` (year). For `m` use 1
    for January, 2 for February, and so forth. For output write 0 for Sunday, 1 for
    Monday, 2 for Tuesday, and so forth. Use the following [formulas for the Gregorian
    calendar](https://www.tondering.dk/claus/cal/julperiod.php):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| *y[0]* = *y* - (14 - *m*) / 12 *x* = *y[0]* + *y[0]/4* - *y[0]*/100 + *y[0]*/400'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*m[0]* = *m* + 12 * ((14 - *m*) / 12) - 2'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*d[0]* = (*d* + *x* + (31**m[0]*)/ 12) mod 7 |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, on what day of the week was August 2, 1953?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| *y* = 1953 - 0 = 1953 *x* = 1953 + 1953/4 - 1953/100 + 1953/400 = 2426'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*m* = 8 + 12*0 - 2 = 6'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*d* = (2 + 2426 + (31*6) / 12) mod 7 = 2443 mod 7 = 0 (Sunday)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Solution*: See [day.py](day.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Uniform random numbers.** Compose a program that writes five uniform random
    floats between 0 and 1, their average value, and their minimum and maximum value.
    Use the built-in `max()` and `min()` functions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [stats1.py](stats1.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Mercator projection.** The [Mercator projection](http://en.wikipedia.org/wiki/Mercator_projection)
    is a conformal (angle preserving) projection that maps latitude *φ* and longitude
    *λ* to rectangular coordinates *(x, y)*. It is widely used — for example, in nautical
    charts and in the maps that you print from the web. The project is defined by
    the equations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| *x* = λ - λ[0] *y* = 1/2 * ln((1 + sin(φ)) / (1 - sin(φ))) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: where λ[0] is the longitude of the point in the center of the map. Compose a
    program that accepts λ[0] and the latitude and longitude of a point from the command
    line and writes its projection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Color conversion.** Several different formats are used to represent color.
    For example, the primary format for LCD displays, digital cameras, and web pages,
    known as the RGB format, specifies the level of red (R), green (G), and blue (B)
    on an integer scale from 0 to 255\. The primary format for publishing books and
    magazines, known as the CMYK format, specifies the level of cyan (C), magenta
    (M), yellow (Y), and black (K) on a real scale from 0.0 to 1.0\. Compose a program
    that converts RGB to CMYK. Accept three integers —r, g, and b —from the command
    line and write the equivalent CMYK values. If the RGB values are all 0, then the
    CMY values are all 0 and the K value is 1; otherwise, use these formulas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| *w* = max(*r*/255, *g*/255, *b*/255) |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| *c* = (*w* - *r*/255) / *w* |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| *m* = (*w* - *g*/255) / *w* |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| *y* = (*w* - *b*/255) / *w* |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| *k* = 1 - *w* |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: 'Here''s an example run:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: '![Great Circle](../Images/13904e699cc9ff92fd2aa41c22eda0b4.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Great circle.** Compose a program that takes four float command-line arguments
    `x1`, `y1`, `x2`, and `y2` (the latitude and longitude, in degrees, of two points
    on the earth) and writes the great-circle distance between them. The great-circle
    distance `d` (in nautical miles) is given by the formula derived from the law
    of cosines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| *d = 60 * arccos(sin(x[1]) * sin(x[2]) + cos(x[1]) * cos(x[2]) * cos(y[1]
    - y[2]))* |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: Note that this equation uses degrees, whereas Python's trigonometric functions
    use radians. Use `math.radians()` and `math.degrees()` to convert between the
    two. Use your program to compute the great-circle distance between Paris (48.87°
    N, -2.33° W) and San Francisco (37.8° N, 122.4° W).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note: the shape of the earth is more like a flattened spheroid than a sphere,
    so the formula above is only an approximation (up to around 0.5% error). Also,
    this formula is [unreliable for small distances](http://www.movable-type.co.uk/scripts/GIS-FAQ-5.1.html)
    because the inverse cosine function is ill-conditioned.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| *a = sin²((L2-L1)/2) + cos(L1) * cos(L2) * sin²((G2-G1)/2) c = 2 * arcsin(min(1,
    sqrt(a))) # distance in radians distance = 60 * c # nautical miles* |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: The Haversine formula is accurate for most distances, but it suffers from rounding
    errors when the points are (nearly) antipodal. The following [formula](http://en.wikipedia.org/wiki/Great-circle_distance#The_formula)
    is accurate for all distances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| *delta = G1 - G2 p1 = cos(L2) * sin(delta) p2 = cos(L1) * sin(L2) - sin(L1)
    * cos(L2) * cos(delta) p3 = sin(L1) * sin(L2) + cos(L1) * cos(L2) * cos(delta)
    distance = 60 * atan2(sqrt(p1*p1 + p2*p2), p3)* |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: This [Kahan reference](http://www.cs.berkeley.edu/~wkahan/Math128/angle.pdf)
    provides more details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: See [greatcircle.py](greatcircle.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Three-sort.** Compose a program that accepts three integers from the command
    line and writes them in ascending order. Use the built-in `min()` and `max()`
    functions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [threesort.py](threesort.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Dragon curves](../Images/b939c3d8907b68a54c185cc9b3b899d8.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Dragon curve.** Compose a program to write the instructions for drawing the
    [dragon curves](http://www.jimloy.com/fractals/dragon.htm) of order 0 through
    5\. The instructions are strings of the characters `F`, `L`, and `R`, where `F`
    means "draw line while moving 1 unit forward", `L` means "turn left", and `R`
    means turn right. A dragon curve of order `n` is formed when you fold a strip
    of paper in half `n` times, then unfold to right angles. The key to solving this
    problem is to note that a curve of order *n* is a curve of order *n-1* followed
    by an *L* followed by a curve of order *n-1* traversed in reverse order, and then
    to figure out a similar description of the reverse curve.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [dragon1.py](dragon1.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
