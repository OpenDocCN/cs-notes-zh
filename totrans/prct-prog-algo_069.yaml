- en: 2.3 Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/python/23recursion](https://introcs.cs.princeton.edu/python/23recursion)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The idea of calling one function from another immediately suggests the possibility
    of a function calling *itself*. The function-call mechanism in Python supports
    this possibility, which is known as *recursion*. Recursion is a powerful general-purpose
    programming technique, and is the key to numerous critically important computational
    applications, ranging from combinatorial search and sorting methods methods that
    provide basic support for information processing (Chapter 4) to the Fast Fourier
    Transform for signal processing.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Your First Recursive Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The "HelloWorld" program for recursion is to implement the *factorial* function,
    which is defined for positive integers `n` by the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n*! = *n* × (*n*-1) × (*n*-2) × ... × 2 × 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*n*! is easy to compute with a `for` loop, but an even easier method, used
    in [factorial.py](factorial.py.html) is to use the following recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can persuade yourself that it produces the desired result by noting that
    `factorial()` returns 1 = 1! when *n* is 1 and that if it properly computes the
    value
  prefs: []
  type: TYPE_NORMAL
- en: (*n*-1)! = (*n*-1) × (*n*-2) × ... × 2 × 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: then it properly computes the value
  prefs: []
  type: TYPE_NORMAL
- en: '*n*! = *n* × (*n*-1)! = *n* × (*n*-1) × (*n*-2) × ... × 2 × 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can trace this computation in the same way that we trace any sequence of
    function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our `factorial()` implementation exhibits the two main components that are required
    for every recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: The *base case* returns a value without making any subsequent recursive calls.
    It does this for one or more special input values for which the function can be
    evaluated without recursion. For `factorial()`, the base case is `n = 1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *reduction step* is the central part of a recursive function. It relates
    the function at one (or more) inputs to the function evaluated at one (or more)
    other inputs. Furthermore, the sequence of parameter values must *converge* to
    the base case. For `factorial()`, the reduction step is `n * factorial(n-1)` and
    `n` decreases by one for each call, so the sequence of parameter values converges
    to the base case of `n = 1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Induction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursive programming is directly related to *mathematical induction*, a technique
    for proving facts about discrete functions. Proving that a statement involving
    an integer `n` is true for infinitely many values of *n* by mathematical induction
    involves two steps.
  prefs: []
  type: TYPE_NORMAL
- en: The *base case* is to prove the statement true for some specific value or values
    of *n* (usually 0 or 1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *induction step* is the central part of the proof. For example, we typically
    assume that a statement is true for all positive integers less than *n*, then
    use that fact to prove it true for *n*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such a proof suffices to show that the statement is true for all *n*: we can
    start at the base case, and use our proof to establish that the statement is true
    for each larger value of *n*, one by one.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Euclid's Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *greatest common divisor (gcd)* of two positive integers is the largest
    integer that divides evenly into both of them. For example, the greatest common
    divisor of 102 and 68 is 34 since both 102 and 68 are multiples of 34, but no
    integer larger than 34 divides evenly into 102 and 68.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can efficiently compute the gcd using the following property, which holds
    for positive integers `p` and `q`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*If p > q, the gcd of p and q is the same as the gcd of q and p % q.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function `gcd()` in [euclid.py](euclid.py.html) is a compact recursive function
    whose reduction step is based on this property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Towers of Hanoi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No discussion of recursion would be complete without the ancient *Towers of
    Hanoi* problem. We have three poles and *n* discs that fit onto the poles. The
    discs differ in size and are initially arranged on one of the poles, in order
    from largest (disc *n*) at the bottom to smallest (disc 1) at the top. The task
    is to move the stack of discs to another pole, while obeying the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Move only one disc at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never place a disc on a smaller one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To solve the problem, our goal is to issue a sequence of instructions for moving
    the discs. We assume that the poles are arranged in a row, and that each instruction
    to move a disc specifies its number and whether to move it left or right. If a
    disc is on the left pole, an instruction to move left means to wrap to the right
    pole; if a disc is on the right pole, an instruction to move right means to wrap
    to the left pole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursion provides the plan that we need, based on the following idea: first
    we move the top *n*-1 discs to an empty pole, then we move the largest disc to
    the other empty pole (where it does not interfere with the smaller ones), and
    then we compete the job by moving the *n*-1 discs onto the largest disc. The [towersofhanoi.py](towersofhanoi.py.html)
    program is a direct implementation of that plan.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Exponential Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![exponential growth](../Images/938fdb6e176f7cff0dbb9076aeb490e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One legend says that the world will end when a certain group of monks solves
    the Towers of Hanoi problem in a temple with 64 golden discs on three diamond
    needles. We can estimate the amount of time until the end of the world (assuming
    that the legend is true). If we define the function *T*(*n*) to be the number
    of move directives issued by `towersofhanoi.py` to move *n* discs from one peg
    to another, then the recursive code implies that *T*(*n*) must satisfy the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T*(*n*) = 2 *T*(*n* - 1) + 1 for *n* > 1, with *T*(1) = 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Such an equation is known in discrete mathematics as a *recurrence relation*.
    We can often use them to derive a closed-form expression for the quantity of interest.
    For example, *T*(1) = 1, *T*(2) = 3, *T*(3) = 7, and *T*(4) = 15\. In general,
    *T*(*n*) = 2^(*n*) - 1.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the value of *T*(*n*), we can estimate the amount of time required to
    perform all the moves. If the monks move discs at the rate of one per second,
    it would take more than one week for them to finish a 20-disc problem, more than
    31 years to finish a 30-disc problem, and more than 348 centuries for them to
    finish a 40-disc problem (assuming that they do not make a mistake). The 64-disc
    problem would take more than 5.8 billion centuries.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Gray Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The playwright Samuel Beckett wrote a play called *Quad* that had the following
    property: Starting with an empty stage, characters enter and exit one at a time,
    but each subset of characters on the stage appears exactly once. The play had
    four characters and there are 2⁴ = 16 different subsets of four elements; hence
    the title. How did Beckett generate the stage directions for this play? How would
    we do it for 5 actors, or more?'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Gray code representations](../Images/b0e061fba5db48825073246abc8e08c7.png)
    |  | ![2-, 3-, and 4-bit Gray codes](../Images/bbd92b4dd7b1530237ef0f915aa75545.png)
    |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: An *n*-bit *Gray code* is a list of the 2^(*n*) different *n*-bit binary numbers
    such that each entry in the list differs in precisely one bit from its predecessor.
    Gray codes directly apply to Beckett's problem because we can interpret each bit
    as denoting whether the integer corresponding to its bit position is in the subset.
    Changing the value of a bit from 0 to 1 corresponds to an integer entering the
    subset; changing a bit from 1 to 0 corresponds to and integer exiting the subset.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we generate a Gray code? A recursive plan that is very similar to the
    one that we used for the Towers of Hanoi problem is effective. The *n* bit binary
    reflected Gray code is defined recursively as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: the *n*-1 bit code, with 0 prepended to each word, followed by
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the *n*-1 bit code in reverse order, with 1 prepended to each word.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 0-bit code is defined to be null, so the 1-bit code is 0 followed by 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive definition leads, after some careful thought, to the implementation
    in [beckett.py](beckett.py.html) for writing Beckett's stage directions.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simple recursive drawing schemes can lead to pictures that are remarkably intricate.
    For example, an *H-tree of order n* is defined as follows: The base case is null
    for *n* = 0\. The reduction step is to draw, within the unit square three lines
    in the shape of the letter H four H-trees of order *n*-1, one connected to each
    tip of the H with the additional provisos that the H-trees of order *n*-1 are
    centered in the four quadrants of the square, halved in size. Program [htree.py](htree.py.html)
    takes a command-line argument `n`, and plots an order *n* H-tree using standard
    draw.'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![htree 1](../Images/c3ed4edf61ea3ca596d5ecf00bf3511f.png) | ![htree 2](../Images/1a8232d62b444aff139b3a8508dc2be6.png)
    | ![htree 3](../Images/b942420950f82948387919d9aee0eabd.png) | ![htree 4](../Images/3436d0cfb6f0833018f5aac682bc598f.png)
    | ![htree 5](../Images/5d6ca3619e95c5a86a988cd0b8701433.png) |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Brownian Bridge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An H-tree is a simple example of a *fractal*: a geometric shape that can be
    divided into parts, each of which is (approximately) a reduced size copy of the
    original. The study of fractals plays an important and lasting role in artistic
    expression, economic analysis, and scientific discovery. Artists and scientists
    use them to build compact models of complex shapes that arise in nature and resist
    description using conventional geometry, such as clouds, plants, mountains, riverbeds,
    human skin, and many others. Economists also use fractals to model function graphs
    of economic indicators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Program [brownian.py](brownian.py.html) produces a function graph that approximates
    a simple example known as a *Brownian bridge* and closely related functions. You
    can think of this graph as a random walk that connects two points, from (*x*[0],
    *y*[0]) to (*x*[1], *y*[1]), controlled by a few parameters. The implementation
    is based on the *midpoint displacement method*, which is a recursive plan for
    drawing the plot within an interval [*x*[0], *x*[1]]. The base case (when the
    size of the interval is smaller than a given tolerance) is to draw a straight
    line connecting the two endpoints. The reduction case is to divide the interval
    into two halves, proceeding as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the midpoint (*x*[*m*], *y*[*m*]) of the interval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add to the `y`-coordinate of the midpoint a random value *δ*, chosen from the
    Gaussian distribution with mean 0 and given variance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recur on the subintervals, dividing the variance by a given scaling factor *s*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The shape of the curve is controlled by two parameters: the *volatility* (initial
    value of the variance) controls the distance the graph strays from the straight
    line connecting the points, and the *Hurst exponent* controls the smoothness of
    the curve. We denote the Hurst exponent by *H* and divide the variance by 2^(2*H*)
    at each recursive level. When *H* is 1/2 (divide by 2 at each level) the standard
    deviation is constant throughout the curve: in this situation, the curve is a
    Brownian bridge. These images show the output generated by the commands `python
    brownian.py 1`, `python brownian.py .5`, and `python brownian.py .05`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Brownian bridge](../Images/f68c09b7605aa0186306f5df9ad635ad.png) | ![Brownian
    bridge](../Images/114230a603be3f1fd0f2eb194bd18644.png) | ![Brownian bridge](../Images/715f81008644e03f7bf0f0902cac534e.png)
    |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls of Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With recursion, you can compose compact and elegant programs that fail spectacularly
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Missing base case**. This recursive function is supposed to compute Harmonic
    numbers, but is missing a base case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you call this function, it will repeatedly call itself and never return.
  prefs: []
  type: TYPE_NORMAL
- en: '**No guarantee of convergence.** Another common problem is to include within
    a recursive function a recursive call to solve a subproblem that is not smaller.
    For example, this recursive function will go into an infinite recursive loop if
    it is invoked with an argument n having any value other than 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Excessive space requirements.** Python needs to keep track of each recursive
    call to implement the function abstraction as expected. If a function calls itself
    recursively an excessive number of times before returning, the space required
    by Python for this task may be prohibitive. For example, this recursive function
    correctly computes the nth harmonic number. However, we cannot use it for large
    *n* because the recursive depth is proportional to *n*, and this creates a `StackOverflowError`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Wrong way to compute Fibonacci numbers](../Images/2607a96b65fea126267c99324a64e48e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Excessive recomputation.** The temptation to write a simple recursive program
    to solve a problem must always be tempered by the understanding that a simple
    program might require exponential time (unnecessarily), due to excessive recomputation.
    For example, the Fibonacci sequence'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: is defined by the formula *F*[*n*] = *F*[*n*-1] + *F*[*n*-2] for *n* ≥ 2 with
    *F*[0] = 0 and *F*[1] = 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'A novice programmer might implement this recursive function to compute numbers
    in the Fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, this program is spectacularly inefficient! For example, consider what
    the function does to compute `fib(7)` = 13\. It first computes `fib(6)` = 8 and
    `fib(5)` = 5\. To compute `fib(6)`, it recursively computes `fib(5)` = 5 again
    and `fib(4)` = 3\. Things rapidly get worse because both times it computes `fib(5)`,
    it ignores the fact that it already computed `fib(4)`, and so forth. The number
    of times this program computes `fib(1)` when computing `fib(n)` is precisely *F*[*n*].
    The mistake of recomputation is compounded, exponentially. No imaginable computer
    will ever be able to do that many calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, a systematic technique known as *memoization* allows us to avoid
    this pitfall while still taking advantage of the compact recursive description
    of a computation. In memoization, we maintain an array that keeps track of the
    values we have computed so that we can return those values and make recursive
    calls only for new values. This technique is a form of *dynamic programming*,
    a well-studied technique for organizing computations that you will learn if you
    take courses in algorithms or operations research.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Q & A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Q.** Are there situations when iteration is the only option available to
    address a problem?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** No, any loop can be replaced by a recursive function, though the recursive
    version might require excessive memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Are there situations when recursion is the only option available to
    address a problem?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** No, any recursive function can be replaced by an iterative counterpart.
    In Section 4.3, we will see how compilers produce code for function calls by using
    a data structure called a *stack*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** Which should I prefer, recursion or iteration?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Whichever leads to the simpler, more easily understood, or more efficient
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** I get the concern about excessive space and excessive recomputation
    in recursive code. Anything else to be concerned about?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A.** Be extremely wary of creating arrays in recursive code. The amount of
    space used can pile up very quickly, as can the amount of time required for memory
    management.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What happens if you run `factorial()` with negative value of `n`? With a large
    value, say 35?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a recursive program that computes the value of *ln*(*n*!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the sequence of integers written by a call to `ex233(6)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Give the value of `ex234(6)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Criticize the following recursive function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: The base case will never be reached. A call to `ex235(3)` will
    result in calls to `ex235(0)`, `ex235(-3)`, `ex235(-6)`, and so forth until the
    "maximum depth exceeded" run-time error occurs.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given four positive integers `a`, `b`, `c`, and `d`, explain what value is computed
    by `gcd(gcd(a, b), gcd(c, d))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain in terms of integers and divisors the effect of the following Euclid-like
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution.* Returns whether `p` and `q` are relatively prime.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Consider the following recursive function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What are the values of `mystery(2, 25)` and `mystery(3, 11)`? Given positive
    integers `a` and `b`, describe what value `mystery(a, b)` computes. Answer the
    same question, but replace `+` with `*` and replace `return 0` with `return 1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution.* 50 and 33\. It computes `a*b`. If you replace `+` with `*`, it
    computes `a^b`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compose a recursive program `ruler.py` to plot the subdivisions of a ruler using
    `stddraw` as in the [ruler.py](../12types/ruler.py.html) program from Section
    1.2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the following recurrence relations, all with *T*(1) = 1\. Assume *n* is
    a power of two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*T*(*n*) = *T*(*n*/2) + 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*T*(*n*) = 2*T*(*n*/2) + 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*T*(*n*) = 2*T*(*n*/2) + *n*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*T*(n) = 4*T*(*n*/2) + 3'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prove by induction that the minimum possible number of moves needed to solve
    the Towers of Hanoi puzzle satisfies the same recurrence as the number of moves
    used by our recursive solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prove by induction that the recursive program given above makes exactly *F*[*n*]
    recursive calls to `fib(1)` when computing `fib(n)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prove that the second argument to `gcd()` decreases by at least a factor of
    two for every second recursive call, then prove that `gcd(p, q)` uses at most
    log[2]*n* recursive calls, where *n* is the larger of *p* and *q*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify `htree.py` to animate the drawing of the H-tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Animated h-tree](../Images/39c8c4e203a2ebfdfcab9deac295cf57.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Next, rearrange the order of the recursive calls (and the base case), view the
    resulting animation, and explain each outcome.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Binary representation.** Compose a program that takes a positive integer
    *n* (in decimal) from the command line and writes its binary representation. Recall
    that in Section 1.3 we used the method of subtracting out powers of 2\. Instead,
    use the following simpler method: repeatedly divide 2 into *n* and read the remainders
    backwards. First, compose a `while` loop to carry out this computation and write
    the bits in the wrong order. Then, use recursion to write the bits in the correct
    order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [binaryconverter.py](binaryconverter.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A4 paper.** The width-to-height ratio of paper in the [ISO format](http://www.cl.cam.ac.uk/~mgk25/iso-paper.html)
    is the square root of 2 to 1\. Format A0 has an area of 1 square meter. Format
    A1 is A0 cut with a vertical line into two equal halves, A2 is A1 cut with a horizontal
    line into in two halves, and so on. Write a program that takes a command-line
    argument *n* and uses `stddraw` to show how to cut a sheet of A0 paper into 2^(*n*)
    pieces. Here''s a nice [illustration of A size formats](http://upload.wikimedia.org/wikipedia/commons/b/b7/A_size_illustration.png).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Permutations.** Compose a program that takes a command-line argument *n*
    and writes all *n*! permutations of the *n* letters starting at a (assume that
    `n` is no greater than 26). A *permutation* of *n* elements is one of the *n*!
    possible orderings of the elements. As an example, when *n* = 3 you should get
    the following output. Do not worry about the order in which you enumerate them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: See [permutations.py](permutations.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Permutations of size *k*.** Modify your solution to the previous exercise
    so that it takes two command-line arguments *n* and *k*, and writes all *P*(*n*,
    *k*) = *n*! / (*n*-*k*)! permutations that contain exactly *k* of the *n* elements.
    Below is the desired output when *k* = 2 and *n* = 4\. You need not write them
    in any particular order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: See [perm.py](perm.py.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Combinations.** Compose a program that takes one integer command-line argument
    *n* and writes all 2^(*n*) *combinations* of any size. A combination is a subset
    of the *n* elements, independent of order. As an example, when *n* = 3 you should
    get the following output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the first element written is the empty string (subset of size 0).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: See [combinations.py](combinations.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Combinations of size `k`.** Modify your solution to the previous exercise
    so that it takes two command-line arguments *n* and *k*, and writes all *C**(n*,
    *k*) = *n*! / (*k*! * (*n*-*k*)!) *combinations* of size *k*. For example, when
    *n* = 5 and *k* = 3 you should get the following output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: See [comb.py](comb.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hamming distance.** The Hamming distance between two bit strings of length
    *n* is equal to the number of bits in which the two strings differ. Compose a
    program that takes an integer *k* and a bit string *s* from the command line,
    and writes all bit strings that have Hamming distance at most *k* from *s*. For
    example if *k* is 2 and *s* is 0000 then your program should write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Hint*: choose *k* of the *n* bits in *s* to flip.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Recursive squares.** Compose a program to produce each of the following recursive
    patterns. The ratio of the sizes of the squares is 2.2:1\. To draw a shaded square,
    draw a filled gray square, then an unfilled black square.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/84ea47fc520362efa19ee7fe093ebd72.png) | ![](../Images/4b5a9b292b61ca6bb9ad851f123df731.png)
    | ![](../Images/95575c922f02cb3ef1ff49e6365a3ef9.png) | ![](../Images/75a5acb259f4112db5e0a1cdb2636b42.png)
    |'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_TB
- en: '| ![](../Images/7d9550b3af8284e66a563d4cb6fedb11.png) | ![](../Images/43519ae4e5ee974eaf460c59556276ec.png)
    | ![](../Images/9b6373f947301245661d48dfb666c3e2.png) | ![](../Images/a3bd5bf4e15b0f9d922d58648161224a.png)
    |'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_TB
- en: '| ![](../Images/f5757b88ff729bf3e506ca924d9e86ae.png) | ![](../Images/4fb704e173a67519fc558b58418a8010.png)
    | ![](../Images/b7685f4ac2b3d02c87838c04e2663e62.png) | ![](../Images/32fec4c578cf37ccc67731cf363cd81d.png)
    |'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_TB
- en: '| ![](../Images/a03dc5dedb6595f00ffc14516c3797f7.png) | ![](../Images/56eddbdeca4aca351d0c00dab3219c78.png)
    | ![](../Images/7c035dd9d3443560c3e1435c56e8e7fa.png) | ![](../Images/bfe8dbbcf5f16647fdc8c5c3face91c0.png)
    |'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_TB
- en: '*Solution*: See [recursivesquares.py](recursivesquares.py.html) for a solution
    to part a.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Pancake flipping.** You have a stack of *n* pancakes of varying sizes on
    a griddle. Your goal is to rearrange the stack in descending order so that the
    largest pancake is on the bottom and the smallest one is on top. You are only
    permitted to flip the top *k* pancakes, thereby reversing their order. Devise
    a scheme to arrange the pancakes in the proper order by using at most 2*n* - 3
    flips.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint*: you can [try out strategies](http://www.cut-the-knot.org/SimpleGames/Flipper.shtml)
    here.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Gray code.** Modify `beckett.py` to write the Gray code, not just the sequence
    of bit positions that change.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [graycode.py](graycode.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Towers of Hanoi variant.** Consider the following variant of the Towers of
    Hanoi problem. There are 2*n* discs of increasing size stored on three poles.
    Initially all of the discs with odd size (1, 3, ..., 2*n*-1) are piled on the
    left pole from top to bottom in increasing order of size; all of the discs with
    even size (2, 4, ..., 2*n*) are piled on the right pole. Compose a program to
    provide instructions for moving the odd discs to the right pole and the even discs
    to the left pole, obeying the same rules as for Towers of Hanoi.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Animated Towers of Hanoi.** Compose a program that uses `stddraw` to animate
    a solution to the Towers of Hanoi problem, moving the discs at a rate of approximately
    1 per second.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: See [animatedhanoi.py](animatedhanoi.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Sierpinski triangles.** Compose a recursive program to draw the *Sierpinski
    gasket*. As with `htree.py`, use a command-line argument to control the depth
    of recursion.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![Sierpinski triangle](../Images/2065f570826dc0c2202b64d2bb777fe7.png) |
    ![Sierpinski triangle](../Images/dd0b7ae0b3555d26a04c6048ed104773.png) | ![Sierpinski
    triangle](../Images/fab7963c2bc03de38f58002c92e9c06b.png) | ![Sierpinski triangle](../Images/c4dc38fe3b42fbf14ccc7af8a8b9f59e.png)
    |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| ![Sierpinski triangle](../Images/604e180b643069181ec0e309117846cf.png) |
    ![Sierpinski triangle](../Images/e730d56b1b86f07d1c26e73cb7e4ff19.png) | ![Sierpinski
    triangle](../Images/01168b3d68969b70be2be7ffca8a7fd2.png) | ![Sierpinski triangle](../Images/fff92ac380765c8e1f22fc1f3942fc31.png)
    |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '**Binomial distribution.** Estimate the number of recursive calls that would
    be used by the code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'to compute `binomial(100, 50)`. Develop a better implementation that is based
    on memoization. *Hint*: see the *Binomial coefficients* exercise in Section 1.4.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A strange function.** Consider McCarthy''s 91 function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Determine the value of `mcCarthy(50)` without using a computer. Give the number
    of recursive calls used by `mcCarthy()` to compute this result. Either prove that
    the base case is reached for all positive integers *n* or give a value of *n*
    for which this function goes into an infinite recursive loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Collatz function.** Consider the following recursive function in [collatz.py](collatz.py.html),
    which is related to a famous unsolved problem in number theory, known as the [Collatz
    problem](http://mathworld.wolfram.com/CollatzProblem.html) or the *3n + 1 problem*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For example, a call to `collatz(7)` writes the sequence of 17 integers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: after 17 function calls. Compose a program that takes a command-line argument
    *m* and returns the value of *n* < *m* for which the number of recursive calls
    for `collatz(n)` is maximized. The unsolved problem is that no one knows whether
    the function terminates for all positive values of *n* (mathematical induction
    is no help because one of the recursive calls is for a larger value of the argument).
    Develop a better implementation that is based on memoization.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Recursive tree.** Compose a program that takes a command-line argument *n*
    and produces tree-like recursive patterns like these for *n* equal to 1, 2, 3,
    4, and 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Recursive trees](../Images/3a92c64d501fb8895038b1c7475b4541.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Brownian island.** Benoit Mandelbrot asked the famous question *How long
    is the coast of Britain?* Modify `brownian.py` to compose a program that plots
    [Brownian islands](http://swiss.csail.mit.edu/~rauch/islands/), whose coastlines
    resemble that of Great Britain. The modifications are simple: first, change `curve()`
    to add a gaussian to the *x* coordinate as well as to the *y* coordinate; second,
    change `main()` to draw a curve from the point at the center of the canvas back
    to itself. Experiment with various values of the arguments to get your program
    to produce islands with a realistic look.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Brownian island](../Images/aff29185fc15188fd0ac852102138ffe.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Solution*: See [brownianisland.py](brownianisland.py.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
