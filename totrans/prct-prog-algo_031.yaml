- en: 9.9 Cryptography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.9 密码学
- en: 原文：[https://introcs.cs.princeton.edu/java/99crypto](https://introcs.cs.princeton.edu/java/99crypto)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/99crypto](https://introcs.cs.princeton.edu/java/99crypto)
- en: This section under major construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在大力施工中。
- en: '**Cryptology.** *Cryptology* is the science of secret communication. It has
    two main subfields: *cryptography* is the science of creating secret codes; *cryptanalysis*
    is the science of breaking codes. There are five pillars of cryptology:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码学。** *密码学* 是秘密通信的科学。它有两个主要子领域：*密码学* 是创建秘密代码的科学；*密码分析* 是破译代码的科学。密码学有五大支柱：'
- en: 'Confidentiality: keep communication private.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保密性：保持通信私密。
- en: 'Integrity: detect unauthorized alteration to communication.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性：检测通信的未经授权的更改。
- en: 'Authentication: confirm identity of sender.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证：确认发件人身份。
- en: 'Authorization: establish level of access for trusted parties.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权：为受信任的方建立访问级别。
- en: 'Non-repudiation: prove that communication was received.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可否认性：证明通信已被接收。
- en: 'We will focus primarily on confidentiality, the most romantic of these endeavors.
    Highly recommended reading for entertainment: The Code Book. Useful Flash demo:
    [e-Security history](http://www.rsasecurity.com/experience/esecurity/index.html)
    from rsa.com.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要关注保密性，这些努力中最浪漫的部分。强烈推荐阅读娱乐：《密码本》。有用的Flash演示：[e-Security history](http://www.rsasecurity.com/experience/esecurity/index.html)
    来自rsa.com。
- en: '**Some applications of crypto.** Phil Zimmermann asserts "Cryptography used
    to be an obscure science, of little relevance to everyday life. Historically,
    it always had a special role in military and diplomatic communications. But in
    the Information Age, cryptography is about political power, and in particular,
    about the power relationship between a government and its people. It is about
    the right to privacy, freedom of speech, freedom of political association, freedom
    of the press, freedom from unreasonable search and seizure, freedom to be left
    alone." (Code Book, p. 296). Crypo benefits both ordinary citizens and terrorists.
    Enables e-commerce. Below is a table of activities that we would like to be able
    to implement digitally and securely. We all list a number of everyday analog implementation
    of each task.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码学的一些应用。** 菲尔·齐默曼声称“密码学曾经是一门鲜为人知的科学，与日常生活无关。从历史上看，它一直在军事和外交通信中扮演着特殊的角色。但在信息时代，密码学涉及政治权力，特别是政府与人民之间的权力关系。它关乎隐私权，言论自由，政治结社自由，新闻自由，免受不合理搜查的自由，独处的自由。”（《密码本》，第296页）。密码学既有利于普通公民，也有利于恐怖分子。促进电子商务。以下是我们希望能够数字化和安全实现的活动表格。我们列出了每个任务的一些日常模拟实现。'
- en: '| Task | Analog Implementations |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 任务 | 模拟实现 |'
- en: '| Protect information | Code book, lock and key |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 保护信息 | 密码本，锁和钥匙 |'
- en: '| Identification | Driver''s license, Social Security number, password, bioinformatics,
    secret handshake |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 识别 | 驾驶执照，社会安全号码，密码，生物信息学，秘密握手 |'
- en: '| Contract | Handwritten signature, notary |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 合同 | 手写签名，公证 |'
- en: '| Money transfer | Coin, bill, check, credit card |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 转账 | 硬币，纸币，支票，信用卡 |'
- en: '| Public auction | Sealed envelope |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 公开拍卖 | 密封信封 |'
- en: '| Public election | Anonymous ballot |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 公开选举 | 匿名投票 |'
- en: '| Poker | Cards with concealed backs |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 扑克 | 有隐蔽背面的牌 |'
- en: '| Public lottery | Dice, coins, rock-paper-scissors |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 公开抽奖 | 骰子，硬币，石头剪刀布 |'
- en: '| Anonymous communication | Pseudonym, ransom note |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 匿名通信 | 匿名，勒索信 |'
- en: 'A malicious adversary can sometimes subvert these analog implementations: forgery,
    lock picks, counterfeiters, card cheats, ballot-stuffing, loaded dice.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意对手有时可以破坏这些模拟实现：伪造，撬锁，伪造者，作弊者，投票作弊，偷骰子。
- en: '**Our goal.** Our goal is to implement all of these tasks digitally and securely.
    We would also like to implement additional tasks that can''t be done with physics!
    For example: play poker variant where dealer wins if no one has an Ace, have an
    anonymous election where everyone learns winner, but nothing else. Is any of this
    possible? If so, how? In the remainder of this section, we will give a flavor
    of modern (digital) cryptography, implement a few of these tasks, and sketch a
    few technical details.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们的目标。** 我们的目标是数字化和安全地实现所有这些任务。我们还希望实现一些物理上无法完成的额外任务！例如：玩一种扑克变体，庄家赢得比赛如果没有人有一张A牌，进行一个匿名选举，每个人都知道赢家，但其他什么都不知道。这些是否有可能？如果是，如何实现？在本节的其余部分，我们将介绍现代（数字）密码学的风味，实现其中一些任务，并勾勒一些技术细节。'
- en: '**History.** Decryption of Mary Stuart''s encrypted letters revealed her intent
    to assassinate Elizabeth I. In the 1800s, Edgar Allen Poe boasted that he could
    break anyone''s cypher using frequency analysis. Alan Turing led a team at Bletchley
    Park which cracked the German Enigma cipher. Many historians believe this was
    the turning point of World War II. Here''s an [Enigma applet](http://russells.freeshell.org/enigma).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**历史。** 解密玛丽·斯图尔特的加密信件揭示了她暗杀伊丽莎白一世的意图。在19世纪，埃德加·爱伦·坡自夸可���通过频率分析破解任何人的密码。艾伦·图灵领导了布莱切利园的一个团队，破解了德国恩尼格玛密码机。许多历史学家认为这是第二次世界大战的转折点。这里有一个[恩尼格玛小程序](http://russells.freeshell.org/enigma)。'
- en: '**Security by obscurity.** The Content Scrambling System (CSS) is used by Hollywood
    to encrypt DVDs. Each disc has three 40-bit keys. Each DVD decoder has unique
    40-bit key. In principle it is "not possible" to play back on computer without
    disc. In 1999, two Norwegians (Canman and SoupaFrog, 1999) wrote a decryption
    algorithm that cracked the CSS system. CSS was a proprietary algorithm and Hollywood
    was banking on the fact that nobody would discover the algorithm. Moreover, the
    size of the keys was too small, so brute force attacks were possible. Other high
    profile failures due to ad hoc approach: GSM cell phones, Windows XP product activiation,
    RIAA digital music watermarking, VCR+ codes, and Adobe eBooks, Diebold AccuVote-TS
    electronic voting machines, [ExxonMobil SpeedPass RFIDs](http://rfidanalysis.org/).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性通过混淆实现。** 内容加密系统（CSS）被好莱坞用于加密DVD。每张光盘有三个40位密钥。每个DVD解码器有唯一的40位密钥。原则上，在没有光盘的情况下在计算机上播放是“不可能的”。1999年，两名挪威人（Canman和SoupaFrog，1999）编写了一个破解CSS系统的解密算法。CSS是一种专有算法，好莱坞赌注于没有人会发现这个算法。此外，密钥的大小太小，因此可以进行穷举攻击。由于临时方法导致的其他高调失败：GSM手机，Windows
    XP产品激活，RIAA数字音乐水印，VCR+代码，Adobe电子书，Diebold AccuVote-TS电子投票机，[埃克森美孚SpeedPass RFIDs](http://rfidanalysis.org/)。'
- en: 'In 1883, The Dutch linguist [Auguste Kerckhoffs von Nieuwenhof](http://en.wikipedia.org/wiki/Auguste_Kerckhoffs)
    embodied the underlying principle guiding modern cryptography in his paper [Cryptographie
    militaire](http://www.petitcolas.net/fabien/kerckhoffs/la_cryptographie_militaire_i.htm):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 1883年，荷兰语言学家[Auguste Kerckhoffs von Nieuwenhof](http://en.wikipedia.org/wiki/Auguste_Kerckhoffs)在他的论文[Cryptographie
    militaire](http://www.petitcolas.net/fabien/kerckhoffs/la_cryptographie_militaire_i.htm)中体现了指导现代密码学的基本原则。
- en: Il faut qu'il n'exige pas le secret, et qu'il puisse sans inconvenient tomber
    entre les mains de l'ennemi.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Il faut qu'il n'exige pas le secret, et qu'il puisse sans inconvenient tomber
    entre les mains de l'ennemi.
- en: The system must not require secrecy and can be stolen by the enemy without causing
    trouble.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 系统不应该要求保密，可以被敌人窃取而不会造成麻烦。
- en: This is now known as *Kerckhoffs' Principle*. The security of a cryptosystem
    should not depend on keeping the algorithm secret, but only on keeping the numeric
    key secret. There are two primary distinctions between the algorithm and the numeric
    key. ([Ed Felten](http://www.freedom-to-tinker.com/archives/2004_09.html)) First,
    since we generate the numeric key at random, we can accurately model and quantify
    how long it would take an adversary to guess (under general technical conditions);
    in contrast, it is much harder to predict or quantify how long it would take an
    adverary to guess our algorithm. Second, it's easy to use different numeric keys
    for different purposes of people, or to stop using a key that has been compromised;
    it's more difficult to design new algorithms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在被称为*Kerckhoffs' Principle*。一个加密系统的安全性不应该依赖于保密算法，而只应该依赖于保密数字密钥。算法和数字密钥之间有两个主要区别。([Ed
    Felten](http://www.freedom-to-tinker.com/archives/2004_09.html)) 首先，由于我们随机生成数字密钥，我们可以准确地建模和量化对手猜测所需的时间（在一般技术条件下）；相比之下，预测或量化对手猜测我们的算法需要更多的努力。其次，对于不同的目的或人员，使用不同的数字密钥很容易，或者停止使用已被泄露的密钥；设计新算法更加困难。
- en: It says that systems based on "security by obscurity" are fatally flawed. This
    is equivalent to Shannon's maxim is "The enemy knows the system." The design of
    secure systems should be left to the experts. Despite this, we can still explore
    the basic ideas of cryptography that the experts use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它说基于“安全性通过混淆”的系统存在致命缺陷。这等同于香农的格言是“敌人知道系统。”设计安全系统应该留给专家。尽管如此，我们仍然可以探索专家使用的密码学基本思想。
- en: '**The participants.** In keeping with the rich tradition of cryptographers,
    Alice and Bob are the two people trying to communicate securely over an insecure
    communication channel. We will assume that the message is already encoded in binary,
    so we can treat it as a (potentially huge) integer *m*. We let N denote the number
    of bits in the message m. Alice applies an encryption function E to the message,
    which produces another N bit integer E(m). Bob receives E(m) and applies his decryption
    function D to this. An obvious condition for this to make any sense is that D(E(m))
    = m. In other words, Bob recovers the original message. Eve is a third party who
    wishes to intercept the message. Eve can observe E(m), so for the scheme to be
    secure, it should be prohibitively difficult for Eve to recover m from E(m) alone.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**参与者。** 与密码学家丰富的传统一致，Alice和Bob是两个试图在不安全的通信渠道上进行安全通信的人。我们假设消息已经以二进制编码，因此我们可以将其视为一个（可能很大的）整数*m*。我们让*N*表示消息*m*中的位数。Alice将加密函数*E*应用于消息，产生另一个*N*位整数*E(m)*。Bob收到*E(m)*并对其应用解密函数*D*。这个方案有意义的一个明显条件是*D(E(m))
    = m*。换句话说，Bob恢复了原始消息。Eve是希望拦截消息的第三方。Eve可以观察*E(m)*，因此为了使方案安全，Eve应该从*E(m)*中单独恢复*m*应该是极其困难的。'
- en: '**Private key cryptography.** Private key = two parties share a secret key
    prior to their communication. One-time pads (Chapter 1) are provably secure if
    the bits in the key are generated from a truly random source. It is also extremely
    easy to implement. Nevertheless, one-time pads have several mitigating factors
    that render it impractical in most situations. First, it is a challenge to generate
    truly random bits, free of biases and correlations. One must go outside the world
    of digital computers and extract them from some physical source (e.g., time between
    emission of particles due to radioactive decay, sound from a microphone, elapsed
    time between keystrokes). Such sources are often biased and we would need to take
    great care to prevent Eve from observing or tampering with the process. The scheme
    is called one-time since we need new key for each message or part of the message.
    If we re-use a one-time pad, then the system is no longer secure. Signature? Non-repudiation?
    Perhaps the most limiting factor is key distribution. Alice and Bob must know
    each other and exchange the key sending the secret message. The Kremlin and White
    House used to communicate with each other using this method. A trusted courier
    would be sent across the Atlantic Ocean with a briefcase of one-time pads handcuffed
    to his arm. This method is ridiculously impractical for if Alice wants to purchase
    a product from Bob over the Internet.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**私钥加密。** 私钥 = 两个参与方在通信之前共享一个秘密密钥。一次性密码本（第1章）如果密钥中的位是从真正随机的来源生成的，则可以被证明是安全的。它也非常容易实现。然而，一次性密码本有几个减轻因素，使其在大多数情况下变得不切实际。首先，生成真正随机、没有偏见和相关性的位是一个挑战。必须走出数字计算机的世界，从某种物理来源提取它们（例如，由于放射性衰变而发射的粒子之间的时间、麦克风的声音、按键之间的经过时间）。这些来源通常是有偏见的，我们需要非常小心地防止伊夫观察或篡改过程。该方案被称为一次性，因为我们需要为每条消息或消息的一部分生成新密钥。如果我们重复使用一次性密码本，那么系统将不再安全。签名？不可否认？也许最具限制性的因素是密钥分发。爱丽丝和鲍勃必须相互认识并交换密钥发送秘密消息。克里姆林宫和白宫曾经使用这种方法相互通信。一个受信任的信使将被派遣穿越大西洋，手铐着一次性密码本的公文包。如果爱丽丝想要通过互联网从鲍勃购买产品，这种方法是荒谬的不切实际的。'
- en: Other private key encryption schemes. Data Encryption Standard (DES). Advanced
    Encryption Standard (AES, Rijndael algorithm). Blowfish. Methods are not provably
    secure like one-time pads, but have withstood the test of time of mathematical
    scrutiny. Efficient. However, these schemes suffer from the same key-distribution
    problem that plagues one-time pads. One emerging solution to the key distribution
    problem is to use quantum mechanics. This is known as Quantum Key Distribution.
    It is an unconditionally secure way for two parties to share a one-time pad. Moreover,
    there is an intrusion detection component so that if Eve observes even one bit,
    both parties will learn about the attempted eavesdropping.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其他私钥加密方案。数据加密标准（DES）。高级加密标准（AES，Rijndael算法）。Blowfish。这些方法不像一次性密码本那样可以被证明是安全的，但经受住了数学审查的时间考验。高效。然而，这些方案遭受了困扰一次性密码本的相同密钥分发问题。解决密钥分发问题的一种新兴方法是使用量子力学。这被称为量子密钥分发。这是两个参与方分享一次性密码的一种无条件安全的方式。此外，还有入侵检测组件，因此如果伊夫观察到甚至一个位，双方都将了解到试图窃听。
- en: '**Modern cryptography.** The modern theory of cryptography leverages the theory
    of hard problems. The goal is to show that breaking security system is equivalent
    to solving some of the world''s greatest unsolved problems! Bruce Schneier, a
    noted electronic security expert, wrote in Applied Cryptography, "It is insufficient
    to protect ourselves with laws, we need to protect ourselves with mathematics."
    The foundations of modern cryptography hinges on three crucial axioms and one
    important fact.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**现代密码学。** 现代密码学理论利用了困难问题的理论。目标是表明破解安全系统等同于解决一些世界上最伟大的未解决问题！著名的电子安全专家布鲁斯·施奈尔在《应用密码学》中写道：“仅仅依靠法律保护自己是不够的，我们需要用数学来保护自己。”现代密码学的基础依赖于三个关键公理和一个重要事实。'
- en: '*Axiom 1\. Players can toss coins.* Crypto is impossible without randomness
    so this axiom is essential. In practice we can generate truly random bits by using
    quantum phenomenon or the radioactive decay of particles.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公理1\. 参与方可以抛硬币。* 没有随机性，密码学是不可能的，因此这个公理是必不可少的。在实践中，我们可以通过使用量子现象或粒子的放射性衰变来生成真正随机的位。'
- en: '*Axiom 2\. Players are computationally limited.* We express this notion formally
    by restricting the participants (communicating parties and malicious adversaries)
    to use only polynomial time algorithms.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公理2\. 参与方在计算上受限。* 我们通过限制参与者（通信各方和恶意对手）只使用多项式时间算法来正式表达这个概念。'
- en: '*Axiom 3\. Factoring is hard computationally.* We assume that it is not possible
    to factor an N-bit integer in time polynomial in N. Given an integer (e.g., 1541)
    it appears difficult to find its prime factorization. However, given the factors
    (e.g., 23 * 67) it is easy to multiply them out and obtain the original number.
    This is referred to as a "1-way trapdoor function" since it is easy to go one
    way (from factors to product), but apparently hard to go the other way (from product
    to factors).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公理3\. 因子分解在计算上很困难。* 我们假设在N位整数中不可能在N的多项式时间内分解出因子。给定一个整数（例如，1541），找到其素数分解似乎很困难。然而，给定因子（例如，23
    * 67），很容易将它们相乘并获得原始数字。这被称为“一种单向陷阱函数”，因为从因子到乘积的方向很容易（从乘积到因子的方向似乎很困难）。'
- en: '*Fact. Primality testing is easy computationally.* Miller-Rabin primality testing
    algorithm. PRIMES in P proved in 2002.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事实。素性测试在计算上很容易。* 米勒-拉宾素性测试算法。2002年证明了PRIMES in P。'
- en: If the three axioms above are valid, then digital cryptography exists. That
    is, it is possible to do all of the previous tasks digitally.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述三个公理有效，则数字密码学存在。也就是说，可以通过数字方式完成以前的所有任务。
- en: '**Public key cryptography.** Public key cryptography is an amazing scheme that
    enables two parties to communicate securely, even if they''ve never met. It is
    the digital analog of a box with a combination lock. Suppose Alice wants to send
    Bob a message. First, Bob send the box to Alice with the padlock in the open position,
    without revealing the combination to anyone. Alice puts her message in the box,
    closes the combination lock, and sends it back to Bob. Eve may intercept the box
    in transit, but since she doesn''t know the combination, she is unable to open
    it. She can try to guess the combination, but there are just too many possibilities.
    When the box arrives, Bob can open it, knowing that nobody else looked inside
    (unless they knew the combination).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**公钥密码学.** 公钥密码学是一种令人惊奇的方案，使两方能够安全地通信，即使他们从未见过面。这是数字化的带有组合锁的盒子的类比。假设Alice想要向Bob发送一条消息。首先，Bob将带有开放位置的挂锁的盒子发送给Alice，而不向任何人透露组合。Alice将她的消息放在盒子里，关闭组合锁，然后将其发送回Bob。Eve可能在传输过程中拦截盒子，但由于她不知道组合，她无法打开它。她可以尝试猜测组合，但可能性太多了。当盒子到达时，Bob可以打开它，知道没有其他人看过里面（除非他们知道组合）。'
- en: 'To do this digitally, Bob has two keys (or combinations): his private key d
    is not revealed to anybody, his public key e is published in an Internet phonebook.
    We think of the keys as integers, but they are really just sequences of bits,
    say 1024. If Alice wants to send a message to Bob, she looks up Bob''s public
    key e on the Internet. She uses e to encrypt her message and sends it to Bob.
    Bob uses his private key d to decrypt the message.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Bob在数字上有两个密钥（或组合）：他的私钥d不向任何人透露，他的公钥e在互联网电话簿中公布。我们将密钥视为整数，但实际上它们只是一系列位，比如1024位。如果Alice想要向Bob发送一条消息，她在互联网上查找Bob的公钥e。她使用e加密她的消息并将其发送给Bob。Bob使用他的私钥d解密消息。
- en: The idea of public key cryptography was first published in 1976 by Whitfield
    Diffie and Martin Hellman in their groundbreaking paper *New Directions in Cryptography*.
    This paper described a public key cryptosystem for the key distribution problem.
    The idea was apparently discovered independently by Ellis, Cocks, and Williamson
    in the UK at the Government Communications Headquarters (GCHQ) in the early 1970s,
    but their work remained a secret for two decades.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学的概念最早是由Whitfield Diffie和Martin Hellman在他们开创性的论文*密码学的新方向*中于1976年首次发表的。这篇论文描述了用于密钥分发问题的公钥加密系统。这个想法显然是由英国政府通信总部（GCHQ）的Ellis、Cocks和Williamson在20世纪70年代早期独立发现的，但他们的工作保密了两十年。
- en: RSA cryptosystem.
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSA加密系统。
- en: We will describe the basic mechanics of the [RSA cryptosystem](http://www.acm.org/turingawardlecture/RSA/),
    a scheme developed by Adleman, Rivest, and Shamir in 1978. Here's the [RSA paper](../../papers/rsa.pdf).
    RSA is very widely used today for secure Internet communication (browsers, S/MIME,
    SSL, S/WAN, PGP, Microsoft Outlook), operating systems (Sun, Microsoft, Apple,
    Novell) and hardware (cell phones, ATM machines, wireless Ethernet cards, Mondex
    smart cards, Palm Pilots). Then, we will give intuition for why it works and describe
    to implement it efficiently. The RSA cryptosystem involves modular arithmetic.
    Recall .....
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述1978年Adleman、Rivest和Shamir开发的[RSA加密系统](http://www.acm.org/turingawardlecture/RSA/)的基本机制。这里是[RSA论文](../../papers/rsa.pdf)。RSA今天被广泛用于安全的互联网通信（浏览器，S/MIME，SSL，S/WAN，PGP，Microsoft
    Outlook），操作系统（Sun，Microsoft，Apple，Novell）和硬件（手机，ATM机，无线以太网卡，Mondex智能卡，Palm Pilots）。然后，我们将解释为什么它有效以及如何高效实现它。RSA加密系统涉及模运算。回想一下......
- en: '*Key generation.* To participate in the RSA cryptosystem, Bob must first generate
    a public and private key. He only needs to do this once, even if he plans to use
    the system many times.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*密钥生成.* 要参与RSA加密系统，Bob必须首先生成公钥和私钥。即使他打算多次使用该系统，他也只需要这样做一次。'
- en: Select two large prime numbers p and q at random.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择两个大素数p和q。
- en: Compute n = p × q.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算n = p × q。
- en: Select two integers e and d such that (m^e)^d ≡ m (mod n) for all integers m.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择两个整数e和d，使得对所有整数m都有(m^e)^d ≡ m (mod n)。
- en: As an example, we might choose the following parameters, although in practice
    we would need to use much larger integers to guarantee security.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，我们可能选择以下参数，尽管在实践中我们需要使用更大的整数来保证安全性。
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Encryption.* Alice wants to send an N-bit secret message m to Bob. She obtains
    Bob''s public key (e, n) from the Internet. Then she encrypts the message m using
    the encryption function E(m) = m^e (mod n), and sends E(m) to Bob.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密.* Alice想要向Bob发送一个N位的秘密消息m。她从互联网上获取Bob的公钥（e，n）。然后她使用加密函数E(m) = m^e (mod
    n)加密消息m，并将E(m)发送给Bob。'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Decryption.* Bob receives the encrypted message c from Alice. Bob recalls
    his private key (d, n). Then he decrypts the ciphertext by applying the decryption
    function D(c) = c^d (mod n). Since Bob knows d, he can compute this function.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*解密.* Bob从Alice那里收到加密消息c。Bob回忆起他的私钥（d，n）。然后他通过应用解密函数D(c) = c^d (mod n)来解密密文。由于Bob知道d，他可以计算这个函数。'
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*RSA simulator.* [RSA simulator](http://www-cs-students.stanford.edu/~tjw/jsbn/rsa2.html).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*RSA模拟器.* [RSA模拟器](http://www-cs-students.stanford.edu/~tjw/jsbn/rsa2.html).'
- en: '*Correctness.* To make sure that Bob receives the original message, we must
    check that D(E(m)) = m. It worked in the example above where m = 100, E(100) =
    254, D(254) = 100, but we need to be sure it works for all possible messages,
    and for all valid choices of e, d, and n. This follows in a straightforward way
    from the defintions and the way we chose e and d.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*正确性.* 为了确保Bob接收到原始消息，我们必须检查D(E(m)) = m。在上面的例子中，当m = 100时，E(100) = 254，D(254)
    = 100，但我们需要确保它适用于所有可能的消息，以及所有有效的e、d和n的选择。这可以直接从定义和我们选择e和d的方式得出。'
- en: '![](../Images/7efd53405c873dd97ddef65722d1d4ff.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7efd53405c873dd97ddef65722d1d4ff.png)'
- en: We have supressed one important detail - how to choose e and d so that the magic
    property holds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了一个重要的细节 - 如何选择e和d，以使魔术属性成立。
- en: '**Implementing the RSA cryptosystem.** Implementing the RSA cryptosystem is
    a formidable engineering challenge. A successful implementation requires many
    ingenious algorithms and knowledge of several theorems in number theory. We will
    describe a bare-bones implemenation, but commercial implementations are more sophisticated.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现RSA加密系统。** 实现RSA加密系统是一个艰巨的工程挑战。成功的实现需要许多巧妙的算法和对数论中几个定理的了解。我们将描述一个基本的实现，但商业实现更加复杂。'
- en: '*Big integers.* Can''t use built in `int` or `long` types since numbers are
    too big. Need to re-implement the laws of arithmetic, e.g., addition, subtraction,
    multiplication, and division. Grade school algorithms are reasonably efficient
    for all of these operations, although there is always opportunity for improvement
    using clever algorithms.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大整数*。不能使用内置的`int`或`long`类型，因为数字太大。需要重新实现算术法则，例如加法、减法、乘法和除法。小学的算法对所有这些操作都相当有效，尽管总是有机会使用聪明的算法来改进。'
- en: '*Modular exponentation.* How to perform modular exponentation: a^b (mod c).
    The naive method would be to repeatedly multiply a by itself, b times, and then
    divide by c and return the remainder. When a, b, and c are N-bit integers, this
    fails spectacularly for two reasons. First, the intermediate number a^b can be
    monstrously large. The number of digits can be exponential in N. When N = 50,
    this consumes 128TB memory. The second problem is that the number of multiplications
    also takes exponential time. So it will take forever.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模指数*。如何执行模指数运算：a^b (mod c)。朴素的方法是重复地将a乘以自身，b次，然后除以c并返回余数。当a、b和c是N位整数时，这种方法会因为两个原因而失败。首先，中间数a^b可能非常大。数字的位数可能是N的指数。当N
    = 50时，这将消耗128TB内存。第二个问题是乘法的次数也需要指数时间。因此，这将永远持续下去。'
- en: 'A better alternative is to use *repeated squaring*. This idea dates back to
    at least 200 BCE according to Knuth. Program [ModExp.java](ModExp.java.html) uses
    the following recurrence to compute a^b mod n:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更好的选择是使用*重复平方*。这个想法可以追溯到至少公元前200年，据Knuth称。程序[ModExp.java](ModExp.java.html)使用以下递归计算a^b
    mod n：
- en: 'if b is zero: 1'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果b是零：1
- en: 'if b is even: (a^(b/2) * a^(b/2)) mod n'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果b是偶数：(a^(b/2) * a^(b/2)) mod n
- en: 'if b is odd: (a * a^(b/2) * a^(b/2)) mod nThis is analogous to the following
    recurrence for multiplication.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果b是奇数：(a * a^(b/2) * a^(b/2)) mod n这类似于乘法的以下递归。
- en: 'if b is zero: 1'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果b是零：1
- en: 'if b is even: (a * b/2) + (a * b/2)'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果b是偶数：(a * b/2) + (a * b/2)
- en: 'if b is odd: (a * b/2) + (a * b/2) + a'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果b是奇数：(a * b/2) + (a * b/2) + a
- en: '*Computing a random prime.* To generate the key, we must have a method for
    generating a random N-bit prime, say N = 1024. One idea is to choose an N-bit
    integer at random and check if it is prime. If it is, then stop; otherwise repeat
    until you stumble upon one that is prime.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*计算一个随机质数*。为了生成密钥，我们必须有一个生成随机N位质数的方法，比���N = 1024。一个想法是随机选择一个N位整数并检查它是否是质数。如果是，那么停止；否则重复，直到找到一个质数。'
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This simple idea works, but to implement it requires two crucial ideas. First,
    the loop may take a very long time if there are not enough prime numbers. Fortunately,
    the Prime Number Theorem (Hadamard, Vallee Poussin, 1896) asserts that the number
    of primes between 2 and x is approximately x / ln x. There are over 10^(151) primes
    with 512 bits or fewer. In other words, roughly 1 out of every ln x x-bit numbers
    are prime, so we expect to wait only ln x steps before stumbling upon a prime
    number. But how do we check to see if a number is prime? Attempting to factor
    it would be prohibitively expensive. Instead, we can use an ingenious algorithm
    due to Miller-Rabin (or a more recent one due to Agarwal-Kayal-Saxena) that checks
    if an integer is prime in a polynomial number of steps.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个简单的想法有效，但要实现它需要两个关键的想法。首先，如果没有足够的质数，循环可能需要很长时间。幸运的是，素数定理（Hadamard，Vallee Poussin，1896）断言2到x之间的质数大约是x
    / ln x。有超过10^(151)个512位或更少的质数。换句话说，大约每ln x个x位数中有一个是质数，因此我们期望在偶然发现一个质数之前只需ln x步。但是我们如何检查一个数是否是质数呢？试图对其进行因式分解将是代价高昂的。相反，我们可以使用Miller-Rabin（或更近期的Agarwal-Kayal-Saxena）的巧妙算法，在多项式步骤内检查一个整数是否为质数。
- en: '*Generating random numbers.* (move to one-time pad?) Physical sources of randomness.
    The Java library `SecureRandom` is a pseudo-random number generator that generates
    *cryptographically secure* random numbers. This means that it is computationally
    intractable to predict future bits. Unlike a LFSR, you can''t reverse-engineer
    it.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成随机数*。（移到一次性密码？）物理随机源。Java库`SecureRandom`是一个生成*密码安全*随机数的伪随机数生成器。这意味着计算未来位是困难的。与LFSR不同，你无法逆向工程它。'
- en: '*Computing the private exponent.* One final challenge is choosing the public
    and private keys. In practice it is common use e = 65,537 as the public key. But
    this means we need to find a private key that makes the magic property hold. This
    turns out to be a well understood problem in number theory and a unqiue d always
    exists provided gcd(e, (p-1)(q-1)) = 1. We can use an extension of Euclid''s algorithm
    (see exercise xyz) for this purpose.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*计算私钥指数*。最后一个挑战是选择公钥和私钥。在实践中，通常使用e = 65,537作为公钥。但这意味着我们需要找到一个使魔术属性成立的私钥。这事实上是一个在数论中被充分理解的问题，只要gcd(e,
    (p-1)(q-1)) = 1，就会存在一个唯一的d。我们可以使用Euclid算法的扩展（参见练习xyz）来实现这个目的。'
- en: Easy to do using Java's `BigInteger` library for manipulating huge integers.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Java的`BigInteger`库来操作大整数非常容易。
- en: '[PRE4]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**RSA Attacks.** Cryptanalysis is the science of breaking secret codes. We
    describe a few common attacks to the RSA crpytosystem to give you the flavor of
    modern cryptanalysis.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**RSA攻击。** 密码分析是破解秘密代码的科学。我们描述了一些常见的RSA加密系统攻击，以让您了解现代密码分析的风格。'
- en: '*Factoring.* The most obvious way to break the RSA cryptosystem is by factoring
    the modulus n. If Eve can factor n = pq, then she has exactly the same information
    as Bob, so she can efficiently compute his private exponent given the public one
    (using exactly the same algorithm that Bob used to compute his private exponent
    in the first place). Using a very sophisticated factoring algorithm known as the
    [general number field sieve](http://mathworld.wolfram.com/NumberFieldSieve.html),
    researchers were recently able to [factor RSA-576](http://www.rsasecurity.com/company/news/releases/pr.asp?doc_id=3520),
    a 576-bit (174 decimal digits) composite integer offered as a challenge problem
    by RSA Security. This effort required 100 workstations and 3 months of number
    crunching. The running time of this algorithm is super-polynomial but sub-exponential
    - O(exp(c (log n)^(1/3) (log log n)^(2/3))).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分解。* 破解 RSA 加密系统最明显的方法是分解模数 n。如果 Eve 能够分解 n = pq，那么她拥有与 Bob 完全相同的信息，因此她可以有效地计算出他的私有指数，给定公共指数（使用
    Bob 用来计算私有指数的算法）。使用一个非常复杂的分解算法，即[一般数域筛](http://mathworld.wolfram.com/NumberFieldSieve.html)，研究人员最近成功地[分解了
    RSA-576](http://www.rsasecurity.com/company/news/releases/pr.asp?doc_id=3520)，这是
    RSA 安全性提供的一个挑战问题，一个 576 位（174 位十进制数字）的复合整数。这个工作需要 100 台工作站和 3 个月的计算。该算法的运行时间是超多项式但是次指数的
    - O(exp(c (log n)^(1/3) (log log n)^(2/3)))。'
- en: '*Improper usage.* The RSA system can also be broken if it is used improperly.
    For example, if Bob decides to use a small *private* exponent to lessen his computational
    burden for decryption, then he is sacrificing security. If d < 1/3 n^(1/4), then
    can recover d in polynomial time (Wiener attack). Note that it is okay to use
    a small public exponent e, and 65,537 is common in practice. Another mistake is
    to allow two participants to share the same modulus n (even if neither party knows
    how to factor n). For example, suppose Bob and Ben have (d1, e1) and (d2, e2)
    for their private and public exponents, respectively, but they are both using
    n as their modulus. Then it is possible for either party to discover the other''s
    private exponent (Simmon''s attack).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不当使用。* 如果 RSA 系统被不当使用，也会被破解。例如，如果 Bob 决定使用一个小的*私有*指数来减轻解密的计算负担，那么他就在牺牲安全性。如果
    d < 1/3 n^(1/4)，那么可以在多项式时间内恢复 d（Wiener 攻击）。请注意，使用一个小的公共指数 e 是可以的，在实践中，65,537 是常见的。另一个错误是允许两个参与者共享相同的模数
    n（即使双方都不知道如何分解 n）。例如，假设 Bob 和 Ben 分别拥有（d1，e1）和（d2，e2）作为他们的私有和公共指数，但他们都使用 n 作为模数。那么任何一方都有可能发现另一方的私有指数（Simmon''s
    攻击）。'
- en: '*Side channel attack.* Exploit physical information leaked from machine, including
    electromagnetic emanations, power consumption, diffuse visible light from CRT
    displays, and acoustic emanations. For example, in a *timing attack* Eve gleans
    information about Bob''s private key by measuring the amount of time it takes
    for Bob to exponentiate. If Bob is using a highly optimized exponentiation routine,
    then Eve can discover enough information to reveal Bob''s private key. Recently,
    Dan Boneh showed how to use this technique to break SSL on a LAN.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*侧信道攻击。* 利用从机器泄露的物理信息，包括电磁辐射、功耗、CRT 显示器的漫射可见光和声学辐射。例如，在一个*时序攻击*中，Eve 通过测量 Bob
    进行指数运算所需的时间来获取关于 Bob 的私有密钥的信息。如果 Bob 使用高度优化的指数运算例程，那么 Eve 可以发现足够的信息来揭示 Bob 的私有密钥。��近，Dan
    Boneh 展示了如何利用这种技术来在局域网上破解 SSL。'
- en: It is a long-standing open research question whether or not there is a way to
    break the RSA system without factoring or physical access. There is no guarantee
    that RSA is secure even if factoring is hard. Also, there are currently know guarantees
    that factoring is hard other Also, currently no mathematical guarantee that factoring
    is hard! FACTOR and its complementary problem NON-FACTOR are both in NP. This
    makes it unlikely that FACTOR is NP-complete since this would imply NP = coNP...
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个长期存在的开放研究问题是是否有一种方法可以在不分解或物理访问的情况下破解 RSA 系统。即使分解很困难，也不能保证 RSA 是安全的。此外，目前也没有关于分解很困难的数学保证！FACTOR
    及其补充问题 NON-FACTOR 都在 NP 中。这使得 FACTOR 是 NP 完全的可能性很小，因为这将意味着 NP = coNP...
- en: '**Semantic security.** Other stronger notions of security. A public key cryptosystem
    is *semantically secure* if anything Eve can compute in polynomial time with the
    ciphertext can be computed without the ciphertext. Thus, observing the ciphertext
    provides no useful information. For example, we shouldn''t be able to determine
    if the last bit of the plaintext is 0 or 1 or if the plaintext has more 1 bits
    than 0 bits. The RSA system is not semantically secure, and in fact no deterministic
    scheme can be. This is not just a theoretical shortcoming. To see why, suppose
    that Eve knows Alice is going to send Bob either the message `ATTACK` or `RETREAT`.
    Eve can encrypt both message using Bob''s public key and then compare against
    the encrypted message that Alice sends to Bob. Thus, Alice can learn exactly which
    message was sent. Naive ideas like appending a random sequence of 0''s and 1''s
    to the plaintext before encrypting do not typically guarantee additional security.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义安全。** 其他更强的安全概念。如果一个公钥加密系统是*语义安全*的，那么 Eve 可以在多项式时间内计算出密文中的任何内容，而无需密文。因此，观察密文不提供任何有用的信息。例如，我们不应该能够确定明文的最后一位是
    0 还是 1，或者明文中 1 的位数是否比 0 多。RSA 系统不是语义安全的，实际上没有确定性方案可以实现。这不仅仅是一个理论上的缺陷。为了理解为什么，假设
    Eve 知道 Alice 将向 Bob 发送 `ATTACK` 或 `RETREAT` 消息。Eve 可以使用 Bob 的公钥加密两条消息，然后与 Alice
    发送给 Bob 的加密消息进行比较。因此，Alice 可以准确地了解发送了哪条消息。像在加密前附加一串随机的 0 和 1 到明文这样的天真想法通常不能保证额外的安全性。'
- en: '**Provably secure cryptosystems.** It is a bit unsatisfying to be using a cryptosystem
    that is not provably as difficult as some hard problem, e.g., factoring. Theoretical
    highground = Blum-Goldwasser (1985). Provably as hard as factoring, semantically
    secure. Based on the probabilistic encryption scheme of Goldwasser and Micali.
    Comparable in speed to RSA.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**可证明安全的加密系统。** 使用一个不像某些困难问题（例如因子分解）那样难以证明的加密系统有点令人不满。理论高地=Blum-Goldwasser（1985）。与因子分解同样难度，语义安全。基于Goldwasser和Micali的概率加密方案。在速度上与RSA可比。'
- en: '**Electronic voting.** Need a crypto scheme that makes it possible to confirm
    that your vote was correctly counted, without revealing whom the vote was for.
    Need the second condition to prevent someone from "buying" your vote since if
    they have no way to verify for whom you voted, they have no incentive to bribe
    you.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子投票。** 需要一种加密方案，使得可以确认你的选票被正确计算，而不透露你的选票给谁。需要第二个条件来防止某人“购买”你的选票，因为如果他们无法验证你投给谁，他们就没有贿赂你的动机。'
- en: '**Zero knowledge.** Alice wants to prove to Bob that a graph G is 3 colorable,
    but doesn''t want to reveal any additional information. Example generalizes to
    many other problems since 3Color is NP complete.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**零知识证明。** Alice想向Bob证明图G是3可着色的，但不想透露任何额外信息。这个例子可以推广到许多其他问题，因为3Color是NP完全的。'
- en: '**Digital rights management.** In the traditonal setting, the Alice, Bob, and
    Eve who are trying to communicate are human beings, and they use a computer to
    assist with the comptuation. An intriguing variant is when Alice and Bob are computers,
    and Eve is a human being. This is exactly the setting that the music industry
    envisions with digital rights management. In this case Alice is your computer,
    Bob is your speakers, and you are Eve. The music industry wants only your computer
    to be able to play the legally purchased music on your computer, but does not
    want you to be able to intercept the raw audio data. We can quickly imagine a
    world where there are restrictions for copying DVDs, runnig software, printing
    documents, and forwarding email. All of these restrictions will be enforced via
    cryptographic algorithms and protocols.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字版权管理。** 在传统设置中，试图进行通信的Alice、Bob和Eve是人类，他们使用计算机辅助计算。一个有趣的变体是当Alice和Bob是计算机，而Eve是人类。这正是音乐行业设想的数字版权管理的情景。在这种情况下，Alice是你的计算机，Bob是你的扬声器，而你是Eve。音乐行业希望只有你的计算机能够在你的计算机上播放合法购买的音乐，但不希望你能够拦截原始音频数据。我们很快可以想象到一个世界，在那里对复制DVD、运行软件、打印文件和转发电子邮件都有限制。所有这些限制将通过加密算法和协议执行。'
- en: 'Goal: transform a program into an obfuscated version that computes the same
    function, but reveals no extra information (e.g., the source code) to a polynomial-bounded
    adversary. Obfuscation not possible in general.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：将一个程序转换为计算相同函数的混淆版本，但不向多项式有界的对手透露任何额外信息（例如源代码）。通常情况下无法混淆。
- en: '**Security.** Cryptography is only one part of overall computer security. This
    [survey](http://news.bbc.co.uk/1/hi/technology/3639679.stm) revealed that 70%
    of people would reveal their computer password in exchange for a chocolate bar.
    One security expert comments "using encryption on the Internet is the equilvant
    of arranging an armored car to deliver credit card information from someone living
    in a cardboard box to someone living on a park bench."'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全。** 密码学只是整体计算机安全的一部分。这项[调查](http://news.bbc.co.uk/1/hi/technology/3639679.stm)显示，70%的人会为了一块巧克力棒而透露他们的计算机密码。一位安全专家评论说，“在互联网上使用加密相当于安排一辆装甲车将信用卡信息从一个住在纸箱里的人送到一个住在公园长椅上的人。”'
- en: '**CAPTCHAs.** Completely automated public Turing test to tell computers and
    humans apart. Reverse Turing test where computer is the judge, trying to distinguish
    between a human and a computer. [New York Times article](http://www.nytimes.com/2002/12/10/science/physical/10COMP.html).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAPTCHAs。** 完全自动化的公共图灵测试，用于区分计算机和人类。反向图灵测试，其中计算机是判官，试图区分人类和计算机。[纽约时报文章](http://www.nytimes.com/2002/12/10/science/physical/10COMP.html)。'
- en: Q+A
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问答
- en: Exercises
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Write a program to empirically determine the running time of the methods methods
    `BigInteger.add`, `BigInteger.multiply`, `BigInteger.mod`, and `BigInteger.modExp`.
    Try to model the running time of each operation as c N^k seconds for some constants
    c and k. Use `BigInteger.rand` to generate random input parameters. For add, multiply,
    and modular exponentiation use N-bit integers for all of the arguments; for division,
    use a N-bit numerator and an N/2-bit denominator.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来经验性地确定方法`BigInteger.add`、`BigInteger.multiply`、`BigInteger.mod`和`BigInteger.modExp`的运行时间。尝试将每个操作的运行时间建模为c
    N^k秒，其中c和k是一些常数。使用`BigInteger.rand`生成随机输入参数。对于加法、乘法和模指数运算，对所有参数使用N位整数；对于除法，使用N位分子和N/2位分母。
- en: Write a program [RandomPrime.java](RandomPrime.java.html) that takes a command-line
    argument N and prints out an N-bit integer that is (probably) prime. Use `BigInteger.probablePrime`
    for primality testing and `SecureRandom` to generate cryptographically secure
    pseudorandom numbers.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[RandomPrime.java](RandomPrime.java.html)，该程序接受一个命令行参数N，并打印出一个（可能）是素数的N位整数。使用`BigInteger.probablePrime`进行素性测试，并使用`SecureRandom`生成密码安全的伪随机数。
- en: Estimate the running time of [RandomPrime.java](RandomPrime.java.html) as a
    function of the number of bits N.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计[RandomPrime.java](RandomPrime.java.html)的运行时间作为位数N的函数。
- en: 'Suppose that instead of using `RandomPrime.java` to choose a prime with N bits,
    you used the following strategy: generate all primes with at most N bits, and
    choose a random one. What will happen if N is large, say 512?'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设不使用`RandomPrime.java`来选择具有N位的素数，而是使用以下策略：生成所有最多具有N位的素数，并选择一个随机素数。如果N很大，比如512，会发生什么？
- en: Suppose that instead of using reapeated squaring to compute a^b mod c, you repeatedly
    multiply a to itself, b times, modding out by c. Estimate how long will it take
    if a, b, and c are N bit integers.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设不使用重复平方来计算a^b mod c，而是将a重复乘以自身b次，同时取模c。估计当a、b和c都是N位整数时需要多长时间。
- en: 'What is the complexity of the following problem: given an even integer x, determine
    if x has any odd factors greater than one. Answer: polynomial - check whether
    x is a power of 2.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下问题的复杂度是多少：给定一个偶数x，确定x是否有大于1的奇数因子。答案：多项式 - 检查x是否是2的幂。
- en: 'What is the complexity of the following problem: Given an even integer x and
    another integer y, determine whether x has any odd factors between 3 and y. Answer:
    equivalent to factoring problem.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下问题的复杂度是多少：给定一个偶数x和另一个整数y，确定x是否在3和y之间有任何奇数因子。答案：等同于因式分解问题。
- en: Creative Exercises
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Extended Euclid''s algorithm.** Extend Euclid''s algorithm for computing
    the greatest common divisor of p and q to also compute coefficients a and b (possibly
    zero or negative) such that ap + bq = gcd(p, q). Write a program [ExtendedEuclid.java](ExtendedEuclid.java.html)
    that takes two command line parameters p and q and outputs gcd(p, q) and a pair
    of integers a and b as described above.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扩展欧几里得算法。** 扩展欧几里得算法用于计算p和q的最大公约数，还可以计算系数a和b（可能为零或负），使得ap + bq = gcd(p, q)。编写一个程序[ExtendedEuclid.java](ExtendedEuclid.java.html)，接受两个命令行参数p和q，并输出gcd(p,
    q)以及如上所述的一对整数a和b。'
- en: '[PRE5]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Hint: since your method needs to return three integers, consider using an array
    of three elements.'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示：由于你的方法需要返回三个整数，考虑使用一个三元素数组。
- en: '**Best rectangle.** Given area A of a rectangle, find a rectangle with integer
    width and height whose area is A and such that the difference between the height
    and width are as close to each other as possible. For example, if A = 48, then
    the best rectangle is 6-by-8 and not 3-by-16 or 4-by-12. Show that if you could
    solve this problem, you could break the RSA cryptosystem.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最佳矩形。** 给定矩形的面积A，找到一个宽度和高度为整数的矩形，其面积为A，并且高度和宽度之间的差距尽可能接近。例如，如果A = 48，则最佳矩形是6乘以8而不是3乘以16或4乘以12。证明如果你能解决这个问题，你就能破解RSA加密系统。'
- en: '**Buckets of water.** Given two buckets of capacity p and q, a receptacle of
    infinite capacity, a water hose, and a drain, devise a method to get exactly k
    liters of water into the receptacle using the following rules:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**水桶问题。** 给定容量为p和q的两个桶，一个无限容量的接收器，一个水管和一个排水口，设计一种方法，使用以下规则将恰好k升水倒入接收器中：'
- en: You can fill either of the two buckets with the huse.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以用水管装满任一桶。
- en: You can empty either bucket to the drain.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将任一桶倒空到排水口。
- en: 'You can transfer water between the two buckets or either bucket and the receptacle
    until one is full or ther other is empty.Prove that you can solve the problem
    if and only if k is a multiple of gcd(p, q). Hint: use the fact from previous
    exercise that there exist integers a and b such that ap + bq = gcd(p, q).'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在两个桶之间或一个桶和接收器之间转移水，直到一个满了或另一个空了。证明当且仅当k是gcd(p, q)的倍数时，你才能解决这个问题。提示：使用前一个练习中存在整数a和b使得ap
    + bq = gcd(p, q)的事实。
- en: '**Multiplicative inverse.** Given a positive integer n, a *multiplicative inverse
    mod b* of an integer k is an integer x such that (k * x) % n = 1\. Such an inverse
    exists if and only if gcd(k, n) = 1\. Write a program [Inverse.java](Inverse.java.html)
    that reads in two command line arguments k and n and computes the modular inverse
    if it exists. *Hint:* use the answer to the previous exercise. See also `BigInteger.modInverse`.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**乘法逆元。** 给定正整数n，整数k的*模b的乘法逆元*是一个整数x，使得(k * x) % n = 1。这样的逆元存在当且仅当gcd(k, n)
    = 1。���写一个程序[Inverse.java](Inverse.java.html)，读取两个命令行参数k和n，并计算模逆元（如果存在）。*提示：*使用前一个练习的答案。另请参阅`BigInteger.modInverse`。'
- en: '**Breaking the RSA cryptosystem.** One potential way to break the RSA cryptosystem
    is to compute φ(n) given n. Recall that if n = pq, then φ(n) = (p-1)(q-1). Show
    that computing φ(n) is equivalent to factoring.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**破解RSA加密系统。** 破解RSA加密系统的一个潜在方法是在给定n的情况下计算φ(n)。回想一下，如果n = pq，那么φ(n) = (p-1)(q-1)。证明计算φ(n)等同于因式分解。'
- en: '*Solution*: obviously if you can factor n = pq, then computing φ(n) = (p-1)(q-1)
    is easy. To see the other direction, observer that n + 1 - φ(n) = pq + 1 - (p-1)(q-1)
    = p + q = n/q + q. Thus q² - (n + 1 - φ(n))q + n = 0. Assuming we know φ(n), we
    can solve the quadratic equation for q and recover one of the factor of n. We
    can recover the other factor p by computing n/q.'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：显然，如果你能分解n = pq，那么计算φ(n) = (p-1)(q-1)就很容易。要看到另一个方向，观察者可以发现n + 1 - φ(n)
    = pq + 1 - (p-1)(q-1) = p + q = n/q + q。因此q² - (n + 1 - φ(n))q + n = 0。假设我们知道φ(n)，我们可以解二次方程得到q，并恢复n的一个因子。通过计算n/q，我们可以恢复另一个因子p。'
- en: '**Generating public and private RSA keys.** Write a program [RSA.java](RSA.java.html)
    to generate a key pair for use with the RSA cryptosystem, determine two N/2 bit
    primes p and q. Set e = 65537, compute n = (p-1)(q-1), and find a number d such
    that (e * d) % n == 0\. Assuming gcd(e, n) = 1, the inverse d will exist. *Hint:*
    use the [RandomPrime.java](RandomPrime.java.html) to compute p and q, and use
    [Inverse.java](Inverse.java.html) to compute d.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成公钥和私钥RSA密钥。** 编写一个程序[RSA.java](RSA.java.html)来生成用于RSA加密系统的密钥对，确定两个N/2位素数p和q。设置e
    = 65537，计算n = (p-1)(q-1)，找到一个数字d，使得(e * d) % n == 0。假设gcd(e, n) = 1，逆d将存在。*提示：*使用[RandomPrime.java](RandomPrime.java.html)来计算p和q，使用[Inverse.java](Inverse.java.html)来计算d。'
- en: '**Sophie Germaine primes.** The security of the RSA cryptosystem appears to
    be improved if you use special types of primes for p and q. Specifically, a [Sophie
    Germaine prime](http://www.wikipedia.org/wiki/Sophie_Germain_prime) is a prime
    number p where (p-1)/2 is also prime. Generate a public and private RSA key where
    p and q are Sophie Germaine primes. Investigate how long it takes to find such
    a prime as a function of the number of bits N.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Sophie Germaine素数。** 如果你使用特殊类型的素数p和q，RSA加密系统的安全性似乎会得到改善。具体来说，[Sophie Germaine素数](http://www.wikipedia.org/wiki/Sophie_Germain_prime)是一个素数p，其中(p-1)/2也是素数。生成一个公钥和私钥RSA密钥，其中p和q是Sophie
    Germaine素数。调查找到这样一个素数所需的时间与位数N的函数关系。'
- en: '**Fermat primality testing.** The Fermat primality test is an algorithm that
    takes an odd integer n and reports that it is definitely composite or "likely"
    prime. By "likely", the algorithm is sometimes wrong, but not too often. Fermat''s
    theorem says that if p is prime and gcd(a, p) = 1, then a^(p-1) = 1 (mod p). A
    version of the converse is used as a crude primality test in the PGP cryptosystem:
    if 2^(p-1) = 3^(p-1) = 5^(p-1) = 7^(p-1) = 1 (mod p), then use p as a prime. Unfortunately,
    there are some numbers that satisfy this Fermat test, but are not prime (e.g.,
    29341, 46657, 75361).'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**费马素性测试。** 费马素性测试是一种算法，接受一个奇数整数n，并报告它绝对是合数或“可能”是素数。通过“可能”，该算法有时会出错，但不会太频繁。费马定理表明，如果p是素数且gcd(a,
    p) = 1，则a^(p-1) ≡ 1 (mod p)。PGP加密系统中使用的一个版本的逆定理作为粗略的素性测试：如果2^(p-1) ≡ 3^(p-1) ≡
    5^(p-1) ≡ 7^(p-1) ≡ 1 (mod p)，则使用p作为素数。不幸的是，有一些数字满足这个费马测试，但不是素数（例如29341、46657、75361）。'
- en: '**Miller-Rabin primality testing.** The Miller-Rabin algorithm is a randomized
    algorithm for determining whether an odd integer n is prime. It takes a security
    parameter t and outputs either `prime` or `composite`. If it outputs `composite`,
    then n is definitely composite; if it outputs `prime`, then n is probably prime,
    but the algorithm could be wrong with probability 2^(-t).'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**米勒-拉宾素性测试。** 米勒-拉宾算法是一种用于确定奇数整数n是否为素数的随机算法。它接受一个安全参数t，并输出`prime`或`composite`。如果输出`composite`，则n绝对是合数；如果输出`prime`，则n可能是素数，但算法可能以2^(-t)的概率错误。'
- en: '[PRE6]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Factoring.** Win $200,000 from [RSA Security](http://www.rsasecurity.com/rsalabs/challenges/factoring)
    for factoring a 2048 bit number (616 digits). Factor a 64 bit number (32 bit RSA)
    using Program xyz in under a minute. How long to factor a 128 bit number?'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因式分解。** 从[RSA Security](http://www.rsasecurity.com/rsalabs/challenges/factoring)赢得20万美元，用于分解一个2048位数（616位）。使用程序xyz在一分钟内分解一个64位数（32位RSA）。分解一个128位数需要多长时间？'
- en: '**Pollard''s rho method.** Pollard''s rho method is a randomized factoring
    algorithm that can factor 128 bit numbers in a reasonable amount of time, especially
    if the numbers have some small factors. It is based on the following fact: if
    d is the smallest nontrivial factor of N and x - y is a nontrivial multiple of
    d then gcd(x-y, N) = d. A naive method would be to generate a bunch of random
    values x[1], x[2], ..., x[m] and compute gcd(x[i]-x[j], N) for all pairs i and
    j. [Pollard''s rho method](http://planetmath.org/encyclopedia/PollardsRhoFactorization.html)
    is an ingenious method way to find x and y without doing all of the pairwise computations.
    It works as follows: choose a and b at random between 1 and N-1, and initialize
    x = y = a. Repeatedly update x = f(x), y = f(f(y)), where f(x) = x² + b as long
    as gcd(x-y, N) = 1. The gcd is a factor of N, but if you get unlucky, it could
    be equal to N. By randomly choosing a and b each time, we ensure that we never
    get too unlucky. Write a program [PollardRho.java](PollardRho.java.html) that
    takes a command-line argument N and uses the Pollard rho method to compute a prime
    factorization of N. Estimate the running time as a function of N.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波拉德的ρ方法。** 波拉德的ρ方法是一种随机因式分解算法，可以在合理的时间内分解128位数，特别是如果这些数有一些小因子的话。它基于以下事实：如果d是N的最小非平凡因子，而x
    - y是d的非平凡倍数，则gcd(x-y, N) = d。一种朴素的方法是生成一堆随机值x[1]、x[2]、...、x[m]，并计算所有i和j对的gcd(x[i]-x[j],
    N)。[波拉德的ρ方法](http://planetmath.org/encyclopedia/PollardsRhoFactorization.html)是一种巧妙的方法，可以找到x和y，而不必进行所有成对的计算。它的工作原理如下：随机选择a和b在1和N-1之间，并初始化x
    = y = a。重复更新x = f(x)，y = f(f(y))，其中f(x) = x² + b，只要gcd(x-y, N) = 1。gcd是N的一个因子，但如果你运气不好，它可能等于N。通过每次随机选择a和b，我们确保我们永远不会太不幸。编写一个程序[PollardRho.java](PollardRho.java.html)，它接受一个命令行参数N，并使用波拉德ρ方法计算N的素因子分解。估计运行时间作为N的函数。'
- en: '**Feit-Thompson Conjecture.** Disprove the [Feit-Thompson conjecture](http://mathworld.wolfram.com/Feit-ThompsonConjecture.html):
    there are no two primes p and q such that (p^q - 1) / (p - 1) and (q^p - 1) (q
    - 1) have a common factor other than 1. Counterexample: (17, 3313) with common
    factor 112643\.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**费特-汤普森猜想。** 反驳[费特-汤普森猜想](http://mathworld.wolfram.com/Feit-ThompsonConjecture.html)：不存在两个素数p和q，使得(p^q
    - 1) / (p - 1)和(q^p - 1) / (q - 1)有除1以外的公因数。反例：(17, 3313)，公因数为112643。'
- en: '**Karatsuba multiplication.** Write a program [Karatsuba.java](Karatsuba.java.html)
    that multiplies two integers using the [Karatsuba algorithm](http://mathworld.wolfram.com/KaratsubaMultiplication.html).
    This ingenious algorithm computes the product of two 2N-bit integers using only
    three N-bit multiplications (and a linear amount of extra work). To multiply x
    and y, break up x and y into N-bit chunks and use the following identity:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**卡拉兹巴乘法。** 编写一个程序[Karatsuba.java](Karatsuba.java.html)，使用[卡拉兹巴算法](http://mathworld.wolfram.com/KaratsubaMultiplication.html)来计算两个整数的乘积。这种巧妙的算法仅使用三次N位乘法（以及线性量的额外工作）来计算两个2N位整数的乘积。要将x和y相乘，将x和y分解为N位块，并使用以下等式：'
- en: '[PRE7]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Your recursive algorithm should compute the number of bits N and cutoff to the
    default `BigInteger.multiply` method when N is small (say 10,000) and apply the
    Karatsuba divide-and-conquer strategy otherwise. Investigate the optimal cutoff
    point and compare its effectiveness against `BigInteger.multiply` when N = 10
    million.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的递归算法应该计算位数N的数量，并在N较小时（比如10000）将截止值设为默认的`BigInteger.multiply`方法，并在N较大时应用Karatsuba分治策略。调查最佳截止点，并比较其在N
    = 1000万时与`BigInteger.multiply`的有效性。
- en: '**Factoring reduces to finding a factor.** Given a function `factor(N)` that
    returns 1 if N is prime, and any nontrivial factor of N otherwise, write a function
    `factorize(N)` that returns the prime factorization of N.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**因式分解归结为找到一个因子。** 给定一个函数`factor(N)`，如果N是素数则返回1，否则返回N的任何非平凡因子，编写一个函数`factorize(N)`，返回N的素因子分解。'
- en: '**Perfect power.** An integer N is a perfect power if N = p^q for two integers
    p ≥ 2 and q ≥ 2. Design an efficient algorithm (polynomial in the number of bits
    in N) to determine if N is a perfect power, and if so, find its prime factorization.
    *Hint*: for all q ≤ lg N binary search for p satisfying N = p^q.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完全幂。** 如果存在两个整数 p ≥ 2 和 q ≥ 2，使得 N = p^q，则整数 N 是完全幂。设计一个高效的算法（与 N 中位数的位数成多项式关系）来确定
    N 是否是完全幂，如果是的话，找到其质因数分解。*提示*：对于所有 q ≤ lg N，二进制搜索满足 N = p^q 的 p。'
- en: '**Euler''s conjecture.** In 1769 Euler conjectured that there are no positive
    integer solutions to a⁴ + b⁴ + c⁴ = d⁴. Noam Elkies discovered the first counterexample
    2682440⁴ + 15365639⁴ + 18796760⁴ = 20615673⁴ over 218 years later. Write a program
    [Euler.java](Euler.java.html) to disprove Euler''s conjecture. The brute force
    solution outlined in Exercise XYZ won''t work for two reasons: (i) it will take
    too much time to find the solution using a quadruply nested loop, and (ii) computing
    a⁴ will overflow a `long` since the smallest such counterexample is 95800⁴ + 217519⁴
    + 414560⁴ = 422481⁴.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**欧拉猜想。** 在 1769 年，欧拉猜想不存在正整数解使得 a⁴ + b⁴ + c⁴ = d⁴。218 年后，Noam Elkies 发现了第一个反例
    2682440⁴ + 15365639⁴ + 18796760⁴ = 20615673⁴。编写一个程序 [Euler.java](Euler.java.html)
    来证明欧拉的猜想是错误的。在练习 XYZ 中概述的蛮力解决方案不会奏效，原因有两点：（i）使用四重嵌套循环找到解决方案需要太长时间，（ii）计算 a⁴ 会导致
    `long` 溢出，因为最小的这种反例是 95800⁴ + 217519⁴ + 414560⁴ = 422481⁴。'
- en: Use the following idea. Iterate over all integers a and b between 1 and N and
    insert a⁴ + b⁴ into a hash table. Then, iterate over all integers c and d between
    1 and N and search to see if d⁴ - c⁴ is in the hash table. Use extended precision
    integers to avoid overflow.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下思路。遍历 1 到 N 之间的所有整数 a 和 b，并将 a⁴ + b⁴ 插入哈希表中。然后，遍历 1 到 N 之间的所有整数 c 和 d，并搜索以查看
    d⁴ - c⁴ 是否在哈希表中。使用扩展精度整数以避免溢出。
- en: 'Using extended precision integers can be a significant overhead over using
    primitive types. Instead of inserting a⁴ + b⁴ into the hash table, insert a⁴ +
    b⁴ modulo p, where p is some big prime, say XYZ. Then, iterate over all c and
    d and search for d⁴ - c⁴ modulo p. If there''s a match, use extended precision
    arithmetic to check that it isn''t just an coincidental collision. Hint: to avoid
    overflow when computing a⁴ + b⁴ modulo p, modulo out multiples of p after each
    multiplication.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用扩展精度整数可能会比使用原始类型产生显著的开销。不要将 a⁴ + b⁴ 插入哈希表中，而是插入 a⁴ + b⁴ 模 p，其中 p 是某个大素数，比如
    XYZ。然后，遍历所有 c 和 d，并搜索 d⁴ - c⁴ 模 p。如果有匹配项，使用扩展精度算术来检查它不仅仅是一个巧合的碰撞。提示：在计算 a⁴ + b⁴
    模 p 时，每次乘法后都要取出 p 的倍数以避免溢出。
- en: '**Fingerprinting.** Alice and Bob maintain two copies of a large genomics database
    in different locations. For consistency, they want to be ble to compare whether
    the two databases are identical. We interpret the databases as N-bit integers,
    say A and B. Because N is very large, they can''t afford to transmit the whole
    database. Instead, consider the following scheme for sending a *fingerprint* of
    the data that enables Alice and Bob to check if the data is inconsistent. Alice
    generates a random prime number p between 2 and, say, N² and sends p and (A %
    p). This takes only O(log N) bits. Bob declares that A and B are the same if ((A
    % p) == (B % p)). The probability of having a false negative (a no that should
    have been a yes) from the scheme is zero. Show that the probability of having
    a false positive (a yes that should have been a no) goes to 0 as n goes to infinity.
    *Hint*: Use the fact that the number of primes less than n² is at least c n² /
    log n, for some constant c > 0. How many bits are sent?'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指纹识别。** Alice 和 Bob 在不同地点维护着一个大基因组数据库的两份副本。为了保持一致性，他们希望能够比较这两个数据库是否相同。我们将数据库解释为
    N 位整数，称为 A 和 B。由于 N 非常大，他们无法承担传输整个数据库的成本。相反，考虑以下方案发送数据的 *指纹*，使得 Alice 和 Bob 能够检查数据是否不一致。Alice
    生成一个介于 2 和 N² 之间的随机素数 p，并发送 p 和 (A % p)。这只需要 O(log N) 位。Bob 声明如果 ((A % p) == (B
    % p))，则 A 和 B 相同。该方案产生错误否定（应该是是的否定）的概率为零。证明随着 n 趋近无穷大，错误肯定（应该是否定的是）的概率趋近于 0。*提示*：利用小于
    n² 的素数数量至少为 c n² / log n，其中 c > 0 是一个常数。发送了多少位？'
- en: '**Flipping a coin over the phone.** Alice and Bob are in the midst of a bitter
    divorce. They have decided to flip a coin to see who will get custody of their
    only son Carl. However, they refuse to see each other in person and they don''t
    want anyone else to know how the resolved the custody dispute. In other, words,
    we want to devise a method to flip a fair coin over a phone line or the Internet
    so that neither party can cheat. Here is an elegant protocol:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过电话翻转硬币。** Alice 和 Bob 正处于一场激烈的离婚中。他们决定翻一枚硬币来决定谁将获得他们唯一儿子 Carl 的监护权。然而，他们拒绝亲自见面，也不希望任何其他人知道他们如何解决监护权纠纷。换句话说，我们希望设计一种方法，在电话线或互联网上公平地翻转一枚硬币，以便任何一方都无法作弊。以下是一个优雅的协议：'
- en: Alice multiplies together two or three large primes to sends the product N to
    Bob.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 将两个或三个大素数相乘，将乘积 N 发送给 Bob。
- en: Bob receives the integer N and responds with the number 2 or 3.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob 收到整数 N，并回答数字 2 或 3。
- en: Alice waits for a valid response from Bob and then sends Bob the prime factorization
    of N.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 等待 Bob 的有效回应，然后向 Bob 发送 N 的质因数分解。
- en: If Bob guesses the correct number of factors, then he gets custody. Otherwise,
    assuming Alice follows the protocol, she wins custody.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Bob 猜对了因子的数量，那么他获得监护权。否则，假设 Alice 遵循协议，她将赢得监护权。
- en: Explain why the system works by answering each of the following questions. You
    may assume that there is no efficient way to determine whether a given integer
    N has at least 3 nontrivial factors (although this is an unresolved conjecture).
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过回答以下每个问题来解释系统为什么有效。您可以假设没有有效的方法来确定给定整数 N 是否至少有 3 个非平凡因子（尽管这是一个未解决的猜想）。
- en: How can Alice compute N efficiently?
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 如何高效地计算 N？
- en: Why can't Bob efficiently determine the true answer on his own?
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 Bob 不能有效地独自确定真实答案？
- en: How can Bob efficiently check that Alice sent him the correct factorization
    of N? In other words, what's to prevent Alice from revealing two factors (one
    of which is not prime) if Bob says 3, even if she multiplied three (or more) primes
    together?
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob如何有效地检查Alice是否发送了正确的N的因数分解？换句话说，防止Alice在Bob说3时透露两个因数（其中一个不是质数），即使她将三个（或更多）质数相乘在一起。
- en: '**Poker over the phone.** Use the *bit-commitment* scheme described above to
    develop a protocol to play poker over the phone, say between two parties.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**电话上的扑克牌。** 使用上面描述的*比特承诺*方案开发一个在电话上玩扑克牌的协议，比如在两个当事方之间。'
- en: '**Discrete log.** Let *p* be a prime number. The *discrete log* of *a* to the
    base *b* is the unique integer *x* between 0 and *p*-1 such that *a = b^x (mod
    p)*. For example, if *p* = 97, *b* = 5, and *a* = 35, then log[5] 35 = 32 since
    5^(32) = 35 (mod 97). Write a program `DiscreteLog.java` that takes three command
    line inputs a, b, and p, and computes *log[b] a* modulo *p* via brute force search.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**离散对数。** 设*p*为一个素数。*a*对于基数*b*的*离散对数*是唯一的整数*x*，满足0到*p*-1之间的条件，使得*a = b^x (mod
    p)*。例如，如果*p* = 97，*b* = 5，*a* = 35，那么log[5] 35 = 32，因为5^(32) = 35 (mod 97)。编写一个名为`DiscreteLog.java`的程序，通过蛮力搜索，接受三个命令行输入a、b和p，并计算模p下的*log[b]
    a*。'
- en: '**Diffie Hellman.** Let *p* be a prime number, and let *a* and *b* be two integers.
    Given *p*, an *x*, *x^a (mod p)* and *x^b (mod p)*, the *Diffie-Hellman* problem
    is to compute *x^(ab) (mod p)*.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Diffie Hellman。** 设*p*为一个素数，*a*和*b*为两个整数。给定*p*，一个*x*，*x^a (mod p)*和*x^b (mod
    p)*，*Diffie-Hellman*问题是计算*x^(ab) (mod p)*。'
- en: '**Rabin''s cryptosystem.** Select p, q to be prime such that p = 3 mod 4 and
    q = 3 mod 4. The public key is n = pq and the private key is (p, q). To encrypt,
    compute E(m) = m² mod n. To decrypt compute D(c) = sqrt(c) mod n. How to compute
    square root: c = x² mod n? Use extended Euclid''s algorithm to find a, b such
    that ap + bq = 1\. Compute r = c^((p+1)/4) mod p and s = c^((q+1)/4) mod q. Compute
    m = (aps + bqr) mod n and t = (aps - bqr) mod n. The four square roots of c are
    m, -m mod n, t, and -t mod n.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Rabin的加密系统。** 选择p、q为素数，使得p = 3 mod 4且q = 3 mod 4。公钥为n = pq，私钥为(p, q)。加密时，计算E(m)
    = m² mod n。解密时计算D(c) = sqrt(c) mod n。如何计算平方根：c = x² mod n？使用扩展欧几里得算法找到a、b，使得ap
    + bq = 1。计算r = c^((p+1)/4) mod p和s = c^((q+1)/4) mod q。计算m = (aps + bqr) mod n和t
    = (aps - bqr) mod n。c的四个平方根为m，-m mod n，t和-t mod n。'
- en: '**Analog private-key exchange.** You are stranded on an island with a box,
    a padlock with key, and a copy of Introduction to Computer Science. You have a
    friend on another island who also has a box, a padlock with key, but wants to
    borrow your copy of the textbook. You can ship stuff via an unscrupulous courier
    service who will pillage anything inside the box if it is left unlocked. How can
    you get your book to your friend?'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟私钥交换。** 你被困在一个岛上，有一个盒子，一个带钥匙的挂锁，还有一本《计算机科学导论》的副本。你有一个在另一个岛上的朋友，他也有一个盒子，一个带钥匙的挂锁，但想借你的教科书。你可以通过一个不怀好意的快递服务运送物品，如果盒子没有锁上，他们会洗劫盒子里的任何东西。你如何把书送给你的朋友？'
- en: '**Cryptographically secure hash functions.** SHA-1 and MD5\. Can compute it
    by converting string to bytes, or when reading in bytes 1 at a time.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**密码安全的哈希函数。** SHA-1和MD5。可以通过将字符串转换为字节来计算，或者在逐个读取字节时计算。'
- en: '[PRE8]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**RSA in Java.** Built-in functionality for RSA or DSA. Untested code below.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Java中��RSA。** 用于RSA或DSA的内置功能。未经测试的代码如下。'
- en: '[PRE9]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Blum-Blum-Shub pseudorandom bit generator.** Choose two distinct N-bit primes
    p and q such that p mod 4 = q mod 4 = 3. Set n = pq and choose a starting value
    x[0] by selecting a random seed 1 < s < n such that gcd(s, n) = 1. Form the sequence
    of integers x[0] = s² mod n and x[i+1] = x[i] x[i] mod n. Use x[i] % 2 as the
    sequence of pseudorandom bits. No need to keep n secret. Discovering any pattern
    (in poly time) is provably as hard as factoring n. Note: we still need to generate
    p, q, and s at random, but these have only O(N) bits, and we will be able to generate
    2^N pseudorandom bits. Can use as a one-time pad.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Blum-Blum-Shub伪随机比特生成器。** 选择两个不同的N位素数p和q，使得p mod 4 = q mod 4 = 3。设n = pq，并通过选择一个随机种子1
    < s < n，使得gcd(s, n) = 1来选择一个起始值x[0]。形成整数序列x[0] = s² mod n和x[i+1] = x[i] x[i] mod
    n。使用x[i] % 2作为伪随机比特序列。不需要保密n。发现任何模式（在多项式时间内）与分解n一样困难。注意：我们仍然需要随机生成p、q和s，但这些只有O(N)位，我们将能够生成2^N个伪随机比特。可以用作一次性密码本。'
- en: Can also be used for directly for [public-key crypto](http://math.boisestate.edu/~marion/teaching/crypto1f03/bbs_the_system.htm)
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也可以直接用于[公钥加密](http://math.boisestate.edu/~marion/teaching/crypto1f03/bbs_the_system.htm)
- en: '**VCR Plus decoding.** Remote control scheme for recording programs on a VCR
    using special code printed in newspapers. Bad cryptography so easy to break. [paper](http://citeseer.nj.nec.com/260048.html)'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**VCR Plus解码。** 用于在报纸上打印的特殊代码来录制VCR上节目的遥控方案。密码学不好，很容易破解。[论文链接](http://citeseer.nj.nec.com/260048.html)'
- en: '**Pascal''s triangle.** One way to compute the kth row of Pascal''s triangle
    (for k > 2) is to compute (2^k + 1)^(k+1) and take its binary representation k
    bits at a time.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**帕斯卡三角形。** 计算帕斯卡三角形的第k行（对于k > 2）的一种方法是计算(2^k + 1)^(k+1)，并以k位为一组取其二进制表示。'
- en: '[PRE10]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Bailey-Borwein-Plouffe algorithm.** Compute the ith binary digit of π without
    computing the earlier digits using the [BBP algorithm](http://crd.lbl.gov/~dhbailey/expmath/expbook-C.pdf)
    which requires modular exponentiation.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Bailey-Borwein-Plouffe算法。** 使用[BBP算法](http://crd.lbl.gov/~dhbailey/expmath/expbook-C.pdf)计算π的第i位二进制数字，而不需要计算前面的数字，这需要模指数运算。'
- en: '**Secret sharing.** Want to distribute a message to N people so that any 3
    of them can recover the original message, but any 1 or 2 cannot. [reference](http://www.chiark.greenend.org.uk/pipermail/ukcrypto/1999-November/007055.html).
    [Scientific American puzzle](http://sciam.com/article.cfm?chanID=sa006&colID=14&articleID=0009F978-0583-1FFB-809C83414B7F0000)'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**秘密分享。** 想要将一条消息分发给N个人，以便其中任意3个人可以恢复原始消息，但任何1或2个人都不能。[参考链接](http://www.chiark.greenend.org.uk/pipermail/ukcrypto/1999-November/007055.html)。[Scientific
    American谜题](http://sciam.com/article.cfm?chanID=sa006&colID=14&articleID=0009F978-0583-1FFB-809C83414B7F0000)'
- en: '**Mersenne prime.** A *Mersenne prime* is a prime of the form M_p = 2^p - 1,
    where p is an odd prime. To test whether M_p is prime, form the following sequence:
    s_0 = 4, s_i+1 = (s_i)^2 - 2 mod M_p. M_p is prime iff s_(p-2) = 0 mod M_p. This
    is method known as the [Lucas-Lehmer primality test](http://en.wikipedia.org/wiki/Lucas-Lehmer_test_for_Mersenne_primes).'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**梅森素数。** *梅森素数* 是形式为 M_p = 2^p - 1 的素数，其中 p 是一个奇素数。要测试 M_p 是否为素数，形成以下序列：s_0
    = 4，s_i+1 = (s_i)^2 - 2 mod M_p。当且仅当 s_(p-2) = 0 mod M_p 时，M_p 是素数。这种方法被称为[卢卡斯-勒默素数检验](http://en.wikipedia.org/wiki/Lucas-Lehmer_test_for_Mersenne_primes)。'
