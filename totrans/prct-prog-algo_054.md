# 9.5\. 数值线性代数

> 原文：[`introcs.cs.princeton.edu/java/95linear`](https://introcs.cs.princeton.edu/java/95linear)

本节正在大力施工中。

[Java 数值计算](http://math.nist.gov/javanumerics/)提供了关于 Java 中数值计算的信息的焦点。

**线性代数。** 计算机科学应用：小波、计算机图形学中的变换、计算机视觉、谷歌的 PageRank 算法、线性规划、线性回归、马尔可夫链。其他应用：线性和非线性优化、控制理论、组合优化、常微分方程的数值解、电气网络分析、投资组合优化、量子力学。解决这些问题的愿望推动了计算技术的发展。BLAS。

**矩阵。** 在数值线性代数中，*矩阵*是一个实数或复数的矩形表。给定矩阵 A，我们使用符号 A[ij]表示第 i 行和第 j 列的条目。我们可以通过使用二维数组在 Java 中实现矩阵。我们使用`A[i][j]`访问 A[ij]。我们从 0 开始索引以符合 Java 索引约定。

**矩阵乘法。** 两个 N×N 矩阵 A 和 B 的乘积是一个 N×N 矩阵 C，定义为

> ![矩阵乘法](img/04dca913e0c86830217d47b25c278f1b.png)

以下代码片段计算 C = AB。

```
for (int i = 0; i < N; i++)
   for (int j = 0; j < N; j++)
      for (int k = 0; k < N; k++)
         C[i][j] += A[i][k] * B[k][j];

```

**行主序 vs. 列主序。** 可以对缓存和性能产生巨大影响。在 Java 中最好迭代一行而不是一列。我们可以以 3！= 6 种方式重新排列矩阵乘法三重循环以获得相同的答案。每种可能性具有不同的内存访问模式，可能在机器架构（缓存、分页等）上表现非常不同（2-3 倍）。程序 MatrixMultiplication.java 在 6 个顺序中执行矩阵乘法，并输出所需的时间。一些架构具有内置的 gaxpy 方法等。高性能矩阵库非常精心地调整到将要运行的机器架构，以充分利用这些效果。

*微优化。* 在许多应用中，矩阵乘法是瓶颈计算，因此在这里考虑是合适的。我们可以明确地缓存某些行和列以加快计算速度。我们缓存 A 的第 i 行和 B 的第 j 列。由于 Java 数组是按行排序的，我们将 B 的第 j 列的条目复制到一维数组中以便未来访问。为什么更快？更好的内存访问模式。避免边界检查。现在赋值语句的数量与 N² 成正比，而不是 N³。

```
double[] ai;                   // row i of A
double[] bj = new double[N];   // column j of B
for (int j = 0; j < N; j++) {
   for (int k = 0; k < N; k++) bj[k] = B[k][j];
   for (int i = 0; i < N; i++) {
      ai = A[i];
      double s = 0;
      for (int k = 0; k < N; k++)
          s += ai[k] * bj[k];
      C[i][j] = s;
   }
}

```

也可以通过使用大小为 N²的一维数组而不是 Java 数组的数组来提高性能（可能高达 2 倍）。这里有一个关于在 Java 中使用矩阵的[概述](http://www.ii.uib.no/~geirg/NIK2002.pdf)。

**线性方程组。** 线性代数中最基本和重要的���题之一是找到方程 Ax = b 的解 x。差分方程、插值、数字信号处理、最小二乘、预测、经济均衡的 Leontief 模型、胡克弹性定律、[交通分析](http://aix1.uottawa.ca/~jkhoury/networks.htm)、[板材中的热平衡](http://aix1.uottawa.ca/~jkhoury/temp.htm)、线性和非线性优化。

**基尔霍夫电压定律。** [电路](http://aix1.uottawa.ca/~jkhoury/networks.htm)的环流分析。

**行操作。** 考虑以下三个未知数的线性方程组。

```
 0x0 + 1x1 +  1x2 =  4
 2x0 + 4x1 -  2x2 =  2
 0x0 + 3x1 + 15x2 = 36

```

我们可以应用一些恒等式将方程组转化为一个可能更容易解决的等价方程组。我们将使用以下两种形式的转换。

+   *行互换。* 交换任意两行。例如，我们可以交换上面的第一行和第二行以得到等价系统。

    ```
     2x0 + 4x1 -  2x2 =  2
     0x0 + 1x1 +  1x2 =  4
     0x0 + 3x1 + 15x2 = 36

    ```

    在 Java 中，交换二维数组中的第 i 行和第 j 行是一种特别高效的操作。我们只需要交换第 i 行和第 j 行的引用。

    ```
    double[] temp = A[i];   // ith row of A
    A[i] = A[j];
    A[j] = temp;

    ```

+   *线性组合。* 将一个行的多倍加或减去另一个行。例如，我们可以从第三个方程中减去第二个方程的三倍，以获得另一个等价系统。

    ```
     2x0 + 4x1 -  2x2 =  2
     0x0 + 1x1 +  1x2 =  4
     0x0 + 0x1 + 12x2 = 24

    ```

    这种转换涉及乘以一个实数，因此即使我们从整数系数开始，最终可能得到实数系数。

**回代法。** 上述最后一个方程组特别适合求解。从最后一个方程（12 x[2] = 24）中，我们可以立即推导出 x[2] = 2。将 x[2] = 2 代入第二个方程中得到 x[1] + 2 = 4。现在我们可以推导出 x[1] = 2。最后，我们可以将 x[1] 和 x[2] 代入第一个方程中。这导致 2x[0] + 4(2) - 2(2) = 2，这意味着 x[0] = -1。这种回代过程在 Java 中表达起来很简单。

```
for (int j = N - 1; j >= 0; j--) {
    double t = 0.0;
    for (int k = j + 1; k < N; k++)
        t += A[j][k] * x[k];
    x[j] = (b[j] - t) / A[j][j];
}

```

**高斯消元法。** 高斯消元法是解线性方程组的最古老和最广泛使用的算法之一。该算法由刘徽在 263 年明确描述，当时他在解释著名的中国文本《九章算术》时提出了解决方案，但实际上可能早在此之前就已被发现。高斯消元法这个名称是在高斯使用它来预测天体位置时产生的，他使用了自己新发现的最小二乘法。对原始方程组应用行操作，将其转换为上三角形式。然后使用回代法。

> ![高斯消元法示意图](img/9fecd45b65d87b5c2240fe2f69215b3b.png)

以下*虚构*代码是高斯消元法的一个简单实现。

```
for (int i = 0; i < N; i++) {
   // pivot within b
   for (int j = i + 1; j < N; j++)
      b[j] -= b[i] * A[j][i] / A[i][i];

   // pivot within A
   for (int j = i + 1; j < N; j++)
      // optimization precompute m = A[j][i] / A[i][i] and loop upwards
      for (int k = N - 1; k >= i; k--)
         A[j][k] -= A[i][k] * A[j][i] / A[i][i];
      A[j][i] = 0.0;  // can stop previous loop at i+1

```

不幸的是，如果其中一个主元素`A[i][i]`为零，代码会除以零并失败。有一些重要的应用场景，我们保证永远不会遇到零主元素并陷入困境（例如，如果矩阵严格对角占优或对称正定），但一般情况下，我们必须通过将包含零主元素的行与其下方的另一行交换来确保零主元素永远不会出现。如果没有这样的行存在，则系统要么没有解，要么有无穷多个解。（参见练习 XYZ 和 XYZ。）

*部分主元素选取。* 一种常见的主元素选取策略是选择具有最大（绝对值）主元素的行，并在每次主元素选取之前进行交换，无论我们是否遇到潜在的零主元素。程序 GaussianElimination.java 实现了带有部分主元素选取的高斯消元法。这种选择规则被称为*部分主元素选取*。它被广泛使用，因为除了解决零主元素问题外，它还显著提高了算法的数值稳定性。要看到其效果，请考虑以下方程组，其中 a = 10^(-17)。

```
ax0 +  x1 = 1
 x0 + 2x1 = 3

```

如果我们不在最大系数上选主元，那么高斯消元会产生解（x[0]，x[1] = (0.0, 1.0)，而带部分主元的高斯消元会产生 (1.0, 1.0)。精确答案是 (99999999999999997/99999999999999998, 50000000000000000/49999999999999999)。带部分主元的解提供了 16 位小数的精度，而不带部分主元的解对于 x[0] 的精度为 0 位。尽管这个例子是为了演示和放大效果而构造的，但在实践中确实会出现这种情况。这个例子是一个问题实��很好的情况，但算法（不带部分主元）是不稳定的。在这个例子中，通过使用部分主元解决了潜在的问题。 （参见练习 XYZ，一个例子展示了即使实例不是病态的情况下部分主元也会失败。）数值分析师对带部分主元的高斯消元有很高的信心，尽管它不能被证明是稳定的。当问题实例本身是病态的时候，没有浮点算法能够拯救它。为了检测这种情况，我们计算*条件数*，它衡量矩阵的病态程度。解中的位数约等于数据中的位数 - lg kappa(A)。

*完全主元.* 选择主元素为仍需行约化的条目中绝对值最大的条目。交换行和列（而不仅仅是行）。更多的簿记和搜索主元的时间，但更好的稳定性。然而，科学家们在实践中很少使用完全主元，因为部分主元几乎总是成功的。

高斯消元法也可用于计算秩，因为行操作不会改变秩。m×n 矩阵的秩：如果在列 j 中选主元时卡住了，就继续到列 j+1。秩 = 终止时非零行数。

[有趣的矩阵](http://math.nist.gov/MatrixMarket/) 用于测试。

*迭代方法.* 高斯消元中会积累舍入误差。迭代方法（高斯-赛德尔，雅各比迭代，逐次超松弛）也可用于改进通过高斯消元获得的线性方程组的解。也可以从头开始解决 - 如果 A 是稀疏的话，这是一个很大的优势。高斯-赛德尔：x[0] = b, x[k+1] = (I - A)x[k] + b。如果 A 的对角线上的元素都是 1（可以通过重新缩放假设），且（I - A）的所有特征值的绝对值都小于 1，那么高斯-赛德尔迭代会收敛到真解。

**矩阵 ADT.** 现在，我们描述一个矩阵的 ADT。

```
public class Matrix {
    private double[][] data;
    private int M;
    private int N;
}

```

程序 Matrix.java 实现了以下操作：加法，乘法，转置，单位矩阵，迹，随机矩阵。更多操作：逆，秩，行列式，特征值，特征向量，范数，解，条件数，奇异值。

**用于数值线性代数的 Java 库**。构建高效和稳健的线性代数问题算法是一项具有挑战性的任务。幸运的是，这些算法在过去几十年中得到了改进，成熟的库易于访问。[JAMA：Java 矩阵包](http://math.nist.gov/javanumerics/jama/) 是一个包括解 Ax = b，计算特征值，计算奇异值分解等矩阵操作的库。这些算法与 EISPACK、LINPACK 和 MATLAB 中的算法相同。这个软件已经被 MathWorks 和国家标准技术研究所（NIST）释放到公共领域。这里是[Javadoc 文档](http://math.nist.gov/javanumerics/jama/doc/)。程序 JamaTest.java 演示了如何与这个库进行交互。它使用 JAMA 包解决了一个包含 3 个未知数的线性方程组。

**特征值和特征向量。** 给定一个方阵 A，特征值问题是找到满足 Ax = λx 的解。满足这个方程的标量λ被称为*特征值*，对应的向量 x 被称为*特征向量*。特征值问题的解在许多科学和工程学科的计算基础设施中扮演着重要角色。1940 年，塔科马纳罗斯大桥在建成四个月后倒塌，因为风的频率太接近桥梁的固有频率，导致了压倒性的振荡。桥梁的固有频率是模拟桥梁的线性系统中最小的特征值。特征值也用于分析弦的振动模式，微分方程的解，莱斯利矩阵模型的人口动态，检测固体中的裂缝或变形，勘探土地寻找石油，减少汽车乘客舱内的噪音，设计音质最佳的音乐厅，计算刚体的惯性轴。

*谱分解。* 如果 A 是对称的，那么特征值分解是 A = VΛV^T，其中Λ是特征值的对角矩阵，V 是特征向量的正交矩阵。程序 Eigenvalues.java 生成一个随机的对称正定矩阵，并使用 Jama 库`EigenvalueDecomposition`计算其谱分解。

*幂法。* 在许多科学和工程应用中，主特征值（绝对值最大的）和相关的特征向量揭示了主导行为模式。例如，谷歌使用它来排名最重要的网页，结构工程师使用它来测量桥梁的最大荷载，声学工程师使用它来测量音乐厅中最低的共振频率。*幂法*是一种简单的方案来分离最大特征值和相关的特征向量。

+   x = Ax

+   x = x / |x|

+   λ = x^TAx / x^Tx

这里的|x|表示 L1 范数（用于概率分布）或 L2 范数。在一般的技术条件下，λ收敛到主特征值，x 收敛到主特征向量。

*马尔可夫链稳态分布。* 马尔可夫链是...像一个随机的 NFA。计算马尔可夫链在每个状态中花费的时间比例。稳态分布满足π A = π。向量π是对应于特征值 1 的（归一化的）特征向量。在某些技术条件（遍历性）下，稳态分布是唯一的，它是 A^T 的主特征向量。这个特征向量的所有分量都保证是非负的。

*Google 的 PageRank 算法。* 使用特征值来排名网页的重要性或者根据赛程强度排名足球队伍。[好的讨论](http://www.math.utsc.utoronto.ca/b24/KendallWei.pdf)。

Jack Dongarra 有一个在线指南[代数特征值问题的解模板](http://www.cs.utk.edu/~dongarra/etemplates/)。

**奇异值。** *奇异值分解*是科学和工程中的一个基本概念，也是数值线性代数中最核心的问题之一。给定一个 M×N 矩阵 A，奇异值分解是 A = UΣV^T，其中 U 是具有正交列的 M×N 矩阵，Σ是一个 N×N 对角矩阵，V 是一个 N×N 正交矩阵。在统计学中也被称为主成分分析（PCA），在模式识别中被称为 Karhunen-Loeve 或 Hotelling 展开。奇异值分解对于任何 M×N 矩阵都是明确定义的（即使矩阵没有完整的行或列秩），并且基本上是唯一的（假设奇异值按降序排列）。它的计算效率为 O( min { MN², M²N } )。它具有许多惊人和美丽的性质，我们只会开始探索其中的一部分。奇异值分解有许多应用：多元线性回归、因子分析、计算机图形学、[人脸识别](http://vismod.media.mit.edu/vismod/demos/facerec/basic.html)、降噪、信息检索、机器人技术、基因表达分析、计算断层摄影、地球物理反演（地震学）、图像压缩、图像去模糊、人脸识别、利用光学线性灵敏度矩��分析航天器动态、化学数据库的可视化以及潜在语义索引（LSI）。在[生物学](http://cmgm.stanford.edu/biochem218/Projects%20Spring%202003/McGrath.pdf)中也被广泛应用于解卷积涉及三种 pH 指示剂混合的滴定，蛋白质动力学分析肌红蛋白的运动，微阵列数据分析，逆向工程基因网络。

程序 SVD.java 计算一个随机 8×5 矩阵的奇异值。它还输出条件数、数值秩和 2-范数。

**图像处理。** 有损压缩。压缩图像和其他数据的一种流行技术是通过 SVD 或 Karhunen-Loeve 分解。我们可以将一个 M×N 像素图像视为三个 M×N 数组，分别表示红色、绿色和蓝色强度，每个强度在 0 到 255 之间。使用 SVD，我们可以计算每个三个矩阵的“最佳”秩 r 近似。这可以仅使用 r(M + N + 1)个值来存储，而不是 MN。随着 r 的增大，图像的质量会提高，但会增加存储成本。

SVD 的最重要特性之一是*截断 SVD* A[r] = U[r]S[r]V[r] 是矩阵 A 的最佳秩 r 近似，其中 U[r]表示 U 的前 r 列，V[r]表示 V 的前 r 列，S[r]表示 S 的前 r 行和列。这里的“最佳”是指 L_2 范数 - A[r]使得 A 和 A[r]之间的差的平方和最小化。

程序 KarhunenLoeve.java 读入一张图片和一个整数 r，计算其红色、绿色和蓝色矩阵的最佳秩 r 近似，并显示结果压缩后的图片。关键子程序计算矩阵 A 的最佳秩 r 近似。方法`getMatrix(i1, i2, j1, j2)`返回由指定行和列索引限定的 A 的子矩阵。

```
public static Matrix KL(Matrix A, int r) {
   int M = A.getRowDimension();
   int N = A.getColumnDimension();
   SingularValueDecomposition svd = A.svd();
   Matrix Ur = svd.getU().getMatrix(0, M-1, 0, r-1);
   Matrix Vr = svd.getV().getMatrix(0, N-1, 0, r-1);
   Matrix Sr = svd.getS().getMatrix(0, r-1, 0, r-1);
   return Ur.times(Sr).times(Vr.transpose());
}

```

下面的图像展示了对著名的 Mandrill 测试图像进行 KL 变换的结果，秩分别为 2、5、10、25、50 和 298。最后一个是原始图像。

| ![Karhunen-Loeve transform](img/903784043c79a2c418d40c2d80ffb70d.png) | ![Karhunen-Loeve transform](img/2ca0ffcb1f264ca66b2c439e8acf00f8.png) | ![Karhunen-Loeve transform](img/8600f4e539e90a5df033b11686621418.png) |
| --- | --- | --- |
| ![Karhunen-Loeve transform](img/944ef9284758af992e8f36d4118aab3a.png) | ![Karhunen-Loeve transform](img/61db57ea890b27265b9546e1d049a081.png) | ![Karhunen-Loeve transform](img/019e768915961025923e85d7f0cdc0e3.png) |

**潜在语义索引。** 谷歌用于分类网页，语言学家用于分类文档等的 LSI。创建矩阵，其中行索引文档中的术语，列索引文档。矩阵条目 (i, j) 是术语 i 在文档 j 中出现的次数的某种函数。矩阵 AA^T 衡量文档之间的相似性。特征向量对应于语言概念，例如，体育可能包含足球、曲棍球和棒球等术语。LSI 技术可以识别文档之间的隐藏相关性，即使这些文档没有共同的术语。例如，术语汽车和汽车被拉在一起，因为两者都经常与轮胎、散热器和汽缸等术语一起出现。

**中心节点和权威节点。** Kleinberg 的方法用于查找相关的网页。如果从 i 到 j 有链接，则 A[ij] = 1，否则为 0。矩阵 A^TA 统计 i 和 j 共同拥有多少链接；矩阵 AA^T 统计多少共同页面链接到 i 和 j。*中心节点*是指指向多个权威页面的页面；*权威节点*是指被多个中心节点指向的页面。矩阵 A^TA 的主要成分（或者等价地，SVD A = USV^T 中 U 的第一列）给出了“主要中心节点”；矩阵 AA^T 的主要成分（或者等价地，V 的第一列）给出了“主要权威节点”。

**基因表达数据分析。** 将基因置于一系列实验中，并尝试将具有相似响应的基因聚类在一起。通过转录响应对基因进行分组，通过表达谱对实验进行分组。

**稀疏矩阵。** 如果非零元素的数量与 N 成比例，则 N×N 矩阵是*稀疏*的。在优化和解决偏微分方程的情况下，维度为 100,000 的稀疏矩阵会出现。搜索引擎谷歌使用大小为 N = 40 亿的庞大稀疏矩阵进行计算。在这些情况下，2D 数组表示变得无用。例如，要计算矩阵-向量乘积将需要二次空间和时间。计算主特征向量的幂法需要快速的矩阵-向量乘法。我们将描述如何在线性时间内执行相同的计算。主要思想是仅显式存储矩阵 A 的 s 个非零元素，同时保留足够的辅助信息以便与 A 进行计算。我们将描述一种被称为*压缩行存储*的流行[稀疏矩阵存储方案](http://www.cs.utk.edu/~dongarra/etemplates/node372.html#sec:data-structures)。我们将所有 s 个非零条目连续存储在一个一维数组 `val[]` 中，以便 `val[j]` 存储第 j 个非零元素（按从左到右、从上到下的顺序）。我们还维护两个额外的辅助数组，以提供对各个矩阵条目的访问。具体来说，我们维护一个大小为 s 的整数数组 `col[]`，使得 `col[j]` 是第 j 个非零元素出现的列。最后，维护一个大小为 N+1 的整数数组 `row`，使得 `row[i]` 是数组 `val` 中第 i 行的第一个非零元素的索引。按照惯例，`row[N] = s`。

```
0.1  0.0  0.0  0.2     val[] =  0.1  0.2  0.3  0.4  0.5
0.3  0.0  0.0  0.0     col[] =  0    3    0    1    2
0.0  0.0  0.0  0.0       
0.0  0.4  0.5  0.0     row[] = 0 2 3 3 5

```

由于每个`double`占用 8 字节，每个`int`占用 4 字节，CRS 的整体存储大约为 12s + 4N。与 2D 数组表示需要的 8N² 字节相比，这是有利的。现在，如果 A 使用 CRS 表示，那么矩阵-向量乘积 y = Ax 可以使用以下紧凑的代码片段高效计算。现在，浮点运算的数量与 (s + N) 成正比，而不是 N²。

```
double[] y = new double[N];
for (int i = 0; i < N; i++)
   for (j = row[i]; j < row[i+1]; j++)
      y[i] += val[j] * x[col[j]];

```

计算 y = A^Tx 稍微棘手，因为朴素方法涉及遍历 A 的列，这在 CRS 格式下不方便。改变求和顺序得到：

```
double[] y = new double[N];
for (int j = 0; j < N; j++)
   for (int i = row[j]; j < row[j+1]; i++)
      y[col[i]] += val[i] * x[j];

```

**共轭梯度法。** 当 A 对称正定时的 Krylov 子空间方法。[可能省略或留作练习。]

#### 问答

问：有没有理由明确计算矩阵的逆？

A. 是的，如果在考试中要求。在实践中，几乎从不需要。要解 Ax = b，应该使用高斯消元而不是形成 A^(-1)b。如果需要为许多不同的 b 值解 Ax = b，则使用称为 LU 分解的东西。它是两倍快，具有更好的数值精度和稳定性属性。

#### 练习

1.  在`Matrix`中添加一个名为`frobenius()`的方法，返回矩阵的 Frobenius 范数。*Frobenius 范数*是所有条目的平方和的平方根。

1.  添加一个名为`normInfinity`的方法，返回矩阵的*无穷范数*。无穷范数（又称行和范数）是通过将每行中元素的绝对值相加得到的最大和。

1.  添加一个名为`trace`的方法，返回矩阵的*迹*。迹是对角线条目的总和。

1.  添加一个名为`isSymmetric`的方法，如果矩阵是*对称*的，则返回`true`，否则返回`false`。矩阵 A 是对称的，如果它是方阵且对于所有 i 和 j，A[ij] = A[ji]。

1.  添加一个名为`isTridiagonal`的方法，如果矩阵是*三对角*的，则返回`true`，否则返回`false`。

1.  给定一个 N×N 数组`a[][]`，编写一个代码片段来原地转置`a`。也就是说，最多使用少量额外的存储变量。

1.  添加一个名为`plusEquals`的方法，以矩阵 B 作为输入，并用自身和 B 的和覆盖调用矩阵。

1.  假设你进行高斯消元而不交换行。展示它将在哪里失败

    ```
    0x0 +  x1 = 7
     x0 + 0x1 = 5

    ```

1.  替代的主元策略：选择列 j 中的行，使得|A_ij| / max_k | A_ik|尽可能大。

1.  通过部分主元消去法手工解以下系统 Ax = b。创建的数字最大为 2⁵。对于 N×N 系统，泛化为 2^N。

    ```
         1  0  0  0  1         1          1/2
        -1  1  0  0  1         0           0
    A = -1 -1  1  0  1    b =  0     x =   0
        -1 -1 -1  1  1         0           0
        -1 -1 -1 -1  1         0          1/2

    ```

    中间表达式膨胀。

1.  考虑一个 N×N 矩阵 A，形式如下，对于 N = 100，

    ```
        1.1000         0         0         0         0    1.0000
       -0.9000    1.1000         0         0         0    1.0000
       -0.9000   -0.9000    1.1000         0         0    1.0000
       -0.9000   -0.9000   -0.9000    1.1000         0    1.0000
       -0.9000   -0.9000   -0.9000   -0.9000    1.1000    1.0000
       -0.9000   -0.9000   -0.9000   -0.9000   -0.9000    1.0000

    ```

    和一个向量 b = [1, 0, 0, ..., 0, 0]。矩阵 A 是非奇异的，Ax = b 有唯一解 x = [1/2, 0, 0, ..., 0, 9/20]。使用带部分主元消去的高斯消元解 Ax = b（使用我们的代码或 Jama 库）。检查残差误差，并观察解向量在许多坐标上没有有效数字。矩阵 A 是良好条件的，因此这不是问题不良条件的结果，如 XYZ 中所述。相反，这是因为部分主元消去是不稳定的，这个输入突显了这个缺陷。将你的程序命名为 PartialPivotStability.java。

1.  通过手工使用回代法解以下上三角线性方程组。

    ```
      2x1 + 4x2 - 2x3 =  2
      0x1 + 1x2 + 1x3 =  4
      0x1 + 0x2 + 4x3 =  8

    ```

    *答案:* -1 2 2。

1.  通过手工使用高斯消元和回代解以下线性方程组。

    ```
      2x1 + 4x2 - 2x3 =  2
      4x1 + 9x2 - 3x3 =  8
    - 2x1 - 3x2 + 7x3 = 10

    ```

    *答案:* -1 2 2。你应该在解上一个练习中获得上三角系统。

1.  解以下线性方程组。

    ```
    -9x1 -  x2 +  x3 +  x4 +  x5 + 3x6 =   2
     2x1 - 7x2 -  x3 +  x4 +  x5 +  x6 = -12
      x1 + 2x2 - 9x3 -  x4 +  x5 + 3x6 = -33
      x1 +  x2 + 2x3 - 7x4 -  x5 +  x6 = -29
      x1 +  x2 +  x3 + 2x4 - 9x5 - 3x6 =  21
      x1 +  x2 +  x3 +  x4 + 2x5 - 7x6 = -13

    ```

    *答案:* 2 3 5 7 -1 4。

    **三角形的面积和 ccw。** 三角形面积的公式已知已有 2000 年。小学公式（1/2 底*高）和海伦公式需要分析三角函数或取平方根。在 17 世纪，笛卡尔和费马使用线性代数来深入了解几何问题。例如，以下行列式给出了以 a、b 和 c 为顶点的三角形的带符号面积的两倍。

    ```
    | ax  ay  1 |
    | bx  by  1 |
    | cx  cy  1 |

    ```

    行列式的符号指定了 c 是在 a 到 b 的线上的左侧、右侧还是在线上。这个 ccw 测试对于凸包和其他计算几何算法非常有用。自然地推广到更高维度的四面体和其他单纯形。

    **内切圆测试。** 确定点 d 是否在平面上由三个点 a、b 和 c 定义的圆内或圆外。应用：Delaunay 三角剖分算法中的原始操作。假设 a、b、c 按逆时针顺序标记在圆周上，如果 d 在圆内则下面的行列式为正，如果 d 在圆外则为负，如果所有四个点共圆则为零。这自然地推广到更高维度，例如，点在由 4 个点定义的球内。

    ```
    | ax  ay  ax² + ay²  1 |
    | bx  by  bx² + by²  1 |
    | cx  cy  cx² + cy²  1 |
    | dx  dy  dx² + dy²  1 |

    ```

1.  给定包含三个点（10, 5, 2）、（3, 8, 9）和（3, 6, -1）的平面方程 ax + by + cz = 1。

1.  找到以下矩阵的特征值和特征向量。

    ```
     3  -1
    -1   3

    ```

    *答案：* λ[1] = 2, λ[2] = 4。

1.  假设你面临计算 c^TA^(-1)d 的问题。解释如何在不显式计算 A^(-1) 的情况下做到这一点。*解决方案。* 使用高斯消元解 Ax = d 得到 x。现在所需的答案是 c^Tx。每当在一个公式中看到一个逆时，总是将其视为解方程而不是计算逆。

#### 创造性练习

1.  **复杂矩阵。** 创建一个抽象数据类型来表示复杂矩阵。

1.  **熄灯游戏。** 实现游戏 [Lights Out](http://www.braingle.com/games/disco/index.php?play=1) 的求解器。解一个线性方程组（在 Z_2 上）以确定应该打开哪些灯（如果存在这样的解）。

1.  **可行性检测。** 无法找到非零主元，且当前右侧不为零。

1.  **不可行性证书。** 如果 Ax = b 没有解，那么高斯消元将失败。如果是这样，那么存在一个向量 c，使得 c^TA = 0 且 c^Tb ≠ 0。修改高斯消元，使其在 Ax = b 没有解时产生这样一个向量。

1.  **三对角矩阵。** 实现一个数据类型 `TridiagonalMatrix`，使用三个 1-D 数组实现三对角矩阵。设计一个算法，当 A 是一个方三对角矩阵时解 Ax = b。你的算法应该在线性时间内运行。

1.  **Strassen 算法。** 用于矩阵乘法的 N^(2.81) 分治算法。与高斯消元比较���

1.  **特殊矩阵。** 使用继承创建类 `DiagonalMatrix`、`TridiagonalMatrix`，并重写解线性方程组和矩阵乘法的方法...

1.  **马尔可夫链。** 马尔可夫链是一种简单的数学工具，用于建模行为模式。广泛应用于包括排队理论、统计学、建模人口过程和基因预测在内的许多科学领域。 Glass 和 Hall（1949）在他们的社会流动性研究中区分了 7 个状态：

    1.  专业的，高级管理

    1.  管理的

    1.  检查、监督、非手工高级

    1.  非手工低级

    1.  熟练的手工

    1.  半熟练的手工

    1.  未熟练的手工

    下表呈现了他们研究的数据。条目 (i, j) 是从状态 i 过渡到 j 的概率。

    ```
      { 0.386, 0.147, 0.202, 0.062, 0.140, 0.047, 0.016 }
      { 0.107, 0.267, 0.227, 0.120, 0.207, 0.052, 0.020 }
      { 0.035, 0.101, 0.188, 0.191, 0.357, 0.067, 0.061 }
      { 0.021, 0.039, 0.112, 0.212, 0.431, 0.124, 0.061 }
      { 0.009, 0.024, 0.075, 0.123, 0.473, 0.171, 0.125 }
      { 0.000, 0.103, 0.041, 0.088, 0.391, 0.312, 0.155 }
      { 0.000, 0.008, 0.036, 0.083, 0.364, 0.235, 0.274 }

    ```

    编写一个程序 MarkovChain.java 来计算一些有趣的数量。

1.  **希尔伯特矩阵。** 编写一个程序 Hilbert.java，读取一个命令行参数 N，创建一个 N×N 的 *希尔伯特矩阵* H，数值计算其逆 H^(-1)。希尔伯特矩阵的 i-j 元素是 1/(i+j-1)。所有希尔伯特矩阵都是可逆的。下面是 4×4 希尔伯特矩阵及其逆矩阵

    ```
        1    1/2  1/3  1/4              16   -120    240   -140
    H = 1/2  1/3  1/4  1/5     H^-1 = -120   1200  -2700   1680
        1/3  1/4  1/5  1/6             240  -2700   6480  -4200
        1/4  1/5  1/6  1/7            -140   1680  -4200   2800

    ```

    当你尝试求一个 100×100 的希尔伯特矩阵的逆时会发生什么？

    *答案：* Jama 矩阵求逆器报告该矩阵不可逆。希尔伯特矩阵病态，大多数线性代数包在求解较大 N 的情况下难以求逆该矩阵。请注意，尽管它可以求逆较小的矩阵而不报告错误，但结果中存在实质性的误差。

1.  **马尔可夫链稳态分布。** 如果马尔可夫链 M 是*不可约*（经过有限次转换可以从任意状态到达任何其他状态）且非周期的，那么它被称为*遍历的*。稳态分布是 M 的（唯一的）对应于特征值=1 的特征向量。

1.  **详细平衡。** 马尔可夫链的一个特殊情况是满足*详细平衡*：存在π[i]使得π[i] p[ij] = π[j] p[ji]对于所有 i 和 j != i 成立。证明如果满足详细平衡，则π P = π。*提示*：对 j 求和。

1.  **环上的随机行走。** 假设你有一个 N 个节点的圆圈，并且你从节点 1 开始。在每一步中，你抛一枚公平的硬币，然后顺时针或逆时针移动。计算每个顶点（除了 1 之外）是最后一个被访问的概率。*解答*：所有的顶点被访问的概率相等！

1.  **莱昂蒂夫投入产出模型。** 经济学的一个分支，利用线性代数来模拟产业之间的相互依赖关系。（瓦西里·莱昂蒂夫获得 1973 年诺贝尔经济学奖）[描述](http://aix1.uottawa.ca/~jkhoury/leonteif.htm)。莱昂蒂夫将美国经济分为 81 个部门（石油、纺织品、交通运输、化学品、钢铁、农业等）[例子](http://www.krellinst.org/AiS/textbook/unit7/f77_7.11_leontief.html) *技术矩阵*表示生产一单位另一资源所需的每种资源的数量。例如，生产 1 单位石油需要 0.2 单位交通运输，0.4 单位化学品，和 0.1 单位石油本身。单位以百万美元计量。

    ```
    Petroleum      0.10 0.40 0.60 0.20
    Textiles       0.00 0.10 0.00 0.10
    Transportation 0.20 0.15 0.10 0.30
    Chemicals      0.40 0.30 0.25 0.20

    ```

    如果经济产出石油净额为 900 百万美元，纺织品，交通运输和化学品分别为 300，850 和 800，那么经济内部消费的各项数量是多少。将 Ax 相乘得到 b [880, 110, 550, 822.50]。

1.  **莱昂蒂夫封闭模型。** 平衡经济：Ax = x。每个部门的总产量等于总消费。

1.  **莱昂蒂夫开放模型。** 外部需求向量 d：Ax + d = x。如果存在具有非负分量的解，则矩阵是*生产性的*。$1 吨煤需要 0.3 度电，0.1 汽车，和 0.1 吨煤。

    ```
    Coal               0.10 0.25 0.20
    Electricity        0.30 0.40 0.50
    Auto manufacturing 0.10 0.15 0.10

    ```

    需求 d = [50 75 125]。 (I - A)x = d。 x = [229.9, 437.8, 237.4]。

1.  **莱斯利矩阵模型。** 在种群生态学中，莱斯利矩阵模拟了一个自然分段为年龄类别的种群的年龄分布。设 F[i]为第 i 类��性的繁殖率，S[i]为从第 i 类到 i+1 类的存活率。莱斯利矩阵 L 的构造方式为：

    > ![莱斯利矩阵](img/dd2d01015adadd630f858a0c5b6d5193.png)

    下表列出了[新西兰母羊](http://www.math.duke.edu/education/ccp/materials/linalg/leslie/lesl1.html)的出生和存活概率。原始来源为：[G. Caughley, "季节性繁殖种群的参数," 生态学 48(1967)834-839]。

    > | 年龄（年） | 出生率 | 存活率 |
    > | --- | --- | --- |
    > | 0-1 | 0.000 | 0.845 |
    > | 1-2 | 0.045 | 0.975 |
    > | 2-3 | 0.391 | 0.965 |
    > | 3-4 | 0.472 | 0.950 |
    > | 4-5 | 0.484 | 0.926 |
    > | 5-6 | 0.546 | 0.895 |
    > | 6-7 | 0.543 | 0.850 |
    > | 7-8 | 0.502 | 0.786 |
    > | 8-9 | 0.468 | 0.691 |
    > | 9-10 | 0.459 | 0.561 |
    > | 10-11 | 0.433 | 0.370 |
    > | 11-12 | 0.421 | 0.000 |

    莱斯利矩阵特性：唯一的正特征值和对应的特征向量的所有条目都是实数且符号相同。在这个例子中为 1.175。使用[特征值](http://isolatium.uhh.hawaii.edu/linear/ch6/green.htm)进行分析。

1.  **莱斯利矩阵模型。** 哥伦比亚河流域的大西洋鲑鱼（Kareiva 等人，2002）

    ```
    eggs per yearling 4
    eggs per 2 year old 20 
    eggs per 3 year old 60

    survival rate of eggs = 0.005
    yearling survival  0.3
    2 year old survival 0.6

    0    4   20   60
    0.05 0    0    0
    0    0.3  0    0
    0    0    0.6  0

    ```

    主特征值 = 人口增长率 = 0.93（每年减少 7%）。稳态分布。

1.  **最大基数匹配。** 给定一个双分图 G，每一边有 N 个顶点，找到最大基数匹配。形成 N×N 邻接矩阵。如果 i 和 j 之间有一条边，将 i-j 的条目设置为 0 到 2N 之间的随机数。如果行列式非零，则 G 有一个完美匹配。如果行列式为零，则至少有 1/2 的概率 G 没有完美匹配。重复以获得更好的误差容限。相同的思路来获得最大基数，但使用 rank(G)。注意：有更快的算法用于使用图找到完美匹配，但这个算法可以有效地并行化。

1.  **最大基数匹配。** 重新做前面的练习，但为了避免溢出，将所有计算模 p，其中 p 是介于 N 和 2N 之间的素数。

1.  **最大基数匹配。** 设计一个算法来找到完美匹配（如果存在）。

1.  **从 s 到 t 的路径数。** 给定一个无向图 G，计算从 s 到 t 的路径数。查看邻接矩阵 G 的 k 次幂。注意路径不一定是简单的。

1.  **查找图的所有单纯顶点。** 给定一个无向图 G，*单纯顶点* 是一个顶点 v，如果你取任意两个它的邻居 x 和 y，那么 x 和 y 之间就有一条边。在时间复杂度小于 N³ 的情况下找到图中所有的单纯顶点。*提示*：计算 N×N 顶点邻接矩阵 A，其中 A[vw] = 1 表示 v 和 w 之间有一条边或者 v = w，否则为 0。事实：一个顶点是单纯的当且仅当对于所有与 v 相邻的顶点 w，(A²)[vv] = (A²)[vw]。使用快速矩阵乘法计算 A²。

1.  **计算有向图中三角形的数量。** 给定一个有向图 G，*三角形* 是三个顶点 x、y 和 z，使得存在一个有向循环 x->y->z->x 或 x->z->y->x。给定一个具有 N 个顶点的图，编写一个程序在时间复杂度小于 N³ 的情况下打印出所有的三角形。*提示*：计算 N×N 顶点邻接矩阵 A，其中 A[vw] = 1 表示从 v 到 w 有一条边，否则为 0（包括 v = w 的情况）。然后 (A²)[vw] 表示从 v 到 w 通过恰好一个其他中间顶点的路径数。只有当 (A²)[xz] > 0 且 A[zx] = 1 时，存在三角形 x->y->z。

1.  **数值秩。** *数值秩* 是非零奇异值的数量。使用奇异值分解（SVD）进行计算。

1.  **条件数。** *条件数* κ 是最大奇异值与最小奇异值的比值。最初由 Alan Turing 提出！对于方阵，它衡量矩阵接近奇异的程度。对于矩形矩阵，它衡量矩阵接近秩不足的程度。它还有助于限制如果我们对 Ax = b 进行微小扰动，解可以改变多少。如果条件数非常大，那么当我们解 Ax = b 时就不会得到非常准确的结果。粗略地说，解的精度位数等于输入精度位数减去 log[2]κ。

    这是一个特别病态的 4×4 矩阵，其条件数约为 10⁶⁵。这意味着在不到 65 位小数精度的情况下，我们不能期望在答案中有任何有效数字。[参考：S.M. Rump. A Class of Arbitrarily Ill-conditioned Floating-Point Matrices. SIAM Journal on Matrix Analysis and Applications (SIMAX), 12(4):645-653, 1991.]

    ```
     -5046135670319638   -3871391041510136 -5206336348183639   -6745986988231149
      -640032173419322    8694411469684959  -564323984386760   -2807912511823001
    -16935782447203334  -18752427538303772 -8188807358110413  -14820968618548534
     -1069537498856711  -14079150289610606  7074216604373039    7257960283978710

    ```

1.  **对称正定。** 一个 N×N 矩阵 A 是*对称正定*的，如果它是对称的且对于所有 x ≠ 0 都有 x^TAx > 0（等价地，所有特征值都是正的）。对称正定矩阵在统计学中作为协方差矩阵，在有限元方法中作为刚度矩阵，在线性回归的正规方程中出现。编写一个程序来测试一个矩阵是否是对称正定的。提示：在高斯消元中所有主元都是正的（且没有行交换）。

1.  **Cholesky 分解。** 编写一个程序 Cholesky.java 来计算对称正定矩阵的[Cholesky 分解](http://en.wikipedia.org/wiki/Cholesky_decomposition)：A = LL^T。使用 Cholesky-Banachiewicz 算法。

    ```
    for (int i = 0; i < N; i++)  {
       for (int j = 0; j <= i; j++) {
          double sum = 0.0;
          for (int k = 0; k < j; k++) {
             sum += L[i][k] * L[j][k];
          }
          if (i == j) L[i][i] = Math.sqrt(A[i][i] - sum);
          else        L[i][j] = 1.0 / L[j][j] * (A[i][j] - sum)
       }
    }

    ```

1.  **多维缩放。** 仅根据点间距离重建相对点位置。解决基本问题的技术用于在地球表面上绘制美国的三维地图等。在二维平面上给定 N 个点，定义一个 N×N 矩阵 A，使得 A[ij]是点 i 和点 j 之间的欧几里德距离。找到一个*等距嵌入*，即满足这些距离的一组点。*提示*：让 I 为 N×N 单位矩阵，让 B 为 N×N 的平方成对距离矩阵，让 u 为全 1 的 N×1 向量，B 为 n 个点之间的平方距离矩阵，并且让 C = (-1/2)(I - uu^T/N) * B * (I - uu^T/N)。如果点位于 m 维空间中，则 C 是正半定的并且秩为 m。让 C = LL^T 为 C 的 Cholesky 分解。然后 L 包含点的坐标。

1.  **压缩列存储。** *压缩列存储*（又称 Harwell-Boeing 存储）与*压缩行存储*完全类似，只是列按顺序存储。在使用 CCS 时实现矩阵-向量乘法。*提示*：使用 CCS 存储 A 与使用 CRS 存储 A^T 是相同的。

1.  **稀疏带矩阵。** 使用[压缩对角线存储](http://www.cs.utk.edu/~dongarra/etemplates/node376.html)来表示*带状矩阵*。高效实现矩阵-向量乘法。

1.  **多项式的根。** 给定多项式 a[n]x^n + ... + a[1]x + a[0]，我们可以通过找到*伴随矩阵*的特征值来计算其根。

    > ![伴随矩阵](img/8d8deb1054e9d4a7f9f454398f93990f.png)

    不稳定数值，因此不能保证可靠工作。

1.  **多项式的实根。** 编写一个程序`RouthHurwitz.java`，其输入为多项式 a[0] + a[1]x¹ + ... + a[n]x^N 的正实系数，并确定多项式的所有零点是否具有负实部。这是控制理论中的经典问题，可用于确定线性系统是否稳定（如果每个根的实部为负，则它是稳定的；否则不稳定）。根据著名的[Routh-Hurwitz 稳定性判据](http://mathworld.wolfram.com/Routh-HurwitzTheorem.html)，如果以下 N×N 矩阵的所有主子行列式严格为正，则为真。

    > ![Routh-Hurwitz](img/628a47204f791bc8bbb41c7c88d51ca4.png)

    按照惯例，如果 m < 0 或 m > n，则 a[m] = 0。

    *解决方案*：计算所有子行列式，运行不进行主元交换的高斯消元 - 如果遇到任何零或负主元，答案为否。我们可以像前面的练习一样计算特征值，但可以在不显式计算根的情况下完成。

1.  **图的连通性。** 给定无向图 A(G)的邻接矩阵，最大特征值（lambda = 1）的重数等于 G 中连通分量的数量。如果-1 是 A(G)的特征值，则 G 是二部图。
