- en: 9.7   Data Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7   数据分析
- en: 原文：[https://introcs.cs.princeton.edu/java/97data](https://introcs.cs.princeton.edu/java/97data)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/97data](https://introcs.cs.princeton.edu/java/97data)
- en: This section under major construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在大规模施工中。
- en: '**Normal distribution.** Sum of a bunch of random coin flips.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**正态分布。** 一堆随机硬币翻转的总和。'
- en: '**Random sampling.** Physical measurement of some unknown constant, e.g., gravitational
    constant. There is some error associated with each measurement, so we get slightly
    different results each time. Our goal is to estimate the unknown quantity as accurately
    and precisely as possible. The sample mean and sample variance are defined as:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机抽样。** 对某些未知常数进行物理测量，例如，重力常数。每次测量都会有一定的误差，因此我们每次都会得到略有不同的结果。我们的目标是尽可能准确和精确地估计未知数量。样本均值和样本方差定义如下：'
- en: '![sampling](../Images/4c55529205ac92bf13882c258c007273.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![抽样](../Images/4c55529205ac92bf13882c258c007273.png)'
- en: The sample mean estimates the unknown constant, and the sample variance measures
    how precise the estimate is. Under quite general conditions, as n gets large,
    the sample mean obeys a normal distribution with mean equal to the unknown constant
    and variance equal to the the sample variance. The 95% approximate confidence
    interval is
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 样本均值估计未知常数，样本方差衡量估计的精确性。在相当一般的条件下，当 n 变大时，样本均值服从均值为未知常数，方差为样本方差的正态分布。95% 的近似置信区间为
- en: '![Confidence interval](../Images/60606007f7470e2767d784bd868c9bd3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![置信区间](../Images/60606007f7470e2767d784bd868c9bd3.png)'
- en: The confidence interval measures the uncertainty assoicated with our estimate
    of the unknown constant. It means that if we perform the same experiment many
    times, we would expect that 95% of the time the estimated mean would lie in the
    given interval. The number 1.96 occurs because the probability that a normal random
    variable is between -1.96 and 1.96 happen to be 95%. If we want a 90% or 99% confidence
    interval, substitute 1.645 or 2.575, respectively. The confidence interval above
    is not exact. It is approximate because we are estimating the standard deviation.
    In n is small (say less than 50), we should use the exact 95% confidence interval
    with the Student's T distribution with n-1 degrees of freedom. For example, if
    there are n = 25 samples, then we should use 2.06 instead of 1.96. These numbers
    can be computed using [or124.jar](http://opsresearch.com/cgi-bin/freeware.cgi/or124.jar)
    which contains the [OR-Objects library](http://opsresearch.com/OR-Objects/api/drasys/or/prob/package-summary.html).
    Program [ProbDemo.java](ProbDemo.java.html) illustrates how to use it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 置信区间衡量了我们对未知常数估计的不确定性。这意味着如果我们多次执行相同的实验，我们预计估计的均值会在给定的区间内出现的概率为 95%。数字 1.96
    出现是因为正态随机变量在 -1.96 和 1.96 之间的概率恰好为 95%。如果我们想要 90% 或 99% 的置信区间，分别替换为 1.645 或 2.575。上述置信区间并非精确。这是因为我们正在估计标准差。如果
    n 较小（比如小于 50），我们应该使用具有 n-1 自由度的学生 t 分布的精确 95% 置信区间。例如，如果有 n = 25 个样本，则我们应该使用 2.06
    而不是 1.96。这些数字可以使用 [or124.jar](http://opsresearch.com/cgi-bin/freeware.cgi/or124.jar)
    计算，其中包含 [OR-Objects library](http://opsresearch.com/OR-Objects/api/drasys/or/prob/package-summary.html)。程序
    [ProbDemo.java](ProbDemo.java.html) 演示了如何使用它。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Implemenation.* Program [Average.java](Average.java.html) is a straightforward
    implementation of the formulas above. This formula involves two passes through
    the data: one to compute the sample mean, and one to compute the sample variance.
    Thus, we store the data in an array. This appears wasteful since we could compute
    both in one pass using the alternate textbook formula for the sample variance.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*实现.* 程序 [Average.java](Average.java.html) 是上述公式的��接实现。这个公式涉及对数据的两次遍历：一次计算样本均值，一次计算样本方差。因此，我们将数据存储在一个数组中。这看起来有些浪费，因为我们可以使用备用的样本方差的教科书公式一次计算两者。'
- en: '![one pass algorithm](../Images/88f00a6cc3184bdb1a7d7931e33f8a5d.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![单次算法](../Images/88f00a6cc3184bdb1a7d7931e33f8a5d.png)'
- en: We avoid this one-pass approach because it is numerically unstable. (See Exercise
    XYZ and XYZ.) This instability is most pronounced when the data has small variance
    but a large number of significant digits. In fact, it can cause the program to
    take the square root of a negative number! (See Exercise XYZ.) This subtlety surprises
    many uninitiated programmers. In fact, it even surprises some very experienced
    ones. Microsoft Excel versions 1.0 through 2002 implement the unstable one-pass
    algorithm in over a dozen of their statistical library functions. As a result,
    you may experience inaccurate results with no warning. [These bugs were fixed](http://support.microsoft.com/default.aspx?kbid=826393)
    with the release of Excel 2003.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免使用这种单次算法，因为它在数值上是不稳定的。（参见练习 XYZ 和 XYZ。）当数据方差较小但有效数字位数较多时，这种不稳定性最为明显。事实上，它可能导致程序对负数进行平方根运算！（参见练习
    XYZ。）这种微妙之处会让许多未经培训的程序员感到惊讶。事实上，甚至有些经验丰富的程序员也会感到惊讶。微软 Excel 版本 1.0 到 2002 实现了不稳定的单次算法在超过十几个统计库函数中。因此，您可能会在没有警告的情况下遇到不准确的结果。[这些错误已经在
    Excel 2003 发布时得到修复](http://support.microsoft.com/default.aspx?kbid=826393)。
- en: '*Confidence intervals.* Temperature in January vs. July.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*置信区间.* 一月与七月的温度。'
- en: '*Survey sampling.* Census survey, temperature readings, election exit polls,
    quality control in manufacturing processes, auditing financial records, epidemiology,
    etc. Generally, newspapers report the result of some poll as something like 47%
    ± 3%. What does this really mean? Typically a 95% confidence interval is implicitly
    assumed. We assume the population consists of N elements, and we take a sample
    of size n, and sample i has an associated real value x[i], which could represent
    weight or age. It could also represent 0 or 1 to denote whether some characteristic
    is present or absent (e.g., plan to vote for Kerry). The techniques from random
    sampling apply, except that we need to make a correction for the finite population
    size.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*调查抽样。* 人口普查调查、温度读数、选举出口民意调查、制造过程的质量控制、审计财务记录、流行病学等。通常，报纸会将某项调查的结果报告为类似于47%
    ± 3%。这到底意味着什么？通常隐含地假定为95%的置信区间。我们假设人口由N个元素组成，我们抽取大小为n的样本，样本i有一个关联的实际值x[i]，它可以代表重量或年龄。它也可以表示0或1来表示某种特征是否存在或不存在（例如，计划投票给Kerry）。随机抽样的技术适用，只是我们需要对有限人口规模进行修正。'
- en: '![sample from finite population](../Images/395fb6eaf287d2d58b23efad8c83e2d3.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![有限人口的样本](../Images/395fb6eaf287d2d58b23efad8c83e2d3.png)'
- en: When N is large relative to n (only a small fraction of the population is sampled),
    the finite population effects can be ignored.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当N相对于n很大（只抽取了人口的一小部分）时，可以忽略有限人口效应。
- en: '*Histogram.* Program `Histogram.java` dynamically displays histogram as the
    data is accumulated.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*直方图。* 程序`Histogram.java`在数据累积时动态显示直方图。'
- en: '[data sets](http://www.oswego.edu/~kane/econometrics/data.htm)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[数据集](http://www.oswego.edu/~kane/econometrics/data.htm)'
- en: '**Simple linear regression.** In 1800 Giuseppe Piazzi discovered what appeared
    to be a new star and tracked its movement for 41 days before losing track of it
    due to bad weather. He was amazed since it moved in the opposite direction of
    the other stars. Carl Frederick Gauss used his newly invented method of least
    squares to predict where to find the star. Gauss became famous after the the star
    was located according to his prediction. As it turns out, the celestial body was
    an asteroid, the first one ever discovered. Now, the method of least squares is
    applied in many disciplines from psychology to epidemiology to physics. Gauss''
    famous computation involved predicting the location of an object using 6 variables.
    We first consider [simple linear regression](http://www.wikipedia.org/wiki/Linear_regression)
    which involves only a single predictor variable x, and we model the response y
    = &beta[0] + β[1]x. Given a sequence of n pairs of real numbers (x[i], y[i]),
    we define the residual at x[i] to be r[i] = (y[i] - β[0] - β[1]x[i]). The goal
    is to estimate values for the unobserved parameters β[0] and β[1] to make the
    residuals as small as possible. The method of least squares is to choose the parameters
    to minimize the sum of the squares of the residuals. Using elementary calculus,
    we can obtain the classic least squares estimates:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单线性回归。** 1800年，朱塞佩·皮亚齐发现了一个看似新星，并在41天内追踪了它的运动，然后由于恶劣天气而失去了踪迹。他感到惊讶，因为它的运动方向与其他星星相反。卡尔·弗里德里希·高斯利用他新发明的最小二乘法预测了星星的位置。高斯因根据他的预测找到了这颗星星而变得著名。事实证明，这颗天体是一颗小行星，是有史以来发现的第一颗小行星。现在，最小二乘法在许多学科中应用，从心理学到流行病学再到物理学。高斯的著名计算涉及使用6个变量预测物体的位置。我们首先考虑[简单线性回归](http://www.wikipedia.org/wiki/Linear_regression)，它只涉及一个预测变量x，并且我们对响应建模y
    = &beta[0] + β[1]x。给定一系列n对实数(x[i], y[i])，我们定义x[i]处的残差为r[i] = (y[i] - β[0] - β[1]x[i])。目标是估计未观察到的参数β[0]和β[1]的值，使得残差尽可能小。最小二乘法是选择参数使残差的平方和最小化。使用基本微积分，我们可以得到经典的最小二乘估计：'
- en: '![Simple linear regression](../Images/404911bdf6e1d92c96b786c3ee6ef1db.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![简单线性回归](../Images/404911bdf6e1d92c96b786c3ee6ef1db.png)'
- en: Program [LinearRegression.java](LinearRegression.java.html) reads in n measurements
    from standard input, plots them, and computes the line that best fits the data
    according to the least squares metric.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[LinearRegression.java](LinearRegression.java.html)从标准输入读取n个测量值，绘制它们，并根据最小二乘度量计算最适合数据的直线。
- en: '**Assessing the fitted solution.** To measure the goodness of fit, we can compute
    the coefficient of determination R², which measure the fraction of variability
    in the data that can be explained by the variable x.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**评估拟合解。** 为了衡量拟合的好坏，我们可以计算决定系数R²，它衡量数据中可以由变量x解释的变异性的比例。'
- en: '![Correlation coefficient](../Images/6303806546bcf5fd3ce4c4437bb56026.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![相关系数](../Images/6303806546bcf5fd3ce4c4437bb56026.png)'
- en: We can also estimate the standard error, the standard error of the regression
    estimate for β[0] and β[1], and the 95% approximate confidence interval for the
    two unknown coefficients are.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以估计标准误差，β[0]和β[1]的回归估计的标准误差，以及两个未知系数的95%近似置信区间。
- en: '![standard error](../Images/afdc07d32c016d10b24fb7f77ed8fee7.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![标准误差](../Images/afdc07d32c016d10b24fb7f77ed8fee7.png)'
- en: '*Running time of algorithms.* Take log of both sides. The slope is the exponent,
    the intercept is the constant.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法的运行时间。* 对两边取对数。斜率是指数，截距是常数。'
- en: Plot latitude vs. January temperature. Draw points within 2 standard deviations
    in black, between 2 and 3 in blue, above 3 in green. 18 of 19 outliers are in
    California or Oregon. The other is in Gunnison County, Colorado which is at very
    high altitude. Perhaps need to incorporate longitude and alititude into model...
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制纬度与一月温度的关系。在2个标准偏差内的点用黑色表示，在2到3之间用蓝色表示，在3以上用绿色表示。19个异常值中有18个在加利福尼亚州或俄勒冈州。另一个在科罗拉多州冈尼森县，那里的海拔非常高。也许需要将经度和海拔高度纳入模型中...
- en: '**Test for normality.**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**正态性检验。**'
- en: '**Multiple linear regression.** Multiple linear regression generalizes simple
    linear regression by allowing several predictor variables instead of just one.
    We model the response y = β[0] + β[1]x[1] + ... + β[p]x[p]. Now, we have a sequence
    of n response values y[i], and a sequence of n predictor *vectors* (x[i1], x[i2],
    ..., x[ip]). The goal is to estimate the parameter vector (β[0], ..., β[p]) so
    as to minimize the sum of the squared errors. In matrix notation, we have an overdetermined
    system of equations y = Xβ.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**多元线性回归。** 多元线性回归通过允许多个预测变量而不仅仅是一个来推广简单线性回归。我们对响应 y = β[0] + β[1]x[1] + ...
    + β[p]x[p] 进行建模。现在，我们有一系列 n 个响应值 y[i]，以及一系列 n 个预测 *向量*（x[i1]，x[i2]，...，x[ip]）。目标是估计参数向量（β[0]，...，β[p]），以使平方误差的总和最小化。在矩阵表示中，我们有一个过度确定的方程组
    y = Xβ。'
- en: '![Multiple linear regression](../Images/e55ead4059086e58bbaabd338285fd07.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![多元线性回归](../Images/e55ead4059086e58bbaabd338285fd07.png)'
- en: Our goal is to find a vector β that minimizes ||X^(β - y||. Assuming X has full
    column rank, we can compute β by solving the *normal equations* X^TXβ = X^Ty to
    compute our estimate of β. The simplest way to solve the normal equations is to
    explicitly compute A = X^TX and b = X^Ty and solve the system of equations Ax
    = b using Gaussian elimination. A numerically stable algorithm for computing β
    is to compute QR factorization X = QR, then solve the triangular system Rβ = Q^Ty
    via back substitution. This is exactly what Jama's `solve` method does when presented
    with an overdetermined system (assumes matrix has full column rank). Program [MultipleLinearRegression.java](MultipleLinearRegression.java.html)
    is a straightforward implementation of this approach. See Exercise XYZ for an
    SVD-based method that works even if the system does not have full column rank).)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一个最小化 ||X^(β - y|| 的向量 β。假设 X 具有完整的列秩，我们可以通过解决 *正规方程* X^TXβ = X^Ty 来计算
    β 的估计值。解决正规方程的最简单方法是显式计算 A = X^TX 和 b = X^Ty，并使用高斯消元法解方程组 Ax = b。计算 β 的一个数值稳定的算法是计算
    QR 分解 X = QR，然后通过回代解三角形系统 Rβ = Q^Ty 来解决。这正是 Jama 的 `solve` 方法在面对一个过度确定系统时所做的（假设矩阵具有完整的列秩）。程序[MultipleLinearRegression.java](MultipleLinearRegression.java.html)是这种方法的一个直接实现。参见练习
    XYZ，其中介绍了一种基于 SVD 的方法，即使系统没有完整的列秩也可以工作。)
- en: '**An example.** Weather data set and examples from this [reference](http://www.stat.lsa.umich.edu/~kshedden/Courses/Stat401/Notes/401-multreg.pdf).
    Averag maximum daily temperatures at n = 1070 weather stations in US during March,
    2001 Predictors = latitude (X1), longitude (X2), and elevation (X3). Model Y =
    101 - 2 X1 + 0.3 X2 - 0.003 X3. Temp increases as longitude increases (west),
    but decreases as latitude increase (north) and alitude increase. Is effect of
    latitude on temperature greater in west or east? Plot scatterplot of temperature
    vs. latitude (divide at median longitude of 93 degrees) for March. Plot residuals
    vs. fitted values. Should not show any pattern.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个例子。** 天气数据集和来自这个[参考资料](http://www.stat.lsa.umich.edu/~kshedden/Courses/Stat401/Notes/401-multreg.pdf)的例子。2001年3月，美国1070个气象站的平均最高日温度。预测因子
    = 纬度（X1）、经度（X2）和海拔（X3）。模型 Y = 101 - 2 X1 + 0.3 X2 - 0.003 X3。随着经度增加（向西），温度增加，但随着纬度增加（向北）和海拔增加，温度降低。纬度对温度的影响在西部和东部哪个更大？绘制3月份温度与纬度的散点图（以93度为中位数的经度分割）。绘制残差与拟合值的图。不应显示任何模式。'
- en: '**Assesing the model.** The error variance s² is the sum of the squared error
    divided by the degrees of freedom (n - p - 1). The diagonal entries of the standard
    variance matrix is σ²(X^TX)^(-1) estimate the variance of the parameter estimates.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**评估模型。** 误差方差 s² 是平方误差之和除以自由度（n - p - 1）。标准方差矩阵的对角线条目是 σ²(X^TX)^(-1) 估计参数估计的方差。'
- en: '![Multiple linear regression](../Images/fca82c52488c54f459bd9c267ef227a4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![多元线性回归](../Images/fca82c52488c54f459bd9c267ef227a4.png)'
- en: '**Polynomial regression.** predictor variables instead of just one. We model
    the response y = β[0] + β[1]x¹ + ... + β[p]x^p. [PolynomialRegression.java](PolynomialRegression.java.html)
    is a data type for performing polynomial regression.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**多项式回归。** 预测变量不只是一个。我们对响应 y = β[0] + β[1]x¹ + ... + β[p]x^p 进行建模。[PolynomialRegression.java](PolynomialRegression.java.html)
    是执行多项式回归的数据类型。'
- en: Discrete Fourier transform.
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离散傅立叶变换。
- en: The discovery of efficient algorithms can have a profound social and cultural
    impact. The discrete Fourier transform is a method for decomposing a waveform
    of N samples (e.g., sound) into periodic components. The brute force solution
    takes time proportional to N². At the age of 27, Freidrich Gauss proposed a method
    that requires only N log N steps, and he used it to analyze the periodic motion
    of the asteroid Ceres. This method was later rediscovered and popularized by Cooley
    and Tukey in 1965 after they described how to efficiently implement it on a digital
    computer. Their motivation was monitoring nuclear tests in the Soviet Union and
    tracking Soviet submarines. The FFT has become a cornerstone of signal processing,
    and is a crucial component of devices like DVD players, cell phones, and disk
    drives. It is also forms the foundation of many popular data formats including
    JPEG, MP3, and DivX. Also speech analysis, music synthesis, image processing.
    Doctors routinely use the FFT for medical imaging, including Magnetic Resonance
    Imaging (MRI), Magnetic Resonance Spectroscopy (MRS), Computer Assisted Tomography
    (CAT scans). Another important application is fast solutions to partial differential
    equations with periodic boundary conditions, most notably Poisson's equation and
    the nonlinear Schroedinger equation. Also used to simulate fractional Brownian
    motion. Without a fast way to solve to compute the DFT none of this would be possible.
    Charles van Loan writes "The FFT is one of the truly great computational developments
    of this [20th] century. It has changed the face of science and engineering so
    much that it is not an exaggeration to say that *life as we know it would be very
    different without the FFT.*"
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 发现高效算法可以产生深远的社会和文化影响。离散傅立叶变换是一种将N个样本（例如声音）的波形分解为周期分量的方法。暴力解决方案的时间复杂度与N²成正比。27岁时，高斯提出了一种仅需N
    log N步的方法，并用它来分析小行星谷神星的周期运动。这种方法后来被库利和图基在1965年重新发现并推广，他们描述了如何在数字计算机上高效实现它。他们的动机是监视苏联的核试验和跟踪苏联潜艇。快速傅立叶变换已成为信号处理的基石，并是DVD播放器、手机和磁盘驱动器等设备的关键组件。它还构成许多流行数据格式的基础，包括JPEG、MP3和DivX。还有语音分析、音乐合成、图像处理。医生们经常在医学成像中使用快速傅立叶变换，包括磁共振成像（MRI）、磁共振光谱（MRS）、计算机辅助断层扫描（CAT扫描）。另一个重要应用是快速解决具有周期边界条件的偏微分方程，尤其是泊松方程和非线性薛定谔方程。还用于模拟分数布朗运动。如果没有快速计算DFT的方��，这一切都将不可能。查尔斯·范·洛恩写道：“快速傅立叶变换是本世纪真正伟大的计算发展之一。它已经改变了科学和工程的面貌，可以毫不夸张地说，*没有快速傅立叶变换，我们所知道的生活将会截然不同*。”
- en: '*Fourier analysis* is a methodology for approximating a function (signal) by
    a sum of sinusoidals (complex exponentials), each at a diffferent frequency. When
    using computers, we also assume that the the continuous function is approximated
    by a finite number points, sampled over a regular interval. Sinusoids play a crucial
    role in physics for describing oscillating systems, including simple harmonic
    motion. The human ear is a Fourier analyzer for sound. Roughly speaking, human
    hearing works by splitting a sound wave into sinusoidal components. Each frequency
    resonates at a different position in the basilar membrane, and these signals are
    delivered to the brain along the auditory nerve. One of the main applications
    of the DFT is to identify periodicities in data and their relative strengths,
    e.g., filtering out high frequency noise in acoustic data, isolating diurnal and
    annual cycles in weather, analyzing astronomical data, performing atmospheric
    imaging, and identifying seasonal trends in economic data.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*傅立叶分析*是一种通过不同频率的正弦波（复指数）的和来近似函数（信号）的方法。在使用计算机时，我们还假设连续函数由在规则间隔上采样的有限数量点来近似。正弦波在物理学中起着至关重要的作用，用于描述振荡系统，包括简谐运动。人耳是声音的傅立叶分析器。粗略地说，人类听觉通过将声波分解为正弦分量来工作。每个频率在耳蜗膜中的不同位置共振，并将这些信号沿听神经传递到大脑。DFT的主要应用之一是识别数据中的周期性及其相对强度，例如在声学数据中滤除高频噪声，分离天气中的昼夜和年度循环，分析天文数据，执行大气成像，并识别经济数据中的季节性趋势。'
- en: The *discrete Fourier transform* (DFT) of a length N complex vector x is defined
    by
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为N的复向量x的*离散傅立叶变换*（DFT）定义为
- en: '![Discrete Fourier transform](../Images/7d58ef322d6a010e7a01597575b23033.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![离散傅立叶变换](../Images/7d58ef322d6a010e7a01597575b23033.png)'
- en: where i is the square root of -1 and ω = e^(-2iπ/N) is a principal Nth root
    of unity. We can also interpret the DFT as the matrix-vector product y = F[N]
    x, where F[N] is the N-by-N matrix whose jth row and kth column is ω^(jk). For
    example, when N = 4,
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其中i是-1的平方根，ω = e^(-2iπ/N)是主N次单位根。我们还可以将DFT解释为矩阵-向量乘积y = F[N] x，其中F[N]是N×N矩阵，其第j行第k列为ω^(jk)。例如，当N
    = 4时，
- en: '![DFT example](../Images/a0c10af275598f0f11be4dc0e30d5c90.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![DFT示例](../Images/a0c10af275598f0f11be4dc0e30d5c90.png)'
- en: 'We note that some authors define the Fourier matrix to be the conjugate of
    our Fourier matrix and normalize it by the factor 1 / sqrt(N) to make it unitary.
    Intuition: let x[i] be the samples of a signal over a time interval from 0 to
    T, and let f[i] be the DFT. Then f[0] / n is an approximation of the average value
    of the signal over the interval. The modulus (absolute value) and argument (angle)
    of the complex number f[j] represent (one half) the amplitude and the phase of
    the signal component having frequency j / T for j = 1 to n/2 - 1.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到一些作者将傅立叶矩阵定义为我们的傅立叶矩阵的共轭，并通过因子1 / sqrt(N)对其进行归一化，使其成为幺正的。直觉：设x[i]为时间间隔从0到T的信号样本，f[i]为DFT。那么f[0]
    / n是信号在该间隔内的平均值的近似值。复数f[j]的模（绝对值）和幅角（角度）表示频率为j / T的信号分量的振幅和相位（一半）。
- en: '*Fast Fourier transform.* It is straightforward to compute the DFT of a N-length
    vector either directly from the definition or via a dense matrix-vector multiplication.
    Both approaches take quadratic time. The Fast Fourier transform (FFT) is an ingenious
    method that computes the DFT in time proportional to N log N. It works by exploiting
    the symmetry of the Fourier matrix F. The crucial idea is to use properties of
    the nth roots of unity to relate the Fourier transform of a vector of size n to
    two Fourier transforms on vectors of size n/2.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速傅里叶变换。* 直接从定义或通过密集矩阵-向量乘法计算N长度向量的DFT是直截了当的。这两种方法都需要二次时间。快速傅里叶变换（FFT）是一种巧妙的方法，它以与N
    log N成比例的时间计算DFT。它通过利用傅里叶矩阵F的对称性来工作。关键思想是利用n次单位根的性质将大小为n的向量的傅里叶变换与大小为n/2的两个向量上的两个傅里叶变换相关联。'
- en: '![FFT](../Images/c1b6acd72769defb470f78d6199f4d73.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![FFT](../Images/c1b6acd72769defb470f78d6199f4d73.png)'
- en: 'where x[even] denotes the vector of size n/2 consisting of x[0], x[2], ...,
    x[n-2] and x[odd] denote the vector consisting of x[1], x[3], ..., x[n-1], the
    matrix I[n/2] is the n/2-by-n/2 identity matrix and the matrix D[n/2] is the diagonal
    matrix whose kth diagonal entry is ω^k. The *radix 2 Cooley-Tukey FFT* uses this
    recursive formula to compute the DFT in a divide-and-conquer style framework.
    Note that we have implicitly assumed that N is a power of 2. Program [FFT.java](FFT.java.html)
    is a bare bones implementation of this scheme. It relies on the [Complex.java](Complex.java.html)
    ADT developed in Section xyz. Program [InplaceFFT.java](InplaceFFT.java.html)
    is an *in-place* variant: it uses only O(1) extra memory.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其中x[even]表示大小为n/2的向量，由x[0]、x[2]、...、x[n-2]组成，x[odd]表示由x[1]、x[3]、...、x[n-1]组成的向量，矩阵I[n/2]是n/2乘n/2的单位矩阵，矩阵D[n/2]是对角线条目为ω^k的对角矩阵。*基数2
    Cooley-Tukey FFT* 使用这个递归公式以分治风格的框架计算DFT。请注意，我们隐含地假设N是2的幂。程序[FFT.java](FFT.java.html)是这个方案的基本实现。它依赖于在第xyz节中开发的[Complex.java](Complex.java.html)
    ADT。程序[InplaceFFT.java](InplaceFFT.java.html)是*原位*变体：它只使用O(1)额外内存。
- en: '**Inverse FFT.** The *inverse DFT* is defined as: The inverse of F[N] is the
    complex conjugate of itself, scaled down by a factor of N. Thus, to compute the
    inverse DFT of x: compute the DFT of the conjugate of x, take the conjugate of
    the result, and multiply each value by N.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆FFT。** *逆DFT* 定义为：F[N]的逆是其复共轭，缩小了N倍。因此，要计算x的逆DFT：计算x的共轭的DFT，取结果的共轭，并将每个值乘以N。'
- en: '*Touch tone phones.* *Touch Tone* ® telephones encode key presses as audio
    signals using a system called *dual tone multi frequency* (DTMF). Two audio frequncies
    are associated with each key press according to the table below'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*按键电话。* *触摸音* ® 电话使用称为*双音多频*（DTMF）的系统将按键编码为音频信号。根据下表，每个按键按键与两个音频频率相关联'
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For example, when the key 7 is pressed, the phone generates signals at frequencies
    770 Hz and 1209 Hz, and sums them together. The frequencies should be within 1.5%
    of the proscribed values or the telephone company ignores it. The high frequencies
    must be at least as loud as the low frequency, but can be no more than 3 decibels
    louder.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当按下键7时，电话会在频率为770 Hz和1209 Hz的信号之间发出信号，并将它们相加。频率应该在规定值的1.5%范围内，否则电话公司会忽略它。高频率必须至少与低频率一样响亮，但不能比低频率响亮超过3分贝。
- en: '[notes](http://www.physik.uni-hannover.de/cip/fourier.pdf)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[笔记](http://www.physik.uni-hannover.de/cip/fourier.pdf)'
- en: '[touch tone songs](http://www.twpyhr.com/tttfaq.shtml), [touch tone sounds](http://rl.se/polisradio/dtmf.php)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[按键音乐](http://www.twpyhr.com/tttfaq.shtml)，[按键声音](http://rl.se/polisradio/dtmf.php)'
- en: '*Commercial implementations.* Because the FFTs great importance, there is a
    rich literature of efficient FFT algorithms, and there are many high optimized
    library implementations available (e.g., Matlab and the [Fastest Fourier Transform
    in the West](http://fftw.org)). Our implementation is a bare bones version that
    captures the most salients ideas, but it can be improved in a number of ways.
    For example, commercial implementations works for any N, not just powers of 2.
    If the input is real (instead of complex), they exploit additional symmetry and
    runs faster. They can also handle multidimensional FFTs. Our FFT implementation
    has a much higher memory footprint than required. With great care, it is even
    possible to do the FFT in-place, i.e., with no extra arrays other than x. Commericial
    FFT implementations also use iterative algorithms instead of recursion. This can
    make the code more efficient, but harder to understand. High performance computing
    machines have specialized vector processors, which can perform vector operations
    faster than an equivalent sequence of scalar operations. Although computational
    scientists often measure performance in terms of the number of flops (floating
    point operations), with the FFT, the number of mems (memory accesses) is also
    critical. Commercial FFT algorithms pay special attention to the costs associated
    with moving data around in memory. Parallel FFTs. Implemented in hardware.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*商业实现。* 由于FFT的重要性，有许多高效的FFT算法的丰富文献，还有许多高度优化的库实现可用（例如，Matlab和[Fastest Fourier
    Transform in the West](http://fftw.org)）。我们的实现是一个基本版本，捕捉了最显著的思想，但可以通过多种方式改进。例如，商业实现适用于任何N，而不仅仅是2的幂。如果输入是实数（而不是复数），它们会利用额外的对称性并运行得更快。它们还可以处理多维FFT。我们的FFT实现的内存占用比所需的要高得多。经过精心设计，甚至可以在原地执行FFT，即除了x之外不需要额外的数组。商业FFT实现还使用迭代算���而不是递归。这可以使代码更高效，但更难理解。高性能计算机具有专门的矢量处理器，可以比等效的标量操作序列更快地执行矢量操作。尽管计算科学家通常根据浮点操作的数量来衡量性能，但对于FFT来说，内存访问的数量也至关重要。商业FFT算法特别关注在内存中移动数据所带来的成本。并行FFT。在硬件中实现。'
- en: '**Convolution.** The [convolution](http://en.wikipedia.org/wiki/Convolution)
    of two vectors is a third vector which represents an overlap between the two vectors.
    It arises in numerous applications: weighted moving average in statistics, shadows
    in optics, and echos in acoustics. Given two periodic signals a and b of length
    N, the *circular convolution* of a and b is defined by'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**卷积。** 两个向量的[卷积](http://en.wikipedia.org/wiki/Convolution)是表示两个向量之间重叠的第三个向量。它在许多应用中出现：统计学中的加权移动平均、光学中的阴影和声学中的回声。给定长度为N的两个周期信号a和b，a和b的*循环卷积*定义为'
- en: '![Convolution](../Images/07dd64a2d5a1e65f8bce06acb84d0fd5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![卷积](../Images/07dd64a2d5a1e65f8bce06acb84d0fd5.png)'
- en: and we use the notation c = a ⊗ b. The vector b is called the impulse response,
    filter, template, or point spread function. To see the importance of convolution,
    consider two degree N polynomials p(x) and q(x). Observe that the coefficients
    of r(x) = p(x) q(x) are
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用符号c = a ⊗ b。向量b称为脉冲响应、滤波器、模板或点扩散函数。为了看到卷积的重要性，考虑两个N次多项式p(x)和q(x)。观察到r(x)
    = p(x) q(x)的系数为
- en: '![Convolution](../Images/c64b8c199d0abd48b2cccca18fcbe5e4.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![卷积](../Images/c64b8c199d0abd48b2cccca18fcbe5e4.png)'
- en: obtained by convolving the coefficients of p with q, where p and q are padded
    with leading 0s to a length 2N. To facilitate computation, we also may pad with
    additional leading 0s to make its length a power of 2. This simulates the *linear
    convolution* since we don't want periodic boundary conditions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将p和q的系数进行卷积得到，其中p和q在长度为2N的情况下填充了前导0。为了便于计算，我们还可以填充额外的前导0，使其长度成为2的幂。这模拟了*线性卷积*，因为我们不希望周期性边界条件。
- en: A cornerstone result of Fourier analysis is the Convolution Theorem. It says
    that the DFT of a convolution of two vectors is the point-wise product of the
    DFT of the two vectors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶分析的一个基石结果是卷积定理。它表明两个向量卷积的DFT是两个向量的DFT的逐点乘积。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Convolution Theorem is useful because the *inverse DFT* is easy to compute.
    This implies that we can compute the circular convolution (and hence polynomial
    multiplicaton) in N log N steps by taking three separate FFTs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积定理很有用，因为*逆DFT*很容易计算。这意味着我们可以通过进行三次单独的FFT来在N log N步骤中计算循环卷积（从而进行多项式乘法）。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is amazing on two levels. First, it means that we can multiply two real
    (or complex) polynomials substantially faster than brute force. Second, the method
    relies on complex numbers even though multiplying two real polynomials appears
    to have nothing to do with imaginary numbers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这在两个层面上都是令人惊奇的。首先，这意味着我们可以比蛮力更快地相乘两个实（或复）多项式。其次，这种方法依赖于复数，即使相乘两个实多项式似乎与虚数无关。
- en: Matlab supplies a function `conv` that performs a linear convoultion of two
    vectors. However, their implementation takes quadratic time. In many applications,
    the vectors are large, say 1 million entries, and using this library function
    as a black box would be unacceptable. By exploiting our understanding of algorithms
    and complexity we can replace the library solution with an optimized one using
    the FFT!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Matlab提供了一个名为`conv`的函数，用于执行两个向量的线性卷积。然而，他们的实现需要二次时间。在许多应用中，向量很大，比如有100万个条目，使用这个库函数作为黑匣子是不可接受的。通过利用我们对算法和复杂性的理解，我们可以用FFT替换库解决方案，从而得到优化的解决方案！
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we have just witnessed, we can make dramatic performance improvements in
    computing the convolution, by first tranforming the data from the time domain
    to frequency domain. This same principle applies to related problems, including
    cross correlation, autocorrelation, polynomial multiplication, discrete sine and
    cosine transforms. It also means that we have fast matrix-vector multiplication
    algorithms for circulant matrices and Toeplitz matrices, which arise in numerical
    solutions to partial differential equations. f = signal, y = spectrum. f = impulse
    response, y = frequency response.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚见证的，通过首先将数据从时域转换到频域，我们可以在计算卷积时取得显著的性能改进。这个原则也适用于相关问题，包括交叉相关、自相关、多项式乘法、离散正弦和余弦变换。这也意味着我们对循环矩阵和Toeplitz矩阵有快速矩阵-向量乘法算法，这些矩阵出现在偏微分方程的数值解中。f
    = 信号，y = 频谱。f = 脉冲响应，y = 频率响应。
- en: '**2D DFT.** (exercise) Compute a 2D DFT of an N-by-N matrix by taking a DFT
    for each column, then taking a DFT of each row of the resulting values. N² log
    N.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**2D DFT。**（练习）通过对每一列进行DFT，然后对结果值的每一行进行DFT，计算一个N×N矩阵的2D DFT。N² log N。'
- en: 'References: [image compression](http://www.cs.berkeley.edu/~demmel/cs267/lecture24/lecture24.html#link_6),
    [DFT book](http://ccrma.stanford.edu/~jos/r320/)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料：[图像压缩](http://www.cs.berkeley.edu/~demmel/cs267/lecture24/lecture24.html#link_6)，[DFT书籍](http://ccrma.stanford.edu/~jos/r320/)
- en: Q + A
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q + A
- en: Q. Why is it called the Student's T distribution?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Q. 为什么称之为学生T分布？
- en: A. Discovered by an employee of Guinness brewing company named William Gosset
    in 1908, but Guinness did not allow him to publish under his own name, so he used
    "Student."
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: A. 由吉尼斯啤酒公司的一名名叫威廉·高斯特的员工于1908年发现，但吉尼斯不允许他以自己的名义发表，所以他使用了“学生”。
- en: Q. Why minimize the sum of the squared errors instead of the sum of the absolute
    errors or some other measure?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Q. 为什么要最小化平方误差的总和而不是绝对误差的总和或其他度量？
- en: 'A. Short answer: this is what scientists do in pratice. There are also some
    mathematical justifications. The [Gauss-Markov theorem](http://www.wikipedia.org/wiki/Gauss-Markov_theorem)
    says that if you have a linear model in which the errors have zero mean, equal
    variance, and are uncorrelated, then the least squares estimates of a and b (the
    ones that minimize the sum of the squared error) have the smallest variance among
    all unbiased estimates of a and b. If in addition we assume that the errors are
    independent and normally distributed, then we can derive *95% or 99% confidence
    intervals*...'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: A. 简短回答：这是科学家在实践中所做的事情。还有一些数学上的理由。[高斯-马尔可夫定理](http://www.wikipedia.org/wiki/Gauss-Markov_theorem)说，如果你有一个线性模型，其中误差均值为零，方差相等，并且不相关，那么a和b的最小二乘估计（最小化平方误差和的那些）在所有无偏估计中具有最小的方差。如果我们进一步假设误差是独立的并且服从正态分布，那么我们可以推导出*95%或99%的置信区间*...
- en: Q. Where can I get a charting library?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Q. 我在哪里可以获得一个图表库？
- en: A. Check out [JFreeChart](http://www.jfree.org/jfreechart/). Here are [some
    instructions](http://www.javaworld.com/javaworld/jw-12-2002/jw-1227-opensourceprofile.html)
    on using it. Or see the [Scientific Graphics Toolkit](http://www.epic.noaa.gov/java/sgt/index.html)
    for creating interactive, publication quality graphics of scientific data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: A. 查看[JFreeChart](http://www.jfree.org/jfreechart/)。这里有一些关于如何使用它的[说明](http://www.javaworld.com/javaworld/jw-12-2002/jw-1227-opensourceprofile.html)。或者查看[科学图形工具包](http://www.epic.noaa.gov/java/sgt/index.html)，用于创建科学数据的交互式、出版质量的图形。
- en: Exercises
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: '**Baseball statistics..** Do some analysis of [baseball statistics](http://www.baseball1.com/statistics/).'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**棒球统计。** 对[棒球统计](http://www.baseball1.com/statistics/)进行一些分析。'
- en: '**Histogram.** Modify `Histogram.java` so that you do not have to input the
    range ahead of time.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**直方图。** 修改`Histogram.java`，使其无需提前输入范围。'
- en: '**Histogram.** Modify `Histogram.java` so that it has 10 buckets.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**直方图。** 修改`Histogram.java`，使其具有10个桶。'
- en: '**Pie chart.**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**饼图。**'
- en: '**Stem-and-leaf plot.**'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**茎叶图。**'
- en: '**Simple linear regression.** Modify program LinearRegression.java to plot
    and scale the data. Again, we are careful to choose a stable algorithm instead
    of a slightly simpler one-pass alternative.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简单线性回归。** 修改程序LinearRegression.java以绘制和缩放数据。再次，我们要谨慎选择一个稳定的算法，而不是稍微简单的一次遍历替代方案。'
- en: Creative Exercises
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**One-pass algorithm.** Write a program [OnePass.java](OnePass.java.html) that
    computes the sample mean and variance in one pass (instead of two) using the alternate
    textbook formula.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一次遍历算法。** 编写一个程序[OnePass.java](OnePass.java.html)，使用备用教科书公式一次计算样本均值和方差（而不是两次）。'
- en: '[PRE5]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Verify that it is not numerically stable by plugging in n = 3, x[1] = 1000000000,
    x[2] = 1000000001, and x[3] = 1000000002\. The one pass algorithm gives a variance
    of 0, but the true answer is 1. Also, verify that it can lead to taking the square
    root of a negative number by plugging in an input with n = 2, x[1] = 0.5000000000000002
    and x[2] = 0.5000000000000001. Compare with [Average.java](Average.java.html).
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过插入n = 3, x[1] = 1000000000, x[2] = 1000000001和x[3] = 1000000002来验证它在数值上不稳定。一次遍历算法给出方差为0，但真实答案是1。另外，通过插入n
    = 2, x[1] = 0.5000000000000002和x[2] = 0.5000000000000001的输入来验证它可能导致对负数求平方根。与[Average.java](Average.java.html)进行比较。
- en: '**Sample variance.** Implement the following stable, one-pass algorithm for
    computing the sample variance. Verify that the formula is correct.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**样本方差。** 实现以下稳定的一次遍历算法来计算样本方差。验证公式是否正确。'
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Normal quantile plot.** To test whether a given set of data follows a normal
    distribution, create a *normal quantile plot* of the data and check whether the
    points lie on (or close to) a straight line. To create a normal quantile plot,
    sort the N data points. Then plot the ith data point against Φ^(-1)(i / N).'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**正态分位数图。** 为了测试给定数据集是否遵循正态分布，创建一个*正态分位数图*并检查数据点是否位于(或接近)一条直线上。要创建正态分位数图，对N个数据点进行排序。然后将第i个数据点绘制在Φ^(-1)(i
    / N)上。'
- en: '**Diamond 3D graphs.** Write a program to read in a set of three dimensional
    data and plot a [diamond graph](http://www.jhsph.edu/Press_Room/Press_Releases/Munoz_diamond_graph.html)
    of the data like the one below. Diamond graphs have several advantages over 3D
    bar charts.![](../Images/ea0bcda65e0eafaf1ba66614d963e418.png)'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**钻石3D图。** 编写一个程序来读取一组三维数据并绘制类似下面的[钻石图](http://www.jhsph.edu/Press_Room/Press_Releases/Munoz_diamond_graph.html)的数据。钻石图比3D条形图有几个优点！[](../Images/ea0bcda65e0eafaf1ba66614d963e418.png)'
- en: '**Polynomial curve fitting.** Suppose we have a set of N observations (x[i],
    y[i]) and we want to model the data using a low degree polynomial.![Polynomial
    curve fitting](../Images/32e98553c6ee49900703338d9504806a.png)'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多项式曲线拟合。** 假设我们有一组N个观测值(x[i], y[i])，我们想要使用低次多项式对数据进行建模。![多项式曲线拟合](../Images/32e98553c6ee49900703338d9504806a.png)'
- en: 'Empirically collect n samples: (x[i], y[i]). In matrix notation, our least
    squares problem is:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实证收集n个样本：(x[i], y[i])。用矩阵表示，我们的最小二乘问题是：
- en: '![Vandermonde matrix](../Images/ef448d79b63ad09eb4cd7f1d8c2321a3.png)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![范德蒙德矩阵](../Images/ef448d79b63ad09eb4cd7f1d8c2321a3.png)'
- en: The Matrix X is called the *Vandermonde matrix* and has full column rank if
    n ≥ p and the x[i] are distinct. Our problem is a special case of general linear
    regression. The solution vector β are the coefficients of the best fit degree
    p polynomial.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 矩阵X称为*范德蒙德矩阵*，如果n ≥ p且x[i]不同，则具有完整的列秩。我们的问题是一般线性回归的特例。解向量β是最佳拟合度p多项式的系数。
- en: '**Rank deficient linear regression.** Better method: use SVD. Better numerical
    stability properties. Works even if A doesn''t have full rank. Compute the [skinny
    SVD](http://element.stanford.edu/~lall/courses/current/engr207a/svd_2004_01_13_01.pdf):
    A = U[r]Σ[r]V[r]^T. Here r is the rank of A, U[r], Σ[r], and V[r] are the first
    r columns of U, Σ, and V, respectively. The pseduoinverse A^† = U[r](Σ[r])^(-1)V[r]^T
    and the least squares estimate x* = A^†b. The pseudoinverse nicely generalizes
    the matrix inverse: if A is square and invertible then A^† = A^(-1). If A is skinny
    and has full rank then A^† = (A^TA)^(-1)A^T. To compute A^†b, don''t explictly
    form the pseudoinverse. Instead, compute v = V^Tb, w = Σ^(-1)u, x* = Uw. Note
    that Σ^(-1) is easy to compute since Σ is diagonal.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**秩亏线性回归。** 更好的方法：使用SVD。具有更好的数值稳定性特性。即使A没有满秩，也可以工作。计算[瘦SVD](http://element.stanford.edu/~lall/courses/current/engr207a/svd_2004_01_13_01.pdf)：A
    = U[r]Σ[r]V[r]^T。这里r是A的秩，U[r]，Σ[r]和V[r]分别是U，Σ和V的前r列。伪逆A^† = U[r](Σ[r])^(-1)V[r]^T和最小二乘估计x*
    = A^†b。伪逆很好地推广了矩阵的逆：如果A是方阵且可逆，则A^† = A^(-1)。如果A是瘦的且具有满秩，则A^† = (A^TA)^(-1)A^T。要计算A^†b，不要显式形成伪逆。相反，计算v
    = V^Tb，w = Σ^(-1)u，x* = Uw。注意Σ^(-1)易于计算，因为Σ是对角线的。'
- en: In Matlab, `pinv(A)` gives pseudoinverse and `svd(A, 0)` gives thin SVD for
    skinny matrices (but not fat ones!)
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Matlab中，`pinv(A)`给出伪逆，`svd(A, 0)`给出瘦SVD用于瘦矩阵（但不适用于胖矩阵！）
- en: '**Underdetermined system.** In data fitting applications, the system of equations
    is typically overdetermined and A is skinny. In control systems, we have have
    an underdetermined system of equations and the goal is to find an x* that solves
    Ax* = b such that the norm of x* is minimized. Again, the SVD comes to the rescue.
    If A has full column rank, then A^†b is such a solution.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**欠定系统。** 在数据拟合应用中，方程组通常是过度确定的且A是瘦的。在控制系统中，我们有一个欠定的方程组，目标是找到一个解Ax* = b，使得x*的范数最小化。同样，SVD拯救了我们。如果A具有完整的列秩，则A^†b就是这样一个解。'
- en: '**Polynomial multiplication.** Give two polynomials of degree m and n, describe
    how to compute their product in time O(m log n).'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多项式乘法。** 给定两个分别为m和n次的多项式，描述如何在O(m log n)的时间内计算它们的乘积。'
- en: '**Clustering.** Evolutionary trees in biology, marketing research in business,
    classifying painters and musicians in liberal arts, classifying survey responses
    in sociology, [reference: Guy Bleloch]'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚类。** 生物学中的进化树，商业中的市场研究，文理学中的画家和音乐家分类，社会学中的调查响应分类，[参考：盖伊·布洛克]'
