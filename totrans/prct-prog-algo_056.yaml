- en: 9.7   Data Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/java/97data](https://introcs.cs.princeton.edu/java/97data)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section under major construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal distribution.** Sum of a bunch of random coin flips.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**Random sampling.** Physical measurement of some unknown constant, e.g., gravitational
    constant. There is some error associated with each measurement, so we get slightly
    different results each time. Our goal is to estimate the unknown quantity as accurately
    and precisely as possible. The sample mean and sample variance are defined as:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![sampling](../Images/4c55529205ac92bf13882c258c007273.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: The sample mean estimates the unknown constant, and the sample variance measures
    how precise the estimate is. Under quite general conditions, as n gets large,
    the sample mean obeys a normal distribution with mean equal to the unknown constant
    and variance equal to the the sample variance. The 95% approximate confidence
    interval is
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![Confidence interval](../Images/60606007f7470e2767d784bd868c9bd3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: The confidence interval measures the uncertainty assoicated with our estimate
    of the unknown constant. It means that if we perform the same experiment many
    times, we would expect that 95% of the time the estimated mean would lie in the
    given interval. The number 1.96 occurs because the probability that a normal random
    variable is between -1.96 and 1.96 happen to be 95%. If we want a 90% or 99% confidence
    interval, substitute 1.645 or 2.575, respectively. The confidence interval above
    is not exact. It is approximate because we are estimating the standard deviation.
    In n is small (say less than 50), we should use the exact 95% confidence interval
    with the Student's T distribution with n-1 degrees of freedom. For example, if
    there are n = 25 samples, then we should use 2.06 instead of 1.96. These numbers
    can be computed using [or124.jar](http://opsresearch.com/cgi-bin/freeware.cgi/or124.jar)
    which contains the [OR-Objects library](http://opsresearch.com/OR-Objects/api/drasys/or/prob/package-summary.html).
    Program [ProbDemo.java](ProbDemo.java.html) illustrates how to use it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Implemenation.* Program [Average.java](Average.java.html) is a straightforward
    implementation of the formulas above. This formula involves two passes through
    the data: one to compute the sample mean, and one to compute the sample variance.
    Thus, we store the data in an array. This appears wasteful since we could compute
    both in one pass using the alternate textbook formula for the sample variance.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![one pass algorithm](../Images/88f00a6cc3184bdb1a7d7931e33f8a5d.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: We avoid this one-pass approach because it is numerically unstable. (See Exercise
    XYZ and XYZ.) This instability is most pronounced when the data has small variance
    but a large number of significant digits. In fact, it can cause the program to
    take the square root of a negative number! (See Exercise XYZ.) This subtlety surprises
    many uninitiated programmers. In fact, it even surprises some very experienced
    ones. Microsoft Excel versions 1.0 through 2002 implement the unstable one-pass
    algorithm in over a dozen of their statistical library functions. As a result,
    you may experience inaccurate results with no warning. [These bugs were fixed](http://support.microsoft.com/default.aspx?kbid=826393)
    with the release of Excel 2003.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '*Confidence intervals.* Temperature in January vs. July.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '*Survey sampling.* Census survey, temperature readings, election exit polls,
    quality control in manufacturing processes, auditing financial records, epidemiology,
    etc. Generally, newspapers report the result of some poll as something like 47%
    ± 3%. What does this really mean? Typically a 95% confidence interval is implicitly
    assumed. We assume the population consists of N elements, and we take a sample
    of size n, and sample i has an associated real value x[i], which could represent
    weight or age. It could also represent 0 or 1 to denote whether some characteristic
    is present or absent (e.g., plan to vote for Kerry). The techniques from random
    sampling apply, except that we need to make a correction for the finite population
    size.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![sample from finite population](../Images/395fb6eaf287d2d58b23efad8c83e2d3.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: When N is large relative to n (only a small fraction of the population is sampled),
    the finite population effects can be ignored.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '*Histogram.* Program `Histogram.java` dynamically displays histogram as the
    data is accumulated.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[data sets](http://www.oswego.edu/~kane/econometrics/data.htm)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple linear regression.** In 1800 Giuseppe Piazzi discovered what appeared
    to be a new star and tracked its movement for 41 days before losing track of it
    due to bad weather. He was amazed since it moved in the opposite direction of
    the other stars. Carl Frederick Gauss used his newly invented method of least
    squares to predict where to find the star. Gauss became famous after the the star
    was located according to his prediction. As it turns out, the celestial body was
    an asteroid, the first one ever discovered. Now, the method of least squares is
    applied in many disciplines from psychology to epidemiology to physics. Gauss''
    famous computation involved predicting the location of an object using 6 variables.
    We first consider [simple linear regression](http://www.wikipedia.org/wiki/Linear_regression)
    which involves only a single predictor variable x, and we model the response y
    = &beta[0] + β[1]x. Given a sequence of n pairs of real numbers (x[i], y[i]),
    we define the residual at x[i] to be r[i] = (y[i] - β[0] - β[1]x[i]). The goal
    is to estimate values for the unobserved parameters β[0] and β[1] to make the
    residuals as small as possible. The method of least squares is to choose the parameters
    to minimize the sum of the squares of the residuals. Using elementary calculus,
    we can obtain the classic least squares estimates:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple linear regression](../Images/404911bdf6e1d92c96b786c3ee6ef1db.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Program [LinearRegression.java](LinearRegression.java.html) reads in n measurements
    from standard input, plots them, and computes the line that best fits the data
    according to the least squares metric.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '**Assessing the fitted solution.** To measure the goodness of fit, we can compute
    the coefficient of determination R², which measure the fraction of variability
    in the data that can be explained by the variable x.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Correlation coefficient](../Images/6303806546bcf5fd3ce4c4437bb56026.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: We can also estimate the standard error, the standard error of the regression
    estimate for β[0] and β[1], and the 95% approximate confidence interval for the
    two unknown coefficients are.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![standard error](../Images/afdc07d32c016d10b24fb7f77ed8fee7.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: '*Running time of algorithms.* Take log of both sides. The slope is the exponent,
    the intercept is the constant.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Plot latitude vs. January temperature. Draw points within 2 standard deviations
    in black, between 2 and 3 in blue, above 3 in green. 18 of 19 outliers are in
    California or Oregon. The other is in Gunnison County, Colorado which is at very
    high altitude. Perhaps need to incorporate longitude and alititude into model...
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Test for normality.**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple linear regression.** Multiple linear regression generalizes simple
    linear regression by allowing several predictor variables instead of just one.
    We model the response y = β[0] + β[1]x[1] + ... + β[p]x[p]. Now, we have a sequence
    of n response values y[i], and a sequence of n predictor *vectors* (x[i1], x[i2],
    ..., x[ip]). The goal is to estimate the parameter vector (β[0], ..., β[p]) so
    as to minimize the sum of the squared errors. In matrix notation, we have an overdetermined
    system of equations y = Xβ.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**多元线性回归。** 多元线性回归通过允许多个预测变量而不仅仅是一个来推广简单线性回归。我们对响应 y = β[0] + β[1]x[1] + ...
    + β[p]x[p] 进行建模。现在，我们有一系列 n 个响应值 y[i]，以及一系列 n 个预测 *向量*（x[i1]，x[i2]，...，x[ip]）。目标是估计参数向量（β[0]，...，β[p]），以使平方误差的总和最小化。在矩阵表示中，我们有一个过度确定的方程组
    y = Xβ。'
- en: '![Multiple linear regression](../Images/e55ead4059086e58bbaabd338285fd07.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![多元线性回归](../Images/e55ead4059086e58bbaabd338285fd07.png)'
- en: Our goal is to find a vector β that minimizes ||X^(β - y||. Assuming X has full
    column rank, we can compute β by solving the *normal equations* X^TXβ = X^Ty to
    compute our estimate of β. The simplest way to solve the normal equations is to
    explicitly compute A = X^TX and b = X^Ty and solve the system of equations Ax
    = b using Gaussian elimination. A numerically stable algorithm for computing β
    is to compute QR factorization X = QR, then solve the triangular system Rβ = Q^Ty
    via back substitution. This is exactly what Jama's `solve` method does when presented
    with an overdetermined system (assumes matrix has full column rank). Program [MultipleLinearRegression.java](MultipleLinearRegression.java.html)
    is a straightforward implementation of this approach. See Exercise XYZ for an
    SVD-based method that works even if the system does not have full column rank).)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一个最小化 ||X^(β - y|| 的向量 β。假设 X 具有完整的列秩，我们可以通过解决 *正规方程* X^TXβ = X^Ty 来计算
    β 的估计值。解决正规方程的最简单方法是显式计算 A = X^TX 和 b = X^Ty，并使用高斯消元法解方程组 Ax = b。计算 β 的一个数值稳定的算法是计算
    QR 分解 X = QR，然后通过回代解三角形系统 Rβ = Q^Ty 来解决。这正是 Jama 的 `solve` 方法在面对一个过度确定系统时所做的（假设矩阵具有完整的列秩）。程序[MultipleLinearRegression.java](MultipleLinearRegression.java.html)是这种方法的一个直接实现。参见练习
    XYZ，其中介绍了一种基于 SVD 的方法，即使系统没有完整的列秩也可以工作。)
- en: '**An example.** Weather data set and examples from this [reference](http://www.stat.lsa.umich.edu/~kshedden/Courses/Stat401/Notes/401-multreg.pdf).
    Averag maximum daily temperatures at n = 1070 weather stations in US during March,
    2001 Predictors = latitude (X1), longitude (X2), and elevation (X3). Model Y =
    101 - 2 X1 + 0.3 X2 - 0.003 X3. Temp increases as longitude increases (west),
    but decreases as latitude increase (north) and alitude increase. Is effect of
    latitude on temperature greater in west or east? Plot scatterplot of temperature
    vs. latitude (divide at median longitude of 93 degrees) for March. Plot residuals
    vs. fitted values. Should not show any pattern.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个例子。** 天气数据集和来自这个[参考资料](http://www.stat.lsa.umich.edu/~kshedden/Courses/Stat401/Notes/401-multreg.pdf)的例子。2001年3月，美国1070个气象站的平均最高日温度。预测因子
    = 纬度（X1）、经度（X2）和海拔（X3）。模型 Y = 101 - 2 X1 + 0.3 X2 - 0.003 X3。随着经度增加（向西），温度增加，但随着纬度增加（向北）和海拔增加，温度降低。纬度对温度的影响在西部和东部哪个更大？绘制3月份温度与纬度的散点图（以93度为中位数的经度分割）。绘制残差与拟合值的图。不应显示任何模式。'
- en: '**Assesing the model.** The error variance s² is the sum of the squared error
    divided by the degrees of freedom (n - p - 1). The diagonal entries of the standard
    variance matrix is σ²(X^TX)^(-1) estimate the variance of the parameter estimates.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**评估模型。** 误差方差 s² 是平方误差之和除以自由度（n - p - 1）。标准方差矩阵的对角线条目是 σ²(X^TX)^(-1) 估计参数估计的方差。'
- en: '![Multiple linear regression](../Images/fca82c52488c54f459bd9c267ef227a4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![多元线性回归](../Images/fca82c52488c54f459bd9c267ef227a4.png)'
- en: '**Polynomial regression.** predictor variables instead of just one. We model
    the response y = β[0] + β[1]x¹ + ... + β[p]x^p. [PolynomialRegression.java](PolynomialRegression.java.html)
    is a data type for performing polynomial regression.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**多项式回归。** 预测变量不只是一个。我们对响应 y = β[0] + β[1]x¹ + ... + β[p]x^p 进行建模。[PolynomialRegression.java](PolynomialRegression.java.html)
    是执行多项式回归的数据类型。'
- en: Discrete Fourier transform.
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离散傅立叶变换。
- en: The discovery of efficient algorithms can have a profound social and cultural
    impact. The discrete Fourier transform is a method for decomposing a waveform
    of N samples (e.g., sound) into periodic components. The brute force solution
    takes time proportional to N². At the age of 27, Freidrich Gauss proposed a method
    that requires only N log N steps, and he used it to analyze the periodic motion
    of the asteroid Ceres. This method was later rediscovered and popularized by Cooley
    and Tukey in 1965 after they described how to efficiently implement it on a digital
    computer. Their motivation was monitoring nuclear tests in the Soviet Union and
    tracking Soviet submarines. The FFT has become a cornerstone of signal processing,
    and is a crucial component of devices like DVD players, cell phones, and disk
    drives. It is also forms the foundation of many popular data formats including
    JPEG, MP3, and DivX. Also speech analysis, music synthesis, image processing.
    Doctors routinely use the FFT for medical imaging, including Magnetic Resonance
    Imaging (MRI), Magnetic Resonance Spectroscopy (MRS), Computer Assisted Tomography
    (CAT scans). Another important application is fast solutions to partial differential
    equations with periodic boundary conditions, most notably Poisson's equation and
    the nonlinear Schroedinger equation. Also used to simulate fractional Brownian
    motion. Without a fast way to solve to compute the DFT none of this would be possible.
    Charles van Loan writes "The FFT is one of the truly great computational developments
    of this [20th] century. It has changed the face of science and engineering so
    much that it is not an exaggeration to say that *life as we know it would be very
    different without the FFT.*"
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 发现高效算法可以产生深远的社会和文化影响。离散傅立叶变换是一种将N个样本（例如声音）的波形分解为周期分量的方法。暴力解决方案的时间复杂度与N²成正比。27岁时，高斯提出了一种仅需N
    log N步的方法，并用它来分析小行星谷神星的周期运动。这种方法后来被库利和图基在1965年重新发现并推广，他们描述了如何在数字计算机上高效实现它。他们的动机是监视苏联的核试验和跟踪苏联潜艇。快速傅立叶变换已成为信号处理的基石，并是DVD播放器、手机和磁盘驱动器等设备的关键组件。它还构成许多流行数据格式的基础，包括JPEG、MP3和DivX。还有语音分析、音乐合成、图像处理。医生们经常在医学成像中使用快速傅立叶变换，包括磁共振成像（MRI）、磁共振光谱（MRS）、计算机辅助断层扫描（CAT扫描）。另一个重要应用是快速解决具有周期边界条件的偏微分方程，尤其是泊松方程和非线性薛定谔方程。还用于模拟分数布朗运动。如果没有快速计算DFT的方��，这一切都将不可能。查尔斯·范·洛恩写道：“快速傅立叶变换是本世纪真正伟大的计算发展之一。它已经改变了科学和工程的面貌，可以毫不夸张地说，*没有快速傅立叶变换，我们所知道的生活将会截然不同*。”
- en: '*Fourier analysis* is a methodology for approximating a function (signal) by
    a sum of sinusoidals (complex exponentials), each at a diffferent frequency. When
    using computers, we also assume that the the continuous function is approximated
    by a finite number points, sampled over a regular interval. Sinusoids play a crucial
    role in physics for describing oscillating systems, including simple harmonic
    motion. The human ear is a Fourier analyzer for sound. Roughly speaking, human
    hearing works by splitting a sound wave into sinusoidal components. Each frequency
    resonates at a different position in the basilar membrane, and these signals are
    delivered to the brain along the auditory nerve. One of the main applications
    of the DFT is to identify periodicities in data and their relative strengths,
    e.g., filtering out high frequency noise in acoustic data, isolating diurnal and
    annual cycles in weather, analyzing astronomical data, performing atmospheric
    imaging, and identifying seasonal trends in economic data.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*傅立叶分析*是一种通过不同频率的正弦波（复指数）的和来近似函数（信号）的方法。在使用计算机时，我们还假设连续函数由在规则间隔上采样的有限数量点来近似。正弦波在物理学中起着至关重要的作用，用于描述振荡系统，包括简谐运动。人耳是声音的傅立叶分析器。粗略地说，人类听觉通过将声波分解为正弦分量来工作。每个频率在耳蜗膜中的不同位置共振，并将这些信号沿听神经传递到大脑。DFT的主要应用之一是识别数据中的周期性及其相对强度，例如在声学数据中滤除高频噪声，分离天气中的昼夜和年度循环，分析天文数据，执行大气成像，并识别经济数据中的季节性趋势。'
- en: The *discrete Fourier transform* (DFT) of a length N complex vector x is defined
    by
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为N的复向量x的*离散傅立叶变换*（DFT）定义为
- en: '![Discrete Fourier transform](../Images/7d58ef322d6a010e7a01597575b23033.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![离散傅立叶变换](../Images/7d58ef322d6a010e7a01597575b23033.png)'
- en: where i is the square root of -1 and ω = e^(-2iπ/N) is a principal Nth root
    of unity. We can also interpret the DFT as the matrix-vector product y = F[N]
    x, where F[N] is the N-by-N matrix whose jth row and kth column is ω^(jk). For
    example, when N = 4,
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其中i是-1的平方根，ω = e^(-2iπ/N)是主N次单位根。我们还可以将DFT解释为矩阵-向量乘积y = F[N] x，其中F[N]是N×N矩阵，其第j行第k列为ω^(jk)。例如，当N
    = 4时，
- en: '![DFT example](../Images/a0c10af275598f0f11be4dc0e30d5c90.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![DFT示例](../Images/a0c10af275598f0f11be4dc0e30d5c90.png)'
- en: 'We note that some authors define the Fourier matrix to be the conjugate of
    our Fourier matrix and normalize it by the factor 1 / sqrt(N) to make it unitary.
    Intuition: let x[i] be the samples of a signal over a time interval from 0 to
    T, and let f[i] be the DFT. Then f[0] / n is an approximation of the average value
    of the signal over the interval. The modulus (absolute value) and argument (angle)
    of the complex number f[j] represent (one half) the amplitude and the phase of
    the signal component having frequency j / T for j = 1 to n/2 - 1.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到一些作者将傅立叶矩阵定义为我们的傅立叶矩阵的共轭，并通过因子1 / sqrt(N)对其进行归一化，使其成为幺正的。直觉：设x[i]为时间间隔从0到T的信号样本，f[i]为DFT。那么f[0]
    / n是信号在该间隔内的平均值的近似值。复数f[j]的模（绝对值）和幅角（角度）表示频率为j / T的信号分量的振幅和相位（一半）。
- en: '*Fast Fourier transform.* It is straightforward to compute the DFT of a N-length
    vector either directly from the definition or via a dense matrix-vector multiplication.
    Both approaches take quadratic time. The Fast Fourier transform (FFT) is an ingenious
    method that computes the DFT in time proportional to N log N. It works by exploiting
    the symmetry of the Fourier matrix F. The crucial idea is to use properties of
    the nth roots of unity to relate the Fourier transform of a vector of size n to
    two Fourier transforms on vectors of size n/2.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![FFT](../Images/c1b6acd72769defb470f78d6199f4d73.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'where x[even] denotes the vector of size n/2 consisting of x[0], x[2], ...,
    x[n-2] and x[odd] denote the vector consisting of x[1], x[3], ..., x[n-1], the
    matrix I[n/2] is the n/2-by-n/2 identity matrix and the matrix D[n/2] is the diagonal
    matrix whose kth diagonal entry is ω^k. The *radix 2 Cooley-Tukey FFT* uses this
    recursive formula to compute the DFT in a divide-and-conquer style framework.
    Note that we have implicitly assumed that N is a power of 2. Program [FFT.java](FFT.java.html)
    is a bare bones implementation of this scheme. It relies on the [Complex.java](Complex.java.html)
    ADT developed in Section xyz. Program [InplaceFFT.java](InplaceFFT.java.html)
    is an *in-place* variant: it uses only O(1) extra memory.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Inverse FFT.** The *inverse DFT* is defined as: The inverse of F[N] is the
    complex conjugate of itself, scaled down by a factor of N. Thus, to compute the
    inverse DFT of x: compute the DFT of the conjugate of x, take the conjugate of
    the result, and multiply each value by N.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '*Touch tone phones.* *Touch Tone* ® telephones encode key presses as audio
    signals using a system called *dual tone multi frequency* (DTMF). Two audio frequncies
    are associated with each key press according to the table below'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For example, when the key 7 is pressed, the phone generates signals at frequencies
    770 Hz and 1209 Hz, and sums them together. The frequencies should be within 1.5%
    of the proscribed values or the telephone company ignores it. The high frequencies
    must be at least as loud as the low frequency, but can be no more than 3 decibels
    louder.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[notes](http://www.physik.uni-hannover.de/cip/fourier.pdf)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[touch tone songs](http://www.twpyhr.com/tttfaq.shtml), [touch tone sounds](http://rl.se/polisradio/dtmf.php)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '*Commercial implementations.* Because the FFTs great importance, there is a
    rich literature of efficient FFT algorithms, and there are many high optimized
    library implementations available (e.g., Matlab and the [Fastest Fourier Transform
    in the West](http://fftw.org)). Our implementation is a bare bones version that
    captures the most salients ideas, but it can be improved in a number of ways.
    For example, commercial implementations works for any N, not just powers of 2.
    If the input is real (instead of complex), they exploit additional symmetry and
    runs faster. They can also handle multidimensional FFTs. Our FFT implementation
    has a much higher memory footprint than required. With great care, it is even
    possible to do the FFT in-place, i.e., with no extra arrays other than x. Commericial
    FFT implementations also use iterative algorithms instead of recursion. This can
    make the code more efficient, but harder to understand. High performance computing
    machines have specialized vector processors, which can perform vector operations
    faster than an equivalent sequence of scalar operations. Although computational
    scientists often measure performance in terms of the number of flops (floating
    point operations), with the FFT, the number of mems (memory accesses) is also
    critical. Commercial FFT algorithms pay special attention to the costs associated
    with moving data around in memory. Parallel FFTs. Implemented in hardware.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Convolution.** The [convolution](http://en.wikipedia.org/wiki/Convolution)
    of two vectors is a third vector which represents an overlap between the two vectors.
    It arises in numerous applications: weighted moving average in statistics, shadows
    in optics, and echos in acoustics. Given two periodic signals a and b of length
    N, the *circular convolution* of a and b is defined by'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**卷积。** 两个向量的[卷积](http://en.wikipedia.org/wiki/Convolution)是表示两个向量之间重叠的第三个向量。它在许多应用中出现：统计学中的加权移动平均、光学中的阴影和声学中的回声。给定长度为N的两个周期信号a和b，a和b的*循环卷积*定义为'
- en: '![Convolution](../Images/07dd64a2d5a1e65f8bce06acb84d0fd5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![卷积](../Images/07dd64a2d5a1e65f8bce06acb84d0fd5.png)'
- en: and we use the notation c = a ⊗ b. The vector b is called the impulse response,
    filter, template, or point spread function. To see the importance of convolution,
    consider two degree N polynomials p(x) and q(x). Observe that the coefficients
    of r(x) = p(x) q(x) are
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用符号c = a ⊗ b。向量b称为脉冲响应、滤波器、模板或点扩散函数。为了看到卷积的重要性，考虑两个N次多项式p(x)和q(x)。观察到r(x)
    = p(x) q(x)的系数为
- en: '![Convolution](../Images/c64b8c199d0abd48b2cccca18fcbe5e4.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![卷积](../Images/c64b8c199d0abd48b2cccca18fcbe5e4.png)'
- en: obtained by convolving the coefficients of p with q, where p and q are padded
    with leading 0s to a length 2N. To facilitate computation, we also may pad with
    additional leading 0s to make its length a power of 2. This simulates the *linear
    convolution* since we don't want periodic boundary conditions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将p和q的系数进行卷积得到，其中p和q在长度为2N的情况下填充了前导0。为了便于计算，我们还可以填充额外的前导0，使其长度成为2的幂。这模拟了*线性卷积*，因为我们不希望周期性边界条件。
- en: A cornerstone result of Fourier analysis is the Convolution Theorem. It says
    that the DFT of a convolution of two vectors is the point-wise product of the
    DFT of the two vectors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶分析的一个基石结果是卷积定理。它表明两个向量卷积的DFT是两个向量的DFT的逐点乘积。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Convolution Theorem is useful because the *inverse DFT* is easy to compute.
    This implies that we can compute the circular convolution (and hence polynomial
    multiplicaton) in N log N steps by taking three separate FFTs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积定理很有用，因为*逆DFT*很容易计算。这意味着我们可以通过进行三次单独的FFT来在N log N步骤中计算循环卷积（从而进行多项式乘法）。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is amazing on two levels. First, it means that we can multiply two real
    (or complex) polynomials substantially faster than brute force. Second, the method
    relies on complex numbers even though multiplying two real polynomials appears
    to have nothing to do with imaginary numbers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这在两个层面上都是令人惊奇的。首先，这意味着我们可以比蛮力更快地相乘两个实（或复）多项式。其次，这种方法依赖于复数，即使相乘两个实多项式似乎与虚数无关。
- en: Matlab supplies a function `conv` that performs a linear convoultion of two
    vectors. However, their implementation takes quadratic time. In many applications,
    the vectors are large, say 1 million entries, and using this library function
    as a black box would be unacceptable. By exploiting our understanding of algorithms
    and complexity we can replace the library solution with an optimized one using
    the FFT!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Matlab提供了一个名为`conv`的函数，用于执行两个向量的线性卷积。然而，他们的实现需要二次时间。在许多应用中，向量很大，比如有100万个条目，使用这个库函数作为黑匣子是不可接受的。通过利用我们对算法和复杂性的理解，我们可以用FFT替换库解决方案，从而得到优化的解决方案！
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we have just witnessed, we can make dramatic performance improvements in
    computing the convolution, by first tranforming the data from the time domain
    to frequency domain. This same principle applies to related problems, including
    cross correlation, autocorrelation, polynomial multiplication, discrete sine and
    cosine transforms. It also means that we have fast matrix-vector multiplication
    algorithms for circulant matrices and Toeplitz matrices, which arise in numerical
    solutions to partial differential equations. f = signal, y = spectrum. f = impulse
    response, y = frequency response.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚见证的，通过首先将数据从时域转换到频域，我们可以在计算卷积时取得显著的性能改进。这个原则也适用于相关问题，包括交叉相关、自相关、多项式乘法、离散正弦和余弦变换。这也意味着我们对循环矩阵和Toeplitz矩阵有快速矩阵-向量乘法算法，这些矩阵出现在偏微分方程的数值解中。f
    = 信号，y = 频谱。f = 脉冲响应，y = 频率响应。
- en: '**2D DFT.** (exercise) Compute a 2D DFT of an N-by-N matrix by taking a DFT
    for each column, then taking a DFT of each row of the resulting values. N² log
    N.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**2D DFT。**（练习）通过对每一列进行DFT，然后对结果值的每一行进行DFT，计算一个N×N矩阵的2D DFT。N² log N。'
- en: 'References: [image compression](http://www.cs.berkeley.edu/~demmel/cs267/lecture24/lecture24.html#link_6),
    [DFT book](http://ccrma.stanford.edu/~jos/r320/)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料：[图像压缩](http://www.cs.berkeley.edu/~demmel/cs267/lecture24/lecture24.html#link_6)，[DFT书籍](http://ccrma.stanford.edu/~jos/r320/)
- en: Q + A
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q + A
- en: Q. Why is it called the Student's T distribution?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Q. 为什么称之为学生T分布？
- en: A. Discovered by an employee of Guinness brewing company named William Gosset
    in 1908, but Guinness did not allow him to publish under his own name, so he used
    "Student."
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: A. 由吉尼斯啤酒公司的一名名叫威廉·高斯特的员工于1908年发现，但吉尼斯不允许他以自己的名义发表，所以他使用了“学生”。
- en: Q. Why minimize the sum of the squared errors instead of the sum of the absolute
    errors or some other measure?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Q. 为什么要最小化平方误差的总和而不是绝对误差的总和或其他度量？
- en: 'A. Short answer: this is what scientists do in pratice. There are also some
    mathematical justifications. The [Gauss-Markov theorem](http://www.wikipedia.org/wiki/Gauss-Markov_theorem)
    says that if you have a linear model in which the errors have zero mean, equal
    variance, and are uncorrelated, then the least squares estimates of a and b (the
    ones that minimize the sum of the squared error) have the smallest variance among
    all unbiased estimates of a and b. If in addition we assume that the errors are
    independent and normally distributed, then we can derive *95% or 99% confidence
    intervals*...'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Q. Where can I get a charting library?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: A. Check out [JFreeChart](http://www.jfree.org/jfreechart/). Here are [some
    instructions](http://www.javaworld.com/javaworld/jw-12-2002/jw-1227-opensourceprofile.html)
    on using it. Or see the [Scientific Graphics Toolkit](http://www.epic.noaa.gov/java/sgt/index.html)
    for creating interactive, publication quality graphics of scientific data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Baseball statistics..** Do some analysis of [baseball statistics](http://www.baseball1.com/statistics/).'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Histogram.** Modify `Histogram.java` so that you do not have to input the
    range ahead of time.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Histogram.** Modify `Histogram.java` so that it has 10 buckets.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Pie chart.**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stem-and-leaf plot.**'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Simple linear regression.** Modify program LinearRegression.java to plot
    and scale the data. Again, we are careful to choose a stable algorithm instead
    of a slightly simpler one-pass alternative.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creative Exercises
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**One-pass algorithm.** Write a program [OnePass.java](OnePass.java.html) that
    computes the sample mean and variance in one pass (instead of two) using the alternate
    textbook formula.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Verify that it is not numerically stable by plugging in n = 3, x[1] = 1000000000,
    x[2] = 1000000001, and x[3] = 1000000002\. The one pass algorithm gives a variance
    of 0, but the true answer is 1. Also, verify that it can lead to taking the square
    root of a negative number by plugging in an input with n = 2, x[1] = 0.5000000000000002
    and x[2] = 0.5000000000000001. Compare with [Average.java](Average.java.html).
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Sample variance.** Implement the following stable, one-pass algorithm for
    computing the sample variance. Verify that the formula is correct.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Normal quantile plot.** To test whether a given set of data follows a normal
    distribution, create a *normal quantile plot* of the data and check whether the
    points lie on (or close to) a straight line. To create a normal quantile plot,
    sort the N data points. Then plot the ith data point against Φ^(-1)(i / N).'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Diamond 3D graphs.** Write a program to read in a set of three dimensional
    data and plot a [diamond graph](http://www.jhsph.edu/Press_Room/Press_Releases/Munoz_diamond_graph.html)
    of the data like the one below. Diamond graphs have several advantages over 3D
    bar charts.![](../Images/ea0bcda65e0eafaf1ba66614d963e418.png)'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Polynomial curve fitting.** Suppose we have a set of N observations (x[i],
    y[i]) and we want to model the data using a low degree polynomial.![Polynomial
    curve fitting](../Images/32e98553c6ee49900703338d9504806a.png)'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Empirically collect n samples: (x[i], y[i]). In matrix notation, our least
    squares problem is:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Vandermonde matrix](../Images/ef448d79b63ad09eb4cd7f1d8c2321a3.png)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The Matrix X is called the *Vandermonde matrix* and has full column rank if
    n ≥ p and the x[i] are distinct. Our problem is a special case of general linear
    regression. The solution vector β are the coefficients of the best fit degree
    p polynomial.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Rank deficient linear regression.** Better method: use SVD. Better numerical
    stability properties. Works even if A doesn''t have full rank. Compute the [skinny
    SVD](http://element.stanford.edu/~lall/courses/current/engr207a/svd_2004_01_13_01.pdf):
    A = U[r]Σ[r]V[r]^T. Here r is the rank of A, U[r], Σ[r], and V[r] are the first
    r columns of U, Σ, and V, respectively. The pseduoinverse A^† = U[r](Σ[r])^(-1)V[r]^T
    and the least squares estimate x* = A^†b. The pseudoinverse nicely generalizes
    the matrix inverse: if A is square and invertible then A^† = A^(-1). If A is skinny
    and has full rank then A^† = (A^TA)^(-1)A^T. To compute A^†b, don''t explictly
    form the pseudoinverse. Instead, compute v = V^Tb, w = Σ^(-1)u, x* = Uw. Note
    that Σ^(-1) is easy to compute since Σ is diagonal.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**秩亏线性回归。** 更好的方法：使用SVD。具有更好的数值稳定性特性。即使A没有满秩，也可以工作。计算[瘦SVD](http://element.stanford.edu/~lall/courses/current/engr207a/svd_2004_01_13_01.pdf)：A
    = U[r]Σ[r]V[r]^T。这里r是A的秩，U[r]，Σ[r]和V[r]分别是U，Σ和V的前r列。伪逆A^† = U[r](Σ[r])^(-1)V[r]^T和最小二乘估计x*
    = A^†b。伪逆很好地推广了矩阵的逆：如果A是方阵且可逆，则A^† = A^(-1)。如果A是瘦的且具有满秩，则A^† = (A^TA)^(-1)A^T。要计算A^†b，不要显式形成伪逆。相反，计算v
    = V^Tb，w = Σ^(-1)u，x* = Uw。注意Σ^(-1)易于计算，因为Σ是对角线的。'
- en: In Matlab, `pinv(A)` gives pseudoinverse and `svd(A, 0)` gives thin SVD for
    skinny matrices (but not fat ones!)
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Matlab中，`pinv(A)`给出伪逆，`svd(A, 0)`给出瘦SVD用于瘦矩阵（但不适用于胖矩阵！）
- en: '**Underdetermined system.** In data fitting applications, the system of equations
    is typically overdetermined and A is skinny. In control systems, we have have
    an underdetermined system of equations and the goal is to find an x* that solves
    Ax* = b such that the norm of x* is minimized. Again, the SVD comes to the rescue.
    If A has full column rank, then A^†b is such a solution.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**欠定系统。** 在数据拟合应用中，方程组通常是过度确定的且A是瘦的。在控制系统中，我们有一个欠定的方程组，目标是找到一个解Ax* = b，使得x*的范数最小化。同样，SVD拯救了我们。如果A具有完整的列秩，则A^†b就是这样一个解。'
- en: '**Polynomial multiplication.** Give two polynomials of degree m and n, describe
    how to compute their product in time O(m log n).'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多项式乘法。** 给定两个分别为m和n次的多项式，描述如何在O(m log n)的时间内计算它们的乘积。'
- en: '**Clustering.** Evolutionary trees in biology, marketing research in business,
    classifying painters and musicians in liberal arts, classifying survey responses
    in sociology, [reference: Guy Bleloch]'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚类。** 生物学中的进化树，商业中的市场研究，文理学中的画家和音乐家分类，社会学中的调查响应分类，[参考：盖伊·布洛克]'
