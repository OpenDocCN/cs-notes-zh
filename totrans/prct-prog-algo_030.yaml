- en: 5.5   Intractability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5   难解性
- en: 原文：[https://introcs.cs.princeton.edu/java/55intractability](https://introcs.cs.princeton.edu/java/55intractability)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/55intractability](https://introcs.cs.princeton.edu/java/55intractability)
- en: This section under major construction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节正在进行重大改建。
- en: The goal of complexity theory is to understand the nature of efficient computation.
    In Section 4.1, we learned about analysis of algorithms, which enables us to classify
    *algorithms* according to the amount of resources they will consume. In this section,
    we will learn about a rich class of *problems* for which nobody has been able
    to devise an efficient algorithm.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性理论的目标是理解有效计算的本质。在第4.1节中，我们学习了算法分析，这使我们能够根据算法消耗的资源量对*算法*进行分类。在本节中，我们将学习一个丰富的*问题*类别，对于这些问题，没有人能够设计出有效的算法。
- en: A nice [YouTube video on P = NP](https://www.youtube.com/watch?v=YX40hbAHx3s).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于P = NP的不错的[YouTube视频](https://www.youtube.com/watch?v=YX40hbAHx3s)。
- en: Computational complexity.
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ���算复杂性。
- en: As digital computers were developed in the 1940s and 1950s, the Turing machine
    served as the theoretical model of computation. In the 1960s Hartmanis and Stearns
    proposed measuring the time and memory needed by a computer as a function of the
    input size. They defined complexity classes in terms of Turing machines and proved
    that some problems have "an inherent complexity that cannot be circumvented by
    clever programming." They also proved a formal version ( [time hierarchy theorem](http://en.wikipedia.org/wiki/Time_hierarchy_theorem))
    of the intuitive idea that if given more time or space, Turing machines can compute
    more things. In other words, no matter how hard a problem is (time and space requirements),
    there are always harder problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数字计算机在1940年代和1950年代的发展，图灵机成为计算的理论模型。在1960年代，Hartmanis和Stearns提出了根据输入大小的函数来衡量计算机所需的时间和内存。他们以图灵机的术语定义了复杂性类，并证明了一些问题具有“无法通过巧妙编程规避的固有复杂性”。他们还证明了一个直观观念的正式版本（[时间层次定理](http://en.wikipedia.org/wiki/Time_hierarchy_theorem)），即如果给予更多时间或空间，图灵机可以计算更多的事情。换句话说，无论问题有多难（时间和空间要求），总会有更难的问题。
- en: Computational complexity is the art and science of determining resource requirements
    for different *problems*. Computational complexity deals with assertions about
    *any* conceivable algorithm for a problem. Making such statements is significantly
    more challenging than understanding the running time of one particular algorithm
    for the problem since we must reason about all possible algorithms (even those
    not yet discovered). This makes computational complexity an exciting, yet daunting,
    field of study. We will survey some of its most important ideas and practical
    outgrowths.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 计算复杂性是确定不同*问题*的资源需求的艺术和科学。计算复杂性涉及对*任何*可能的问题算法的断言。做出这样的陈述比理解解决问题的一个特定算法的运行时间要困难得多，因为我们必须推理出所有可能的算法（甚至是尚未发现的算法）。这使得计算复杂性成为一个令人兴奋但令人望而生畏的研究领域。我们将概述一些其最重要的思想和实际产物。
- en: Polynomial-time.
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式时间。
- en: In Section 4.1, we learned how to analyze the running time of an algorithm as
    a function of its input size. When solving a given problem, we prefer an algorithm
    that takes 8 N log N steps to one that takes 3 N² steps, since when N is large,
    the first algorithm is significantly faster than the first. The second algorithm
    will ultimately solve the same problem (but it might take hours instead of seconds).
    In contrast, an exponential time algorithm has a different qualitative behavior.
    For example, a brute force algorithm for the TSP might take N! steps. Even if
    each electron in the universe (10^(79)) had the power of today's fastest supercomputer
    (10^(12) instructions per second), and each worked for the life of the universe
    (10^(17) seconds) on solving the problem, it would barely make a dent in solving
    a problem with N = 1,000 since 1000! >> 10^(1000) >> 10^(79) * 10^(12) * 10^(17).
    Exponential growth dwarfs technological change. We refer to any algorithm whose
    running time is bounded by a polynomial in the input size (e.g., N log N or N^2)
    as a *polynomial-time* algorithm. We say that a problem is *intractable* if there
    is no polynomial-time algorithm for the problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4.1节中，我们学习了如何分析算法的运行时间作为其输入大小的函数。在解决给定问题时，我们更喜欢一个需要8 N log N步骤的算法，而不是需要3 N²步骤的算法，因为当N很大时，第一个算法比第二个算法快得多。第二个算法最终将解决相同的问题（但可能需要几小时而不是几秒）。相比之下，指数时间算法具有不同的定性行为。例如，对于TSP的暴力算法可能需要N!步骤。即使宇宙中的每个电子（10^(79)）都具有今天最快超级计算机（每秒10^(12)条指令）的能力，并且每个电子在解决问题上工作了宇宙寿命（10^(17)秒），也几乎无法解决N
    = 1,000的问题，因为1000! >> 10^(1000) >> 10^(79) * 10^(12) * 10^(17)。指数增长使技术变革相形见绌。我们将任何运行时间受输入大小多项式限制的算法（例如N
    log N或N^2）称为*多项式时间*算法。如果对于问题没有多项式时间算法，则称该问题为*难解性*。
- en: Create log-log scale plot of N, N³, N⁵, N^(10), 1.1^N, 2^N, N! as in Harel p.
    74.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Harel p. 74中创建N、N³、N⁵、N^(10)、1.1^N、2^N、N!的对数对数比例图。
- en: As programmers gained more experience with computation, it became evident that
    polynomial-time algorithms were useful and exponential-time algorithms were not.
    In a very [influential paper](../../papers/edmonds.pdf), Jack Edmonds referred
    to polynomial algorithms as "good algorithms" and argued that polynomial time
    is a good surrogate for efficient computation. Kurt Godel wrote [a letter to von
    Neumann (p. 9)](http://www.cs.berkeley.edu/~luca/cs172/sipser92history.pdf) in
    1956 that contains the (implicit) notion that polynomiality is a desirable feature.
    Earlier (1953), von Neumann recognized the qualitative difference between polynomial
    and exponential algorithms. The idea of classifying problems according to polynomial
    and exponential time profoundly changed the way people thought about computational
    problems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序员对计算的经验增加，很明显多项式时间算法是有用的，而指数时间算法则不是。在一篇非常有影响力的论文中，Jack Edmonds将多项式时间算法称为“好算法”，并认为多项式时间是有效计算的一个很好的替代。Kurt
    Godel在1956年给冯·诺伊曼写了一封[信（第9页）](http://www.cs.berkeley.edu/~luca/cs172/sipser92history.pdf)，其中包含了多项式性是一个可取的特征的（隐含）概念。早在1953年，冯·诺伊曼就认识到了多项式和指数算法之间的定性差异。根据多项式和指数时间对问题进行分类的想法深刻地改变了人们对计算问题的看法。
- en: NP.
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NP.
- en: Informally we define a *search problem* as a computational problem where we
    are looking for a solution among a (potentially huge) number of possibilities,
    but such that when we find a solution, we can easily check that it solves our
    problem. Given an instance I of a *search problem* (some input data specifying
    the problem), our goal is to find a solution S (an entity that meets some pre-specified
    criterion) or report that no such solution exists. To be a search problem, we
    require that it be easy to *check* that S is indeed a solution. By easy, we mean
    polynomial-time in the size of the input I. The complexity class *NP* is the set
    of all search problems. Here are a few examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，我们将*搜索问题*定义为一个计算问题，我们在（可能非常庞大的）可能性中寻找一个解，但是当我们找到一个解时，我们可以轻松地检查它是否解决了我们的问题。给定*搜索问题*的一个实例
    I（指定问题的一些输入数据），我们的目标是找到���个解 S（满足一些预先指定标准的实体）或报告不存在这样的解。为了成为搜索问题，我们要求检查 S 是否确实是一个解是容易的。这里的“容易”是指在输入
    I 的大小的多项式时间内。复杂度类*NP*是所有搜索问题的集合。以下是一些示例。
- en: '*Linear systems of equations.* Given a system of linear equations Ax = b, find
    a solution x that satisfies the equations (if one exists). The problem is in NP
    because if we are given a purported solution x, we can check that Ax = b by plugging
    in x and verifying each equation.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性方程组.* 给定一个线性方程组 Ax = b，找到一个满足方程的解 x（如果存在的话）。这个问题属于 NP 类，因为如果我们得到一个假设的解 x，我们可以通过将
    x 代入并验证每个方程来检查 Ax = b。'
- en: '*Linear programming.* Given a system of linear inequalities Ax ≤ b, find a
    solution x that satisfies the inequalities (if one exists). The problem is in
    NP because if we are given a purported solution x, we can check that Ax ≤ b by
    plugging in x and verifying each inequality.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性规划.* 给定一个线性不等式系统 Ax ≤ b，找到一个满足不等式的解 x（如果存在的话）。这个问题属于 NP 类，因为如果我们得到一个假设的解
    x，我们可以通过将 x 代入并验证每个不等式来检查 Ax ≤ b。'
- en: '*Integer linear programming.* Given a system of linear inequalities Ax ≤ b,
    find a binary (0/1) solution x that satisfies the inequalities (if one exists).
    The problem is in NP because if we are given a purported solution x, we can check
    that Ax ≤ b by plugging in x and verifying each inequality.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数线性规划.* 给定一个线性不等式系统 Ax ≤ b，找到一个满足不等式的二进制（0/1）解 x（如果存在的话）。这个问题属于 NP 类，因为如果我们得到一个假设的解
    x，我们可以通过将 x 代入并验证每个不等式来检查 Ax ≤ b。'
- en: While it is easy to check a proposed solution to all three problems, how difficult
    is it to *find* a solution from scratch?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然检查对所有三个问题的提议解是容易的，但是从头开始*找到*一个解有多困难呢？
- en: 'Remark: our definition of NP is slightly non-standard. Historically, complexity
    classes were defined in terms of decision problems (yes-no problems). For example,
    given a matrix A and a vector b, does there exist a solution x such that Ax =
    b?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：我们对 NP 的定义略有不同。从历史上看，复杂度类是根据决策问题（是-否问题）来定义的。例如，给定一个矩阵 A 和一个向量 b，是否存在一个解 x
    使得 Ax = b？
- en: P.
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: P.
- en: 'The complexity class P is the set of all search problems solvable in polynomial-time
    (on a deterministic Turing machine). As before, we define P in terms of search
    problems (instead of decision problems). It captures most of the problems that
    we can solve in practice on real machines. We list a few examples below:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度类 P 是所有可以在多项式时间内解决的搜索问题的集合（在确定性图灵机上）。与以前一样，我们根据搜索问题（而不是决策问题）定义 P。它涵盖了我们在实际机器上可以解决的大多数问题。以下是一些示例：
- en: '| Problem | Description | Algorithm | Instance | Solution |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 描述 | 算法 | 实例 | 解决方案 |'
- en: '| GCD | Find the greatest common divisor of two integers x and y. | Euclid''s
    algorithm (Euclid, 300 BCE) | 34, 51 | 17 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 最大公约数 | 找到两个整数 x 和 y 的最大公约数。 | 欧几里得算法（欧几里得，公元前300年） | 34, 51 | 17 |'
- en: '| STCONN | Given a graph G and two vertices s and t, find a path from s to
    t. | BFS or DFS (Theseus) |  |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| STCONN | 给定图 G 和两个顶点 s 和 t，找到从 s 到 t 的路径。 | BFS 或 DFS（忒修斯） |  |  |'
- en: '| SORT | Find permutation that puts elements in ascending order. | Mergesort
    (von Neumann, 1945) | 2.3 8.5 1.2 9.1 2.2 0.3 | 5 2 4 0 1 3 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 排序 | 找到将元素按升序排列的排列。 | 归并排序（冯·诺伊曼，1945） | 2.3 8.5 1.2 9.1 2.2 0.3 | 5 2 4
    0 1 3 |'
- en: '| PLANARITY | Given a graph G, draw it in the plane so that no two edges cross.
    | (Hopcroft-Tarjan, 1974) |  |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| PLANARITY | 给定一个图 G，在平面上绘制它，使得没有两条边相交。 | （Hopcroft-Tarjan，1974） |  |  |'
- en: '| LSOLVE | Given a matrix A and a vector b, find a vector x such Ax = b. |
    Gaussian elimination (Edmonds, 1967) | x+y=1 2x+4y=3 | x = 1/2 y = 1/2 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| LSOLVE | 给定矩阵 A 和向量 b，找到一个向量 x 使得 Ax = b。 | 高斯消元法（Edmonds，1967） | x+y=1 2x+4y=3
    | x = 1/2 y = 1/2 |'
- en: '| LP | Given a matrix A and a vector b, find a vector x such that Ax ≤ b? |
    Ellipsoid algorithm (Khachiyan, 1979) | x+y≤1 2x+4y≤3 | x = 0 y = 0 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| LP | 给定一个矩阵 A 和一个向量 b，找到一个向量 x 使得 Ax ≤ b？ | 椭球算法（Khachiyan，1979） | x+y≤1
    2x+4y≤3 | x = 0 y = 0 |'
- en: '| DIOPHANTINE | Given a (sparse) polynomial of one variable with integer coefficients,
    find an integral root? | (Smale et. al, 1999) | x⁵ - 32 | x = 2 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 丢番图方程 | 给定一个具有整数系数的（稀疏）一元多项式，找到一个整数根？ | （Smale等，1999） | x⁵ - 32 | x = 2 |'
- en: Extended Church-Turing Thesis.
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展的图灵-丘奇论题。
- en: 'In the mid 1960s Cobham and Edmonds independently observed that the set of
    problems solvable in a polynomial number of steps remains invariant over a very
    wide range of computational models, from deterministic Turing machines to RAM
    machines. The extended Church-Turing thesis asserts that the Turing machine is
    as efficient as any physical computing device. That is, P is the set of search
    problems solvable in polynomial-time *in this universe*. If some piece of hardware
    solves a problem of size N in time T(N), the extended Church-Turing thesis asserts
    that a deterministic Turing machine can do it in time T(N)^k for some fixed constant
    k, where k depends on the particular problem. Andy Yao expresses the broad implications
    of this thesis:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在1960年代中期，Cobham和Edmonds独立观察到，在多种计算模型中，从确定性图灵机到RAM机，可以在多项式步骤内解决的问题集保持不变。扩展的图灵-丘奇论题断言图灵机与任何物理计算设备一样有效。也就是说，P是在*这个宇宙*中可以在多项式时间内解决的搜索问题集。如果某个硬件解决了大小为N的问题需要时间T(N)，扩展的图灵-丘奇论题断言确定性图灵机可以在时间T(N)^k内解决，其中k是某个固定常数，k取决于特定问题。Andy
    Yao表达了这个论题的广泛影响：
- en: They imply that at least in principle, to make future computers more efficient,
    one only needs to focus on improving the implementation technology of present-day
    computer designs.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们暗示至少原则上，要使未来的计算机更有效，只需要专注于改进现代计算机设计的实现技术。
- en: In other words, any *reasonable* model of computation can be efficiently simulated
    on a (probabilistic) Turing machine. The extended Church-Turing thesis is true
    for all known physical general purpose computers. For random access machines (e.g.,
    your PC or Mac) the constant k = 2\. So, for example, if a random access machine
    can perform a computation in time N^(3/2), then a Turing machine can do the same
    computation in time N³.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，任何*合理*的计算模型都可以在（概率性）图灵机上进行有效模拟。已知的所有物理通用计算机都符合扩展的图灵-丘奇论题。对于随机访问机器（例如您的PC或Mac），常数k
    = 2。因此，例如，如果随机访问机器可以在时间N^(3/2)内执行计算，则图灵机可以在时间N³内执行相同的计算。
- en: Does P = NP?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: P = NP吗？
- en: One of the most profound scientific questions of our time is whether [P = NP](http://en.wikipedia.org/wiki/Complexity_classes_P_and_NP).
    That is, can all search problems be solved in polynomial time? Clay Foundation
    offers a [1 million dollar millennium prize](http://www.claymath.org/millennium/)
    for solving it. Here are some speculations on [when the question will be resolved](http://www.cs.umd.edu/~gasarch/papers/poll.ps).
    The overwhelming consensus is that P != NP, but nobody has been able to prove
    it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个时代最深刻的科学问题之一是[P = NP](http://en.wikipedia.org/wiki/Complexity_classes_P_and_NP)。也就是说，所有搜索问题是否都可以在多项式时间内解决？Clay基金会为解决这个问题提供了[100万美元的千禧奖](http://www.claymath.org/millennium/)。以下是一些关于[何时解决这个问题的猜测](http://www.cs.umd.edu/~gasarch/papers/poll.ps)。压倒性的共识是P
    != NP，但没有人能够证明它。
- en: '[Video](http://youtube.com/watch?v=t_bO9LilNpE) of Homer Simpson pontificating
    over P = NP, with accompanying music Erased by Paradise Lost.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[视频](http://youtube.com/watch?v=t_bO9LilNpE)中荷马·辛普森对P = NP进行演讲，伴随着《失乐园》的音乐。'
- en: Godel's letter to von Neumann anticipated the P = NP question. He recognized
    that if P = NP (satisfiability is in P), it "would have consequences of the greatest
    importance" since then "the mental work of a mathematician concerning Yes-or-No
    questions could be completely replaced by a machine." He asked for which combinatorial
    problems was there a more efficient alternative to exhaustive search.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Godel写给von Neumann的信预见了P = NP问题。他认识到如果P = NP（可满足性在P中），那么“将会产生最重要的后果”，因为“数学家关于是或否问题的思维工作可以完全被机器取代”。他询问哪些组合问题有更有效的替代方案来避免穷举搜索。
- en: Reduction.
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化。
- en: Reduction or simulation is a powerful idea in computer science.... Problem-solving
    framework that transforms a problem X into a simpler problem Y such that it is
    easy to deduce a solution to the original problem X based on the solution for
    Y.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 简化或模拟是计算机科学中的一个强大概念……将问题X转化为更简单的问题Y的问题解决框架，以便根据对Y问题的解决方案推断出原始问题X的解决方案。
- en: 'Eric Alander - "Reduction provides an abstraction. If A efficiently reduces
    to B and B efficiently reduces to A, then A and B are equivalent in a meaningful
    sense: they are two different ways to look at the same problem. Instead of infinitely
    many computational problems, we are left with a smaller number of classes of equivalent
    problems. Nothing had prepared the computing community for the shocking insight
    that there are really just a handful of fundamentally different computational
    problems that people want to solve." Partitions natural computational problems
    into meaningful groups based on resource bounds.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Eric Alander - “简化提供了一种抽象。如果A有效地简化为B，而B有效地简化为A，那么A和B在某种意义上是等价的：它们是解决同一问题的两种不同方式。我们不再有无限多的计算问题，而是留下了更少数量的等价问题类。没有什么能够让计算社区为这个惊人的发现做好准备，即人们真正想要解决的基本不同的计算问题只有几个。”基于资源限制将自然计算问题划分为有意义的组。
- en: NP-completeness.
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NP完全性。
- en: 'Informally, NP-complete problems are the "hardest" problems in NP; they are
    the ones most likely to not be in P. Define: a problem is *NP-complete* if (i)
    it is in NP and (ii) every problem in NP polynomial reduces to it. Defining the
    concept of NP-completeness does not mean that such problems exist. In fact, the
    existence of NP-complete problems is an amazing thing. We cannot prove a problem
    is NP-complete by presenting a reduction from each NP problem since there are
    infinitely many of them. In the 1960s, Cook and Levin proved that SAT is NP-complete.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地说，NP完全问题是NP中“最难”的问题；它们最有可能不在P中。定义：如果一个问题（i）在NP中且（ii）每个NP问题都可以多项式归约到它，则问题是*NP完全*的。定义NP完全性的概念并不意味着这样的问题存在。事实上，NP完全问题的存在是一件令人惊奇的事情。我们无法通过从每个NP问题呈现归约来证明一个问题是NP完全的，因为它们有无限多个。在1960年代，Cook和Levin证明了SAT是NP完全的。
- en: 'This is an example of universality: if we can solve any NP-complete, then we
    can solve any problem in NP. Unique scientific discovery giving common explanation
    to all sorts of problems. It is even more amazing that there exist "natural" problems
    that are NP-complete.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是普遍性的一个例子：如果我们可以解决任何NP完全问题，那么我们就可以解���NP中的任何问题。独特的科学发现为各种问题提供了共同的解释。更令人惊奇的是存在“自然”的NP完全问题。
- en: The impact of NP-completeness on the natural sciences has been undeniable. Once
    the first NP-complete problems were discovered, intractability "spread like a
    shockwave through the space of problems", first in computer science, and then
    to other scientific disciplines. Papadimitriou lists 20 diverse scientific disciplines
    that were coping with internal questions. Ultimately, scientists discovered their
    inherent complexity after realizing that their core problems were NP-complete.
    NP-completeness is mentioned as a keyword in 6,000 scientific papers per year.
    "Captures vast domains of computational, scientific, mathematical endeavors, and
    seems to roughly delimit what mathematicians and scientists had been aspiring
    to compute feasibly." [Papadimitriou] Few scientific theories have had such a
    breadth and depth of influence.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: NP完全性对自然科学的影响是不可否认的。一旦第一个NP完全问题被发现，难以解决性质就像“冲击波一样在问题空间中蔓延”，首先在计算机科学中，然后传播到其他科学学科。Papadimitriou列出了20个不同的科学学科正在应对内部问题。最终，科学家们在意识到他们的核心问题是NP完全后发现了它们固有的复杂性。每年有6000篇科学论文提到NP完全性作为关键词。“涵盖了计算、科学、数学努力的广泛领域，并似乎粗略地界定了数学家和科学家一直渴望可行计算的范围。”
    [Papadimitriou] 很少有科学理论有如此广泛和深远的影响。
- en: '**Some NP-complete problems.** Since the discovery that SAT is NP-complete,
    tens of thousands of problems have been identified as NP-complete. In 1972, Karp
    showed that 21 of the most infamous problem s in discrete mathematics were [NP-complete](http://en.wikipedia.org/wiki/Karp%27s_21_NP-complete_problems),
    including `Tsp`, `Knapsack`, `3Color`, and `Clique`. The failure of scientists
    to find an efficient algorithm for these 21 problems, despite being unaware that
    they were NP-complete, was among the first evidence suggesting that P != NP. Below
    we list a sampling of some NP-complete problems. Here are some more [NP-complete
    problems](http://en.wikipedia.org/wiki/List_of_NP-complete_problems). This is
    only meant to illustrate their diversity and pervasiveness.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些NP完全问题**。自从发现SAT是NP完全以来，已经确定了成千上万个问题是NP完全的。1972年，Karp表明离散数学中最臭名昭著的21个问题是[NP完全的](http://en.wikipedia.org/wiki/Karp%27s_21_NP-complete_problems)，包括`Tsp`、`Knapsack`、`3Color`和`Clique`。科学家们未能为这21个问题找到有效算法，尽管他们不知道这些问题是NP完全的，这是最早表明P
    != NP的证据之一。以下是一些NP完全问题的示例。这里还有一些[NP完全问题](http://en.wikipedia.org/wiki/List_of_NP-complete_problems)。这只是为了说明它们的多样性和普遍性。'
- en: '*Bin Packing.* You have n items and m bins. Item i weighs w[i] pounds. Each
    bin can hold at most W pounds. Can you pack all n items into the m bins without
    violating the given weight limit?'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*装箱问题*。你有n个物品和m个箱子。第i个物品重w[i]磅。每个箱子最多可以容纳W磅。你能否将所有n个物品装入m个箱子而不违反给定的重量限制？'
- en: 'This problem has many industrial applications. For example, UPS may need to
    ship a large number of packages (items) from one distribution center to another.
    It wants to put them into trucks (bins), and use as few trucks as possible. Other
    NP-complete variants allow volume requirements: each 3-dimensional package takes
    up space and you also have to worry about arranging the packages within the truck.'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个问题有许多工业应用。例如，UPS可能需要从一个配送中心将大量包裹（物品）运送到另一个中心。它希望将它们放入卡车（箱子）中，并尽可能少地使用卡车。其他NP完全的变体允许体积要求：每个三维包裹占用空间，你还必须担心如何在卡车内摆放包裹。
- en: '*Knapsack*. You have a set of n items. Item i weighs w[i] pounds and has benefit
    b[i]. Can you select a subset of the items that have total weight less than or
    equal to W and total benefit greater than or equal to B? For example, when you
    go camping, you must select items to bring based on their weight and utility.
    Or, suppose you are burglarizing a home and can only carry W pounds of loot in
    your knapsack. Each item i weighs w[i] pounds has a street value of b[i] dollars.
    Which items should you steal?'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*背包问题*。你有一组n个物品。第i个物品重w[i]磅，具有收益b[i]。你能否选择物品的一个子集，使得总重量小于或等于W且总利益大于或等于B？例如，当你去露营时，必须根据它们的重量和效用选择要带的物品。或者，假设你正在入室行窃，只能在你的背包中携带W磅的赃物。每个物品i重w[i]磅，有b[i]美元的街头价值。你应该偷哪些物品？'
- en: '*Subset Sum*. Given n integers does there exists a subset of them that sum
    exactly to B? For example, suppose the integers are {4, 5, 8, 13, 15, 24, 33}.
    If B = 36 then the answer is yes (and 4, 8, 24 is a certificate). If B = 14 the
    answer is no.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*子集和*。给定n个整数，是否存在它们的一个子集，其和恰好为B？例如，假设整数是{4, 5, 8, 13, 15, 24, 33}。如果B = 36，则答案是肯定的（4,
    8, 24是一个证书）。如果B = 14，则答案是否定的。'
- en: '*Partition.* Given n integers, can you divide them into two subsets so that
    each subset sums to the same number? For example, suppose the integers are {4,
    5, 8, 13, 15, 24, 33}. Then the answer is `yes`, and {5, 13, 33} is a certificate.
    Load balancing for dual processors.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*划分*。给定 n 个整数，你能将它们划分为两个子集，使得每个子集的和相等吗？例如，假设整数是 {4, 5, 8, 13, 15, 24, 33}。那么答案是`yes`，{5,
    13, 33}是一个证书。双处理器的负载平衡。'
- en: '*Integer linear programming.* Given an integer matrix A and an integer vector
    b, does there exist an integer vector x such that Ax ≤ b? This is a central problem
    in operations research since many optimization problems can be formulated in this
    way. Note the contrast to the linear programming problem presented above where
    we are looking for a *rational* vector instead of an *integer* vector. The line
    between problems which are tractable and problems which are intractable can be
    very subtle.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数线性规划*。给定一个整数矩阵 A 和一个整数向量 b，是否存在一个整数向量 x 使得 Ax ≤ b？这是运筹学中的一个核心问题，因为许多优化问题可以用这种方式表达。请注意与上面提出的线性规划问题形成对比，我们在这里寻找的是一个*有理*向量而不是一个*整数*向量。可解问题和不可解问题之间的界限可能非常微妙。'
- en: '*SAT.* Given n Boolean variables x[1], x[2], ..., x[N] and a logical formula,
    is there an assignment of truth variables that makes the formula *satisfiable*,
    i.e., true? For example, suppose the formula is'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SAT.* 给定 n 个布尔变量 x[1], x[2], ..., x[N] 和一个逻辑公式，是否存在一种真值赋值使得该公式是*可满足*的，即为真？例如，假设公式是'
- en: (x[1]' + x[2] + x[3]) (x[1] + x[2]' + x[3]) (x[2] + x[3]) (x[1]' + x[2]' + x[3]')
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (x[1]' + x[2] + x[3]) (x[1] + x[2]' + x[3]) (x[2] + x[3]) (x[1]' + x[2]' + x[3]')
- en: Then, the answer is yes and (x[1], x[2], x[3]) = (true, true, false) is a certificate.
    Many applications to electronic design automation (EDA), including testing and
    verification, logic synthesis, FPGA routing, and path delay analysis. Application
    to AI, including knowledge base deduction and automatic theorem proving.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，答案是 yes，(x[1], x[2], x[3]) = (true, true, false) 是一个证书。在电子设计自动化（EDA）中有许多应用，包括测试和验证、逻辑综合、FPGA
    ��由和路径延迟分析。在人工智能中的应用，包括知识库推理和自动定理证明。
- en: 'Exercise: given two circuits C1 and C2, design a new circuit C such that some
    setting of input values makes C output true if and only if C1 and C2 are equivalent.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：给定两个电路 C1 和 C2，设计一个新电路 C，使得某些输入值的设置使得 C 输出为真当且仅当 C1 和 C2 是等价的。
- en: '*3-SAT.* Given n Boolean variables x[1], x[2], ..., x[N] and a logical formula
    in conjunction normal form (product-of-sums) with exactly 3 distinct literals
    per clause, is there an assignment of truth variables that makes the formula satisfiable?'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3-SAT.* 给定 n 个布尔变量 x[1], x[2], ..., x[N] 和一个逻辑公式（合取范式），每个子句恰好有 3 个不同的文字，是否存在一种真值赋值使得该公式是可满足的？'
- en: '*Clique*. Given n people and a list of pairwise friendships. Is there a group
    or *clique* of k people such that every possible pair of people within the group
    are friends? It is convenient to draw the *friendship graph*, where we include
    a node for each person and an edge connecting each pair of friends. In the following
    example with n = 11 and k = 4, the answer is `yes`, and {2, 4, 8, 9} is a certificate.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*团*. 给定 n 个人和一组两两友谊关系。是否存在一个由 k 个人组成的群体或*团*，使得群体内每对人之间都是朋友？方便起见，我们可以绘制*友谊图*，其中我们为每个人包括一个节点，并连接每对朋友之间的边。在下面的例子中，当
    n = 11 且 k = 4 时，答案是`yes`，{2, 4, 8, 9}是一个证书。'
- en: '*Longest path*. Given a set of nodes and pairwise distances between nodes,
    does there exists a simple path of length at least L connecting some pair of nodes?'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最长路径*。给定一组节点和节点之间的两两距离，是否存在一条长度至少为 L 的简单路径连接某对节点？'
- en: '*Machine Scheduling*. Your goal is to process n jobs on m machines. For simplicity,
    assume each machine can process any one job in 1 time unit. Also, there can be
    *precedence constraints*: perhaps job j must finish before job k can start. Can
    you schedule all of the jobs to finish in L time units?'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*机器调度*。你的目标是在 m 台机器上处理 n 个作业。为简单起见，假设每台机器可以在 1 个时间单位内处理任何一个作业。此外，可能存在*优先约束*：也许作业
    j 必须在作业 k 开始之前完成。你能安排所有作业在 L 个时间单位内完成吗？'
- en: 'Scheduling problems have a huge number of applications. Jobs and machines can
    be quite abstract: to graduate Princeton you need to take n different courses,
    but are unwilling to take more than m courses in any one semester. Also, many
    courses have prerequisites (you can''t take COS 226 or 217 before taking 126,
    but it is fine to take 226 and 217 at the same time). Can you graduate in L semesters?'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调度问题有大量的应用。工作和机器可以是相当抽象的：为了毕业普林斯顿，你需要修完 n 门不同的课程，但不愿意在任何一个学期修超过 m 门课程。此外，许多课程有先修课程（你不能在修
    126 之前修 COS 226 或 217，但可以同时修 226 和 217）。你能在 L 个学期内毕业吗？
- en: '*Shortest Common Superstring*. Given the genetic alphabet { a, t, g, c } and
    N DNA fragments (e.g., ttt, atggtg, gatgg, tgat, atttg) is there a DNA sequence
    with K or fewer characters that contains every DNA fragment? Suppose K = 11 in
    the above example; then the answer is `yes` and `atttgatggtg` is a certificate.
    Applications to computational biology.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最短公共超字符串*。给定基因字母表 { a, t, g, c } 和 N 个 DNA 片段（例如，ttt, atggtg, gatgg, tgat,
    atttg），是否存在一个长度不超过 K 的 DNA 序列，其中包含每个 DNA 片段？假设在上面的例子中 K = 11；那么答案是`yes`，而`atttgatggtg`是一个证书。应用于计算生物学。'
- en: '*Protein folding.* Proteins in organism *fold* in three dimensional dimensional
    space in a very specific way, to their *native state*. This geometric pattern
    determines the behavior and function of a protein. One of the most widely used
    folding models is the two dimensional hydrophilic-hydrophobic (H-P) model. In
    this model, a protein is a sequence of 0s and 1s, and the problem is to embed
    it into a 2-d lattice such that the number of pairs of adjacent 1s in the lattice,
    but not in the sequence (its energy), is minimized. For example, the sequence
    011001001110010 is embedded in the figure below in such a way that there are 5
    new adjacent pairs of 1s (denoted by asterisks).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*蛋白质折叠。* 生物体内的蛋白质以非常特定的方式在三维空间中 *折叠* 到它们的 *天然状态*。这种几何模式决定了蛋白质的行为和功能。最广泛使用的折叠模型之一是二维亲水-疏水（H-P）模型。在这个模型中，蛋白质是一个由
    0 和 1 组成的序列，问题是将其嵌入到一个 2-d 格点中，使得格点中相邻的 1 对的数量，但不在序列中（它的能量），被最小化。例如，序列 011001001110010
    被嵌入到下面的图中，以便有 5 对新的相邻的 1（用星号表示）。'
- en: '[PRE0]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Minimizing the H-P energy of a protein is NP-hard. (Papadimitriou, et al.) It
    is well accept by biologists that proteins fold to minimize their energies. A
    version of Levinthal's paradox asks how it is possible that proteins are able
    to efficiently solve apparently intractable problems.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最小化蛋白质的 H-P 能量是 NP 难题。（Papadimitriou 等人）生物学家普遍认为蛋白质会折叠以最小化它们的能量。Levinthal 悖论的一个版本问的是蛋白质如何能够有效地解决表面上看起来棘手的问题。
- en: '*Integration.* Given integers a[1], a[2], ..., a[N], does the following integral
    equal 0?'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*积分。* 给定整数 a[1]、a[2]、...、a[N]，以下积分是否等于 0？'
- en: '![Integration](../Images/d295b80320355f57152540b82f6c8881.png)'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![积分](../Images/d295b80320355f57152540b82f6c8881.png)'
- en: If you see this integral in your next Physics course, you should not expect
    to be able to solve it. This should not come as a big surprise because in Section
    7.4 we consider a version of integration that is undecidable.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在下一门物理课程中看到这个积分，你不应该期望能够解决它。这应该不会让人感到惊讶，因为在第 7.4 节中，我们考虑了一个不可判定的积分版本。
- en: '*Crossword puzzle*. Given an integer N, and a list of valid words, is it possible
    to assign letters to the cells of an N-by-N grid so that all horizontal and vertical
    words are valid? No easier if some of the squares are black as in a crossword
    puzzle.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*填字游戏。* 给定一个整数 N 和一个有效单词列表，是否可能为一个 N×N 网格的单元格分配字母，以便所有水平和垂直单词都是有效的？如果一些方格是黑色的，就像填字游戏中一样，那么问题并不会更容易。'
- en: '*Theorem.* Given a purported theorem (such as one for the Riemann Hypothesis),
    can you prove it is true using at most n symbols in some formal system such as
    Zermelo-Fraenkel set theory?'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定理。* 给定��个所谓的定理（比如黎曼猜想），你能否在某个形式系统（如 Zermelo-Fraenkel 集合论）中最多使用 n 个符号证明它是真实的？'
- en: '*Tetris.*'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*俄罗斯方块。*'
- en: '*Minesweeper.*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*扫雷。*'
- en: '*Regular expressions.* Give two regular expressions over the unary alphabet
    { 1 }, do they represent different languages? Give two NFAs, do they represent
    different languages? It may not be apparent that either problem is even decidable
    since we don''t have an obvious bound on the size of the smallest string that
    is in one language but not the other. [Note that the corresponding inequivalence
    problem for DFAs is polynomial solvable.] The reason why we phrase the problem
    as inequivalence instead of equivalence is that it is easy to check that the two
    entities are non-equivalent by demonstrating a string s. In fact, if the two languages
    are different, then the smallest string is polynomial in the size of the input.
    Thus, we can use the efficient algorithms from Section 7.xyz to check whether
    s is recognized by an RE or accepted by an NFA. However, to argue that two REs
    are equivalent, we would need an argument that guarantees that all strings in
    one are in the other, and vice versa. [It is possible to devise an (exponential)
    algorithm to test whether two REs or NFAs are equivalent, although this should
    not be obvious.]'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式。* 给定两个在一元字母表 { 1 } 上的正则表达式，它们表示不同的语言吗？给定两个 NFA，它们表示不同的语言吗？由于我们没有一个明显的界限来确定一个语言中最小字符串的大小，而另一个语言中没有，因此甚至可能无法确定这两个问题是否可判定。[请注意，对于
    DFA 的对应不等价问题是多项式可解的。] 我们将问题表述为不等价而不是等价的原因是，通过展示一个字符串 s，很容易检查这两个实体是否不等价。实际上，如果这两个语言不同，那么最小字符串在输入大小的多项式中。因此，我们可以使用第
    7.xyz 节中的高效算法来检查 s 是否被 RE 识别或被 NFA 接受。然而，要证明两个 RE 是等价的，我们需要一个保证一个语言中的所有字符串都在另一个语言中，反之亦然的论证。[可以设计一个（指数级的）算法来测试两个
    RE 或 NFA 是否等价，尽管这并不明显。]'
- en: '*Lemmings.* Is it possible to guide a tribe of green-haired lemming creatures
    to safety in a level of the game Lemmings?'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旅鼠。* 在游戏旅鼠的一个关卡中，是否可能引导一群绿发旅鼠生物安全到达目的地？'
- en: '*Multinomial minimization over unit hypercube.* Given a multinomial of N variables,
    is the minimum <= C, assuming all variables are bounded between 0 and 1. Classic
    calculus problem: min f(x) = ax^2 + bx + c over [0, 1]. Derivative at x = ?? is
    0, but minimum occurs at boundary.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单位超立方体上的多项式最小化。* 给定 N 个变量的多项式，最小值是否 <= C，假设所有变量都在 0 和 1 之间。经典微积分问题：在 [0, 1]
    上，min f(x) = ax^2 + bx + c。在 x = ?? 处的导数为 0，但最小值出现在边界处。'
- en: '*Quadratic Diophantine equations.* Given positive integers a, b, and c, are
    there positive integers x and y such that ax² + by = c?'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二次丢番图方程。* 给定正整数 a、b 和 c，是否存在正整数 x 和 y，使得 ax² + by = c？'
- en: '*Knot theory.* Which knots on a 3-dimensional manifold bound a surface of genus
    ≤ g?'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结实论。* 在三维流形上，哪些结实边界的结实的表面的亏格 ≤ g？'
- en: '*Bounded Post Correspondence Problem.* Given a post correspondence problem
    with N cards and an integer K &le N, is there a solution that uses at most K cards?
    Recall it is undecidable if there is no limit on K.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有界的邮政对应问题。* 给定一个具有 N 张卡片的邮政对应问题和一个整数 K，是否存在一个使用最多 K 张卡片的解？如果 K 没有限制，那么问题是不可判定的。'
- en: '*Nash equilibria.* Cooperative game theory. Given a 2-player game, find a Nash
    equilibrium that maximizes the payoff to player 1. Do more than one NE exist?
    Is there a NE that is Pareto optimal? NE that maximizes social welfare.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*纳什均衡。* 合作博弈论。给定一个 2 人游戏，找到一个最大化玩家 1 收益的纳什均衡。是否存在多个 NE？是否存在 Pareto 最优 NE？最大化社会福利的
    NE。'
- en: '*Quadratic congruence.* Given positive integers a, b, and c, is there a positive
    integer x < c such that x² = a (mod b)?'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二次同余。* 给定正整数a、b和c，是否存在一个小于c的正整数x，使得x² = a (mod b)？'
- en: '*Ising model in 3d.* Simple mathematical model of phase transitions, e.g.,
    when water freezes or when cooling iron becomes magnetic. Computing lowest energy
    state is NP-hard. Solvable in polynomial time if graph is planar, but 3d lattice
    is nonplanar. Holy grail of statistical mechanics for 75 years before proved NP-hard.
    Establishing NP-completeness means that physicists won''t spend another 75 years
    attempting to solve the unsolvable.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*三维伊辛模型。* 相变的简单数学模型，例如，当水结冰或冷却铁变成磁性时。计算最低能量状态是NP难题。如果图是平面的，则可以在多项式时间内解决，但3D晶格是非平面的。在被证明为NP难题之前，统计力学的圣杯已经存在了75年。建立NP完全性意味着物理学家不会再花75年时间试图解决不可能解决的问题。'
- en: '*Bandwidth minimization*. Given an N-by-N matrix A and an integer B, is it
    possible to permute the rows and columns of A such that A[ij] = 0 if |i - j| >
    B. Useful for numerical linear algebra.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带宽最小化。* 给定一个N×N矩阵A和一个整数B，是否可以重新排列A的行和列，使得当|i - j| > B时，A[ij] = 0。对数值线性代数很有用。'
- en: '*Voting and social choice.* NP-hard for an individual to manipulate a voting
    scheme known as [single transferable vote](http://www.isye.gatech.edu/~jjb/papers/stv.pdf).
    NP-hard to determine who has won an election in a scheme seriously proposed by
    Lewis Carroll (Charles Dodgson) in 1876. In Carroll''s scheme, the winner is the
    candidate who with the fewest pairwise adjacent changes in voters'' preference
    rankings becomes the Condercet winner (a candidate who would beat all other candidates
    in a pairwise election). Shapley-Shubik voting power. Computing the [Kemeny optimal
    aggregation](http://www10.org/cdrom/papers/577/).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*投票和社会选择。* 对于个人来说，操纵称为[单次转移投票](http://www.isye.gatech.edu/~jjb/papers/stv.pdf)的投票方案是NP难的。在刘易斯·卡罗尔（查尔斯·道奇森）于1876年提出的方案中，确定谁赢得了选举是NP难的。在卡罗尔的方案中，获胜者是在选民偏好排名中进行最少配对相邻变化的候选人，成为康德塞特赢家（在两两选举中击败所有其他候选人的候选人）。夏普利-舒比克投票权。计算[Kemeny最优聚合](http://www10.org/cdrom/papers/577/)。'
- en: Coping with intractability.
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应对难以解决的问题。
- en: 'The theory of NP-completeness says that unless P = NP, there are some important
    problems for which we can''t create an algorithm that simultaneously achieves
    the following three properties:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: NP完全性理论表明，除非P = NP，否则有一些重要问题无法创建同时实现以下三个属性的算法：
- en: Guarantee to solve the problem in polynomial-time.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证在多项式时间内解决问题。
- en: Guarantee to solve the problem to optimality.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证解决问题到最优性。
- en: Guarantee to solve arbitrary instances of the problem.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证解决问题的任意实例。
- en: When we encounter an NP-complete problem, we must relax one of the three requirements.
    We will consider solutions to the TSP problem that relax one of the three goals.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到一个NP完全问题时，我们必须放宽三个要求中的一个。我们将考虑解决TSP问题的解决方案，这些解决方案放宽了三个目标中的一个。
- en: Complexity theory deals with worst-case behavior. This leaves open the possibility
    of designing algorithms that run quickly on some instances, but take a prohibitive
    amount of time on others. For example, [Chaff](http://www.princeton.edu/pr/pwb/01/0305/1b.shtml)
    is a program that can solve many real-world SAT instances with 10,000 variables.
    Remarkably, it was developed by two undergraduates at Princeton. The algorithm
    does not guarantee to run in polynomial time, but the instances we're interested
    in may be "easy."
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性理论处理最坏情况的行为。这留下了设计在某些实例上快速运行但在其他实例上需要大量时间的算法的可能性。例如，[Chaff](http://www.princeton.edu/pr/pwb/01/0305/1b.shtml)是一个可以解决许多具有10000个变量的实际SAT实例的程序。值得注意的是，它是由普林斯顿大学的两名本科生开发的。该算法不能保证在多项式时间内运行，但我们感兴趣的实例可能是“简单的”。
- en: 'Sometimes we may be willing to sacrifice the guarantee on finding the optimal
    solution. Many heuristic techniques (simulating annealing, genetic algorithms,
    Metropolis algorithm) have been designed to find "nearly optimal" solutions to
    the TSP problem. Sometimes it is even possible to prove how good the resulting
    solution will be. For example, Sanjeev Arora designed an *approximation algorithm*
    for the Euclidean TSP problem that guarantees to find a solution that costs at
    most, say 1%, above the optimum. Designing approximation algorithms is an active
    area of research. Unfortunately, there are also non-approximability results of
    the form: if you can find an approximation algorithm for problem X that guarantees
    to get within a factor of 2 of the optimum, then P = NP. Thus, designing approximation
    algorithms for some NP-complete problems is not possible.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能愿意牺牲找到最优解的保证。许多启发式技术（模拟退火、遗传算法、Metropolis算法）已被设计用于找到“几乎最优”的TSP问题解决方案。有时甚至可以证明最终解决方案的优劣。例如，Sanjeev
    Arora设计了一种用于欧几里德TSP问题的*近似算法*，保证找到的解决方案的成本最多比最优解高出1%。设计近似算法是一个活跃的研究领域。不幸的是，也存在一些无法近似的结果形式：如果你能找到一个问题X的近似算法，保证能够接近最优解的两倍，那么P
    = NP。因此，为一些NP完全问题设计近似算法是不可能的。
- en: If we are trying to solve a special class of TSP problems, e.g., where the points
    lie on the boundary of a circle or the vertices of an M-by-N lattice, then we
    can design efficient (and trivial) algorithms to solve the problem.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图解决一类特殊的TSP问题，例如，点位于圆的边界上或M×N晶格的顶点上，那么我们可以设计高效（且微不足道）的算法来解决问题。
- en: '**Exploiting intractability.** Having intractability problems is occasionally
    a good thing. In Section XYZ, we will exploit intractable problems to design cryptographic
    systems.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用难以解决性。** 有时遇到难以解决的问题是一件好事。在第XYZ节中，我们将利用难以解决的问题设计密码系统。'
- en: '**Between P and NP-complete.** Most natural problems in NP are now known to
    be in P or NP-complete. If P != NP, then there are provably some NP problems that
    are neither in P or NP-complete. Like "dark matter we have not developed means
    of observing." A few notable unclassified problems in the netherworld: factoring,
    and subgraph isomorphism.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**P 与 NP-complete 之间。** 现在已知大多数 NP 中的自然问题属于 P 或 NP-complete。如果 P != NP，则可以证明存在一些既不属于
    P 也不属于 NP-complete 的 NP 问题。就像“我们尚未开发出观察手段的暗物质”。在地下世界中有一些显著的未分类问题：因子分解和子图同构。'
- en: '*Factoring.* Given an integer, find its prime factorization. Best known algorithm
    is 2^O(n^1/3 polylog(n)) - number field sieve. Believed by experts not to be in
    P.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*因子分解。* 给定一个整数，找到其素因子分解。已知的最佳算法是 2^O(n^1/3 polylog(n)) - 数域筛法。专家认为不太可能属于 P。'
- en: '*Precedence constrained 3-processor scheduling.* Given a set of unit length
    tasks, and a precedence order, find the shortest schedule on 3 parallel machines.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优先约束 3 处理器调度。* 给定一组单位长度任务和一个优先顺序，找到 3 台并行机器上的最短调度。'
- en: '*Turnpike problem.* Given N(N-1)/2 positive numbers (not necessarily distinct),
    does there exist a set of N points on the line such that these numbers are the
    pairwise distances of the N points. Intuition: points are exits on I-95\. Problem
    first arose in 1930s in the context of x-ray crystallography. Also known as the
    *partial digest problem* in molecular biology.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转角石问题。* 给定 N(N-1)/2 个正数（不一定不同），是否存在一组 N 个点在直线上，使得这些数字是这些 N 个点的两两距离。直觉：点是 I-95
    上的出口。问题最早在 1930 年代出现在 X 射线晶体学的背景中。在分子生物学中也被称为*部分消化问题*。'
- en: '*Boolean formula dualization.* Given a monotone CNF formula and a monotone
    DNF formula, are they equivalent? (a + b)(c + d) = ac + ad + bc + bd. Naively
    applying De Morgan''s law leads to exponential algorithm because of redundancy.
    Best algorithm O(n^(log n / log log n)).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布尔公式对偶化。* 给定一个单调 CNF 公式和一个单调 DNF 公式，它们是否等价？(a + b)(c + d) = ac + ad + bc +
    bd。直接应用德摩根定律会导致指数级算法，因为存在冗余。最佳算法为 O(n^(log n / log log n))。'
- en: '*Stochastic games.* White, Black and Nature alternate moving a token on the
    edges of a directed graph, starting at the start state s. White''s goal is to
    move the token to a goal state t. Black''s goal is to prevent the token from ever
    reaching t. Nature moves the tokens at random. Given a digraph, a start state
    s, and a goal state t,, does White have a strategy which will make the token reach
    t with probability ≥ 1/2? Problem is in NP intersect co-NP, but not known to be
    in P. Believed to be in P, we just haven''t found a polynomial-time algorithm.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机游戏。* 白色、黑色和自然轮流在有向图的边上移动一个令牌，从起始状态 s 开始。白色的目标是将令牌移动到目标状态 t。黑色的目标是阻止令牌到达
    t。自然以随机方式移动令牌。给定一个有向图、一个起始状态 s 和一个目标状态 t，白色是否有一种策略使得令牌到达 t 的概率 ≥ 1/2？问题在 NP 交
    co-NP 中，但尚不知道是否在 P 中。人们相信它在 P 中，只是我���尚未找到多项式时间算法。'
- en: Other complexity classes.
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他复杂度类。
- en: The complexity classes P, NP, and NP-complete are the three most famous complexity
    classes. Scott Aaronson's website [The Complexity Zoo]( http://www.complexityzoo.com)
    contains a comprehensive list of other complexity classes that are useful in classifying
    problems according to their computational resources (time, space, parallelizability,
    use of randomness, quantum computing). We describe a few of the most important
    ones below.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度类 P、NP 和 NP-complete 是三个最著名的复杂度类。Scott Aaronson 的网站[The Complexity Zoo](http://www.complexityzoo.com)包含了其他复杂度类的全面列表，这些类对根据计算资源（时间、空间、可并行性、随机性使用、量子计算）对问题进行分类非常有用。我们以下简要描述一些最重要的类。
- en: '*PSPACE.* The complexity class PSPACE = problems solvable by a Turing machine
    using polynomial space. PSPACE-complete = in PSPACE and every other problem in
    PSPACE can be reduced to it in polynomial time.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PSPACE。* 复杂度类 PSPACE = 可由图灵机使用多项式空间解决的问题。PSPACE-complete = 在 PSPACE 中，且 PSPACE
    中的每个其他问题都可以在多项式时间内归约到它。'
- en: Here is a complexity version of the halting problem. Given a Turing machine
    that is limited to n tape cells, does it halt in at most k steps? The problem
    is PSPACE-complete, where n is encoded in unary. This means that unless P = PSPACE,
    we are unlikely to be able to tell whether a given program, running on a computer
    with n units of memory, will terminate before k steps substantially faster than
    the trivial method of running it for k steps and seeing what happens.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是停机问题的一个复杂性版本。给定一个限制在 n 个磁带单元上的图灵机，在最多 k 步内是否会停机？问题是 PSPACE-complete，其中 n 以一进制编码。这意味着除非
    P = PSPACE，否则我们不太可能能够判断给定程序在具有 n 个内存单元的计算机上在 k 步之前是否终止，这比运行它 k 步并查看结果的简单方法要快得多。
- en: 'Bodlaender: given a graph with vertices 1, ..., N, two players alternate in
    labeling the vertices red, green, or blue. The first player to label a vertex
    the same color as one of its neighbors loses. Determining whether there is a winning
    strategy for the first player is PSPACE-complete.'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bodlaender：给定一个带有顶点 1, ..., N 的图，两名玩家轮流为顶点标记红色、绿色或蓝色。首个将顶点标记为与其邻居相同颜色的玩家失败。确定是否有第一个玩家的获胜策略是
    PSPACE-complete。
- en: Versions of many conventional games are provably intractable; this partially
    explains their appeal. Also natural generalizations of Othello, Hex, Geography,
    Shanghai, Rush Hour, go-moku, Instant Insanity, and Sokoban are PSPACE-complete.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多传统游戏的变体被证明是棘手的；这在一定程度上解释了它们的吸引力。此外，黑白棋、六角棋、地理游戏、上海、交通堵塞、五子棋、瞬间疯狂和推箱子的自然推广都是
    PSPACE-complete。
- en: '[Eppstein''s list of hard games](http://www.ics.uci.edu/~eppstein/cgt/hard.html).'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Eppstein 的困难游戏列表](http://www.ics.uci.edu/~eppstein/cgt/hard.html)。'
- en: Is a given string a member of a context sensitive grammar?
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个给定的字符串是否是上下文敏感文法的成员？
- en: Do two regular expressions describe different languages? PSPACE-complete even
    over the binary alphabet and if one of the regular expressions is `.*`.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个正则表达式描述不同的语言吗？即使在二进制字母表上，如果其中一个正则表达式是`.*`，也是 PSPACE-complete。
- en: Another example that can be made rigorous is the problem of moving a complicated
    object (e.g., furniture) with attachments that can move and rotate through an
    irregularly shaped corridor.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个可以严格化的例子是移动一个复杂对象（例如家具），其附件可以通过不规则形状的走廊移动和旋转。
- en: Another example arises in parallel computing when the challenge is to determine
    whether a deadlock state is possible within a system of communicating processors.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个例子出现在并行计算中，当挑战是确定在一个通信处理器系统中是否可能存在死锁状态时。
- en: Note PSPACE = NPSPACE (Savitch's theorem).
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意PSPACE = NPSPACE（Savitch定理）。
- en: '*EXPTIME.* The complexity class EXPTIME = all decision problem solvable in
    exponential time on deterministic Turing machine. Note P ⊆ NP ⊆ PSPACE ⊆ EXPTIME,
    and, by the time hierarchy theorem, at least one inclusion is strict, but unknown
    which one (or more). It is conjectured that all inclusions are strict.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EXPTIME.* 复杂度类EXPTIME = 在确定性图灵机上指数时间内可解决的所有决策问题。注意P ⊆ NP ⊆ PSPACE ⊆ EXPTIME，并且根据时间层次定理，至少有一个包含是严格的，但未知哪一个（或更多）。有猜想认为所有包含都是严格的。'
- en: Roadblock from Harel p. 85.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Harel第85页的路障。
- en: 'Natural generalization of chess, checkers, Go (with Japanese style ko termination
    rule), and Shogi are EXPTIME-complete. Given a board position, can the first player
    force a win? Here N is the size of the board, and the running time is exponential
    in N. One reason that these problems are harder from a theoretical standpoint
    than Othello (and other PSPACE-complete games) is that they can take an exponential
    number of moves. Checkers (aka English draughts on an N-by-N board): player can
    have an exponential number of moves at a given turn because of jump sequences.
    [[pdf](../../papers/checkers.pdf)] Note: depending on termination rules, checkers
    can either be PSPACE-complete or EXPTIME-complete. For EXPTIME-complete, we assume
    the "forced capture rule" where a player must make a jump (or sequence of jumps)
    if available.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际象棋，跳棋，围棋（带有日本式的劫规则），将棋的自然推广是EXPTIME-complete。给定一个棋盘位置，第一位玩家能否强迫获胜？这里N是棋盘的大小，运行时间是N的指数。这些问题比奥赛洛（和其他PSPACE-complete游戏）在理论上更难的一个原因是它们可能需要指数数量的步骤。跳棋（在N×N棋盘上的英式跳棋）：玩家在一个回合中可以有指数数量的步骤，因为可以进行跳跃序列。[[pdf](../../papers/checkers.pdf)]
    注意：根据终局规则的不同，跳棋可以是PSPACE-complete或EXPTIME-complete。对于EXPTIME-complete，我们假设“强制捕获规则”，即如果有可用的跳跃（或跳跃序列），玩家必须进行跳跃。
- en: 'Here is a complexity version of the halting problem. Given a Turing machine,
    does it halt in at most k steps? Alternatively, given a fixed Java program and
    a fixed input, does it terminate in at most k steps? The problem is EXPTIME-complete.
    Here the running time is exponential in the binary representation of k. In fact,
    no turing machine can guarantee to solve it in, say, O(k / log k) steps. Thus,
    brute force simulation is essentially best possible: provably, the problem cannot
    be solved substantially faster than the trivial method of running the Turing machine
    for the first k steps and seeing what happens.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是停机问题的一个复杂性版本。给定一个图灵机，在最多k步内是否停机？或者，给定一个固定的Java程序和一个固定的输入，在最多k步内是否终止？这个问题是EXPTIME-complete。这里的运行时间是k的二进制表示的指数。事实上，没有图灵机能保证在O(k
    / log k)步内解决它。因此，暴力模拟基本上是最佳的方法：可以证明，这个问题不能比运行图灵机的前k步并观察发生了什么更快地解决。
- en: An EXPTIME-complete problem cannot be solved in polynomial-time on a deterministic
    Turing machine - it does not depend on the P ≠ NP conjecture.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个EXPTIME-complete问题不能在确定性图灵机上多项式时间内解决-这不依赖于P ≠ NP猜想。
- en: '*EXPSPACE.* EXPSPACE-complete: given two "extended" regular expressions, do
    they represent different languages? By extended, we allow a squaring operation
    (two copies of an expression). Stockmeyer and Meyer (1973). Or, more simply set
    intersection (Hunt, 1973). Word problem for Abelian groups (Cardoza, Lipton, Meyer,
    1976), Vector Addition Subsystem.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EXPSPACE.* EXPSPACE-complete：给定两个“扩展”正则表达式，它们是否表示不同的语言？通过扩展，我们允许一个平方操作（表达式的两个副本）。Stockmeyer和Meyer（1973）。或者更简单的集合交集（Hunt，1973）。Abelian群的字问题（Cardoza，Lipton，Meyer，1976），向量加法子系统。'
- en: 'The [Vector Addition Subsystem](http://rjlipton.wordpress.com/2009/04/08/an-expspace-lower-bound/)
    is EXPSAPCE-hard: given a nonnegative vector s and a set of arbitrary vectors,
    v1, v2, ..., vn, a vector x is reachable from s if it is either (i) the vector
    s or (ii) the vector y + vi where y is reachable. The VAS problem is to determine
    whether a given vector x is reachable.'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[向量加法子系统](http://rjlipton.wordpress.com/2009/04/08/an-expspace-lower-bound/)是EXPSAPCE-hard：给定一个非负向量s和一组任意向量v1，v2，...，vn，如果向量x是从s可达的，则它要么是（i）向量s，要么是可达的向量y
    + vi，其中y是可达的。VAS问题是确定给定向量x是否可达。'
- en: '*DOUBLE-EXPTIME.* The class DOUBLE-EXPTIME is the set of all decision problems
    solvable in doubly exponential time. A remarkable example is determining whether
    a formula in [first order Presburger arithmetic](http://en.wikipedia.org/wiki/Presburger_arithmetic)
    is true. Presburger arithmetic consists of statements involving integers with
    + as the only operation (no multiplication or division). It can model statements
    like the following: if x and y are integer such that x &le y + 2, then y + 3 >
    x. In 1929 Presburger proved that his system is consistent (can''t prove a contradiction
    like 1 > 2) and complete (every statement can be proven true or false). In 1974,
    Fischer and Rabin proved that any algorithm that decides the truth of a Presburger
    formula requires at least 2^((2^(cN))) time for some constant c, where N is the
    length of the formula.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双指数时间.* 双指数时间类是所有在双指数时间内可解决的决策问题的集合。一个显著的例子是确定[一阶Presburger算术](http://en.wikipedia.org/wiki/Presburger_arithmetic)中的一个公式是否为真。Presburger算术包括涉及只有+作为操作的整数的语句（没有乘法或除法）。它可以模拟以下语句：如果x和y是整数，使得x
    ≤ y + 2，则y + 3 > x。1929年，Presburger证明了他的系统是一致的（不能证明矛盾，如1 > 2）和完备的（每个语句都可以被证明为真或假）。1974年，Fischer和Rabin证明了任何决定Presburger公式真假的算法都��要至少2^((2^(cN)))时间，其中c是常数，N是公式的长度。'
- en: '*Non-elementary.* More than 2^2^2^...^2^N for any finite tower. Given two regular
    expressions that allow squaring and complementation, do they describe different
    languages?'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非初等.* 对于任何有限的塔，超过2^2^2^...^2^N。给定允许平方和补集的两个正则表达式，它们描述不同的语言吗？'
- en: Other types of computational problems.
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类型的计算问题。
- en: We focus on search problems since this is a very rich and important class of
    problems for scientists and engineers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注搜索问题，因为这是科学家和工程师面临的一个非常丰富和重要的问题类。
- en: '*Search problems.* This is the version we have considered in detail. Technically,
    FP = polynomial-time function problems, FNP = polynomial-time function problems
    on nondeterministic Turing machine. FP problems can have any output that can be
    computed in polynomial time (e.g., multiplying two numbers or finding the solution
    to Ax = b).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索问题*。这是我们详细考虑的版本。从技术上讲，FP = 多项式时间函数问题，FNP = 非确定性图灵机上的多项式时间函数问题。FP问题可以有任何可以在多项式时间内计算的输出（例如，两个数字相乘或找到Ax
    = b的解）。'
- en: '*Decision problems.* Traditionally, complexity theory is defined in terms of
    yes/no problems, e.g., Does there exist a solution to Ax &le b? Definition of
    reduction is cleaner (no need to deal with output). Classes P and NP traditionally
    defined in terms of decision problems. Typically the search problem reduces to
    the decision problem (and this is known to be true for all NP-complete problems).
    Such search problems are referred to as *self-reducible*. The P = NP question
    is equivalent to the FP = FNP question.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*决策问题*。传统上，复杂性理论是以是/否问题来定义的，例如，Ax &le b是否存在解？规约的定义更清晰（无需处理输出）。P和NP类通常以决策问题来定义。通常搜索问题归约为决策问题（对于所有NP完全问题来说这是成立的）。这样的搜索问题被称为*自可归约*。P
    = NP问题等价于FP = FNP问题。'
- en: '*Total functions.* Occasionally, a decision problem is easy, while the corresponding
    search problem is (believed to be) hard. For example, there may be a theorem asserting
    that a solution is guaranteed to exist, but the theorem does not provide any hint
    as to how to find one efficiently.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全函数*。有时，一个决策问题很容易，而相应的搜索问题（被认为）很难。例如，可能有一个定理断言保证存在解，但该定理不提供如何高效找到解的任何提示。'
- en: '[subset sum example](http://theory.lcs.mit.edu/classes/6.042/spring04/handouts/numbers.shtml).
    Given N numbers, find two (disjoint) subsets of these N numbers that sum to exactly
    the same value. If N = 77 and all the numbers are at most twenty-one decimal digits
    long, then by the pigeonhole principle, at least two subsets must sum to the same
    value. This is because there are 2^77 subsets but at most 1 + 77 * 10^21 < 2^77
    possible sums. Or decision = composite, search = factor.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[子集和示例](http://theory.lcs.mit.edu/classes/6.042/spring04/handouts/numbers.shtml)。给定N个数字，找到这些N个数字的两个（不相交）子集，使它们的和恰好相等。如果N
    = 77，并且所有数字最多为二十一位十进制数，则根据鸽巢原理，至少有两个子集的和必定相等。这是因为有2^77个子集，但最多有1 + 77 * 10^21 <
    2^77种可能的和。或者决策 = 复合，搜索 = 因子。'
- en: John Nash proved that *Nash equilibria* always exist in a normal form game of
    two or more players with specified utilities. Proof was nonconstructive, so unclear
    how to find such an equilibria. Proved to be *PPAD-complete* - the analog of NP-complete
    for problems known to have solutions.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约翰·纳什证明了在具有指定效用的两个或更多玩家的正常形式博弈中总是存在*Nash均衡*。证明是非构造性的，因此不清楚如何找到这样的均衡。被证明是*PPAD完全*
    - 已知具有解的问题的NP完全的类比。
- en: General equilibrium theory is foundation of microeconomics. Given an economy
    with k commodities, each of N agents has an initial endowment of the commodities.
    Each agent also as a utility function for each commodity. The [Arrow-Debreu theorem](http://en.wikipedia.org/wiki/Arrow_Debreu)
    asserts that under suitable technical conditions (e.g., utility functions are
    continuous, monotonic, and strictly concave) there exist a (unique) set of *market
    prices* such that each agent sells all their goods and buys the optimal bundle
    using this money (i.e., supply equals demand for every commodity). But how does
    market compute it? The proof relies on a deep theorem from topology (Kakutani's
    fixed point theorem) and no efficient algorithm is currently known. Economists
    assume that the market finds the equilibrium prices; Adam Smith used the metaphor
    of [the invisible hand](http://en.wikipedia.org/wiki/Invisible_hand) to describe
    this social mechanism.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般均衡理论是微观经济学的基础。给定一个有k种商品的经济体，每个N个代理人都有商品的初始禀赋。每个代理人还对每种商品有一个效用函数。[阿罗-德布鲁定理](http://en.wikipedia.org/wiki/Arrow_Debreu)断言，在适当的技术条件下（例如，效用函数连续、单调且严格凹），存在一组（唯一的）*市场价格*，使得每个代理人都卖掉所有商品，并用这笔钱购买最佳组合（即，每种商品的供给等于需求）。但市场如何计算？证明依赖于拓扑学的一个深刻定理（Kakutani的不动点定理），目前尚不知道任何有效的算法。经济学家假设市场找到均衡价格；亚当·斯密用[看不见的手](http://en.wikipedia.org/wiki/Invisible_hand)的隐喻来描述这种社会机制。
- en: Generalization of 15-slider puzzle. Testing whether solution exists is in P,
    but finding shortest solution is intractable. [Ratner-Warmuth, 1990]
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15滑块拼图的泛化。测试解是否存在在P中，但找到最短解是棘手的。[Ratner-Warmuth, 1990]
- en: '*Optimization problems.* Sometimes we have optimization problems, e.g., TSP.
    Given an NP problem and a cost function on solutions, the goal for a given instance
    is to find the *best* solution for it (e.g find the shortest TSP tour, the minimum
    energy configuration, etc.) Sometimes hard to formulate as a search problem (find
    the shortest TSP tour) since not clear how to efficiently check that you have
    optimal tour. Instead, we rephrase as: given a length L, find a tour of length
    at most L. Then binary search for optimal L.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优化问题*。有时我们有优化问题，例如，TSP。给定一个NP问题和解的成本函数，对于给定的实例，目标是找到其最佳解（例如找到最短的TSP路径、最小能量配置等）。有时很难表述为搜索问题（找到最短的TSP路径），因为不清楚如何有效地检查是否有最佳路径。相反，我们重新表述为：给定长度L，找到长度最多为L的路径。然后二分搜索最佳L。'
- en: '*Counting problems.* Given an NP problem, find the number of solutions for
    it. For example, given a CNF formula, how many satisfying assignments does it
    have? Includes many problems in statistical physics and combinatorics. Formally,
    the class of problems is known as [#P](http://en.wikipedia.org/wiki/Sharp-P).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*计数问题*。给定一个NP问题，找到其解的数量。例如，给定一个CNF公式，它有多少满足的赋值？包括统计物理学和组合数学中的许多问题。形式上，这类问题被称为[#P](http://en.wikipedia.org/wiki/Sharp-P)。'
- en: '*Strategic problems.* Given a game, find an optimal strategy (or best move)
    for a player. Includes many problems in economics and board games (e.g., chess,
    go).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*战略问题。* 给定一个游戏，为玩家找到最佳策略（或最佳移动）。包括经济学和棋盘游戏（例如国际象棋，围棋）中的许多问题。'
- en: Output polynomial-time.
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出多项式时间。
- en: Some problems involve more output than a single bit of information. For example,
    outputting a solution to the Towers of Hanoi problem requires at least 2^N steps.
    This requirement is not because the solution is inherently hard to compute, but
    rather because there are 2^N symbols of output, and it takes one unit of time
    to write each output symbol. Perhaps a more natural way to measure efficiency
    is a function both of the input size and of the output size. A classic electrical
    engineering problem with DFAs is to build a DFA from a RE that uses the minimum
    number of states. We would like an algorithm that is polynomial in the size of
    the input RE (number of symbols) and also in the size of the output DFA (number
    of states). Unless P = NP, designing such an algorithm is impossible. In fact,
    it's not even possible to design a polynomial algorithm that gets the answer within
    a constant (or even polynomial) number of states! Without the theory of NP-completeness,
    researchers would waste time following unpromising research directions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一些问题涉及的输出比单个位的信息更多。例如，输出汉诺塔问题的解决方案至少需要2^N步。这种要求并不是因为解决方案本质上难以计算，而是因为有2^N个输出符号，并且每个输出符号写入需要一个单位的时间。也许更自然的衡量效率的方法是输入大小和输出大小的函数。一个具有DFAs的经典电气工程问题是从RE构建使用最少状态的DFA。我们希望的算法在输入RE的大小（符号数）和输出DFA的大小（状态数）上都是多项式的。除非P
    = NP，设计这样的算法是不可能的。事实上，甚至不可能设计一个在常数（甚至多项式）数量的状态内得出答案的多项式算法！没有NP完全性理论，研究人员将浪费时间追随没有前途的研究方向。
- en: Other lower bounds.
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他下界。
- en: '*Information theoretic.* In Section X.Y we saw that insertion uses at most
    N^2 compares to sort N items, and mergesort uses at most N log N compares. A natural
    question to ask is whether we can do better, perhaps one that uses at most 5N
    compares or even 1/2 N log N compares. To make the question more precise, we must
    explicitly state our computational model (decision tree). Here, we assume that
    we only access the data through the `less()` function. A remarkable theorem due
    to X says that no (comparison based) sorting algorithm can guarantee to sort every
    input of N distinct elements in fewer than ~ N log N compares. To see why, observe
    that each compare (call to `less`) provides one bit of information. In order to
    identify the correct permutation, you need log N! bits, and log N! ~ N log N.
    This tells us that mergesort is (asymptotically) the best possible sorting algorithm.
    No sorting algorithm in existence (or even one not yet imagined) will use substantially
    fewer compares.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息论。* 在第X.Y节中，我们看到插入最多使用N^2次比较来对N个项目进行排序，而归并排序最多使用N log N次比较。一个自然的问题是我们是否可以做得更好，也许最多使用5N次比较，甚至1/2
    N log N次比较。为了使问题更加明确，我们必须明确陈述我们的计算模型（决策树）。在这里，我们假设我们只通过`less()`函数访问数据。由X提出的一个引人注目的定理表明，没有（基于比较的）排序算法可以保证在少于~
    N log N次比较中对N个不同元素的每个输入进行排序。要理解原因，观察到每次比较（调用`less`）提供一位信息。为了识别正确的排列，您需要log N!位信息，而log
    N! ~ N log N。这告诉我们，归并排序是（渐近地）最佳可能的排序算法。不存在任何排序算法（甚至是尚未想象的算法）将使用大大少于这些比较。'
- en: '*3-Sum hard.* Given a set of N integers, do any three of them sum to 0? Quadratic
    algorithm exists (see exercise xyz), but no subquadratic algorithm known. 3-SUM
    linear reduces to many problems in computational geometry. (find whether set of
    points in the plane have 3 that are collinear, decide whether a set of line segments
    in the plane can be split into two subsets by a line, determining whether a set
    of triangles cover the unit square, can you translate a polygon P to be completely
    inside another polygon Q, robot motion planning).'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3-Sum难题。* 给定一组N个整数，其中任意三个数之和为0吗？存在二次算法（参见练习xyz），但没有已知的次二次算法。 3-SUM线性归约为计算几何中的许多问题。（找出平面上的点集是否有3个共线，决定平面上的线段集是否可以被一条线分成两个子集，确定一组三角形是否覆盖单位正方形，您是否可以将多边形P平移到完全位于另一个多边形Q内部，机器人运动规划）。'
- en: Brute force TSP takes N! steps. Using dynamic programming, can get it down to
    2^N. Best lower bound = N. Essence of computational complexity = trying to find
    matching upper and lower bounds.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力TSP需要N!步。使用动态规划，可以将其降至2^N。最佳下界 = N。计算复杂性的本质 = 尝试找到匹配的上界和下界。
- en: Circuit complexity.
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电路复杂度。
- en: There are other ways to define and measure computational complexity. A Boolean
    circuit of n inputs can compute any Boolean function of n variables. We can associate
    the set of binary strings of size n for which the circuit outputs 1 as the set
    of strings in the language. We need one circuit for each input size n. Shannon
    (1949) proposed the size of the circuit as a measure of complexity. It is known
    that a language has *uniformly* polynomial circuits if and only if the language
    is in P.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他定义和衡量计算复杂性的方法。具有n个输入的布���电路可以计算n个变量的任何布尔函数。我们可以将电路输出1的大小的二进制字符串集合与语言中的字符串集合相关联。我们需要每个输入大小n的电路。
    Shannon（1949）提出了电路大小作为复杂性的度量。已知，如果语言具有*统一*多项式电路，则该语言属于P。
- en: Physical and analog computation.
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理和模拟计算。
- en: The P = NP question is a mathematical question regarding the capabilities of
    Turing machines and classical digital computers. We might also wonder whether
    the same is true for analog computers. By *analog*, we mean any "deterministic
    physical device that uses a fixed number of physical variables to represent each
    problem variable." Internal state represented by continuous variables instead
    of discrete. E.g., soap bubbles, protein folding, quantum computing, gears, time
    travel, black holes, etc.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: P = NP问题是关于图灵机和经典数字计算机能力的数学问题。我们也可以思考模拟计算机是否也适用于模拟计算机。通过*模拟*，我们指的是任何“使用固定数量的物理变量来表示每个问题变量的确定性物理设备”。内部状态由连续变量而不是离散变量表示。例如，肥皂泡、蛋白质折叠、量子计算、齿轮、时间旅行、黑洞等。
- en: '[Vergis, Steiglitz, and Dickinson](../../papers/vergis-steiglitz-dickinson.pdf)
    proposed an analog form of the Strong Church-Turing thesis:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[维尔吉斯、斯泰格利茨和迪金森](../../papers/vergis-steiglitz-dickinson.pdf)提出了强丘奇-图灵论断的模拟形式：'
- en: Any finite analog computer can be simulated *efficiently* by a digital computer,
    in the sense that the time required by the digital computer to simulate the analog
    computer is bounded by a polynomial function of the resources used by the analog
    computer.
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何有限的模拟计算机都可以被数字计算机*高效*模拟，即数字计算机模拟模拟计算机所需的时间受到模拟计算机使用资源的多项式函数的限制。
- en: 'The resources of the analog computer could be time, volume, mass, energy, torque,
    or angular momentum. Reference: [The Physics of Analog Computation](../../papers/vergis_steiglitz_dickinson86.pdf)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟计算机的资源可以是时间、体积、质量、能量、扭矩或角动量。参考：[模拟计算的物理](../../papers/vergis_steiglitz_dickinson86.pdf)
- en: Any reasonable model of computation (e.g., not involving exponential parallelism)
    can be simulated in polynomial time by a Turing machine (supplemented by a hardware
    random number generator).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 任何合理的计算模型（例如，不涉及指数并行性）都可以通过图灵机（辅以硬件随机数生成器）在多项式时间内模拟。
- en: 'Reference: [Scott Aaronson](../../papers/aaronson.pdf). Can yield new insights
    into physics. One day "the presumed intractability of NP-complete problems might
    be taken as a useful constraint in the search for new physical theories" just
    like the second law of thermodynamics. Still can be falsified by experiment, but
    don''t waste time looking...'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 参考：[斯科特·亚伦森](../../papers/aaronson.pdf)。可以为物理学带来新的见解。有一天，“NP完全问题的假定不可解性可能被视为寻找新物理理论的有用约束”，就像热力学第二定律一样。仍然可以通过实验来验证，但不要浪费时间...
- en: '*Soap bubbles.* Folklore that you can solve Steiner tree problem. In reality,
    only finds a local minimum, and may take a while to do so.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*肥皂泡。* 传说中可以解决斯坦纳树问题。实际上，只能找到一个局部最小值，并且可能需要一段时间才能找到。'
- en: '*Quantum computing.* One speculative model of computation - quantum computers
    - might be capable of solving some problems in a polynomial time that a deterministic
    Turing machine cannot do. Peter Shor discovered an N^3 algorithm for factoring
    N-digit integers, but the best known algorithm on a classical computer takes time
    exponential in N. Same idea could lead to a comparable speedup in simulating quantum
    mechanical systems. This explains the recent excitement in quantum computation,
    as it could result in a paradigm shift for computing. However, quantum computers
    do not yet violate the extended Church-Turing thesis since we don''t yet know
    how to build them. (Difficult to harness because much of the quantum information
    seems to be easily destroyed by its interactions with the outside world, i.e.,
    decoherence.) Moreover, it is still possible that someone might discover a polynomial-time
    algorithm for factoring on a classical computer, although most experts suspect
    that this is not possible. Grover''s algorithm: search in sqrt(N) time instead
    of N.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*量子计算。* 一种推测的计算模型 - 量子计算机 - 可能能够在多项式时间内解决一些确定性图灵机无法解决的问题。彼得·肖尔发现了一个N^3算法来因式分解N位整数，但在经典计算机上已知的最佳算法需要指数级时间。同样的想法可能导致在模拟量子力学系统方面取得可比较的加速。这解释了最近对量子计算的兴奋，因为它可能导致计算的范式转变。然而，量子计算机尚未违反扩展的丘奇-图灵论断，因为我们尚不知道如何构建它们。（难以利用，因为大部分量子信息似乎很容易被其与外界的相互作用所破坏，即退相干。）此外，仍然有可能有人在经典计算机上发现一个多项式时间算法来因式分解，尽管大多数专家认为这是不可能的。格罗弗算法：在sqrt(N)时间内搜索而不是N。'
- en: Richard Feynman showed in 1982 that classical computers cannot simulate quantum
    mechanical systems without slowing down exponentially (crux of argument is that
    Turing machines have locality of reference whereas quantum mechanics includes
    "exploit spooky action at a distance"). A quantum computer might be able to get
    around this problem. Feynman quote with respect to building a computer to simulate
    physics...
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理查德·费曼在1982年表明，经典计算机无法在不出现指数级减速的情况下模拟量子力学系统（论点的关键在于图灵机具有引用的局部性，而量子力学包括“利用远距离的诡异作用”）。量子计算机可能能够解决这个问题。费曼关于建造模拟物理的计算机的引用...
- en: '"The rule of simulation that I would like to have is that the number of computer
    elements required to simulate a large physical system is only to be proportional
    to the space-time volume of the physical system. I don''t want to have an explosion."'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我想要的模拟规则是，用于模拟大型物理系统所需的计算机元素数量仅与物理系统的时空体积成正比。我不希望出现爆炸。”
- en: Rephrase in terms of modern complexity theory by replacing "proportional to"
    by "bounded by a polynomial function of".
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用“与...成正比”替换现代复杂性理论的表述，用多项式函数“受限于”。
- en: Deutsch-Jozsa give algorithm that is provably exponentially faster on a quantum
    computer than on a deterministic Turing machine. (Though exponential gap does
    not exist if the Turing machine has access to a hardware random number generator
    and can be wrong with negligible probability. Quantum computers can generate true
    randomness. )
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Deutsch-Jozsa 提出的算法在量子计算机上被证明比确定性图灵机快指数倍。（尽管如果图灵机可以访问硬件随机数生成器并且可以以可忽略的概率出错，指数差距就不存在。量子计算机可以生成真正的随机性。）
- en: PRIMES and COMPOSITE.
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PRIMES和COMPOSITE。
- en: 'It is easy to convince someone that a number is composite by producing a factor.
    Then, the person just has to check (by long division) that you did not lie to
    them. Marin Mersenne conjectured that numbers of the form 2^p - 1 are prime for
    p = 2, 3, 5, 7, 13, 17, 19, 31, 67, 127 and 257. His conjecture for p = 67 was
    disproved by F. N. Cole over two hundred and fifty years later in 1903. According
    to E. T. Bell''s book *Mathematics: Queen and Servant of Science*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个因子很容易说服某人一个数是合数。然后，这个人只需通过长除法检查你是否对他们撒谎。马林·梅森猜想形式为2^p - 1的数对于p = 2, 3,
    5, 7, 13, 17, 19, 31, 67, 127和257时是质数。他对p = 67的猜想在两百五十多年后的1903年被F·N·科尔证明是错误的。根据E·T·贝尔的书籍*数学：科学的女王和仆人*
- en: In the October meeting of the AMS, Cole announced a talk "On the Factorisation
    of Large Numbers". He walked up to the blackboard without saying a word, calculated
    by hand the value of 2^(67), carefully subtracted 1. Then he multiplied two numbers
    (which were 193707721 and 761838257287). Both results written on the blackboard
    were equal. Cole silently walked back to his seat, and this is said to be the
    first and only talk held during an AMS meeting where the audience applauded. There
    were no questions. It took Cole about 3 years, each Sunday, to find this factorization,
    according to what he said.
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在AMS的十月会议上，Cole宣布了一个名为“关于大数的因式分解”的讲座。他默默无言地走到黑板前，手工计算了2^(67)的值，仔细地减去1。然后他将两个数相乘（分别是193707721和761838257287）。黑板上写下的两个结果是相等的。Cole默默地走回座位，据说这是AMS会议上唯一一次观众鼓掌的讲座。没有问题。根据他所说，Cole花了大约3年的时间，每个星期日，找到这个因式分解。
- en: For the record 2^(67) - 1 = 193707721 × 761838257287 = 147573952589676412927.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为记录，2^(67) - 1 = 193707721 × 761838257287 = 147573952589676412927。
- en: Q + A
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Q + A
- en: '**Q.** Are polynomial algorithms always useful?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 多项式算法总是有用的吗？'
- en: '**A.** No, algorithms that take N^(100) or 10^(100) N² steps are as useless
    in practice as exponential ones. The constants that arise in practice are usually
    sufficiently small that polynomial-time algorithms scale to huge problems, so
    polynomiality often serves as a surrogate for useful in practice.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不，那些需要N^(100)或10^(100)N²步骤的算法在实践中和指数级别的算法一样无用。在实践中出现的常数通常足够小，使得多项式时间算法可以扩展到巨大的问题，因此多项式性通常作为实践中有用的替代品。'
- en: '**Q.** Why is the class of all search problems named NP?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么所有搜索问题的类别被命名为NP？'
- en: '**A.** The original definition of NP was in terms of *nondeterministic* Turing
    machines: NP is the set of all decision problems that can be solved in polynomial-time
    on a nondeterministic Turing machine. Roughly speaking, the difference between
    a deterministic and nondeterministic Turing machine is that the former operates
    like a conventional computer, performing each instruction in sequence, forming
    a computational path; a nondeterministic Turing machine can "branch off" where
    each branch can execute a different statement in parallel, forming a computational
    tree (If any path in the tree leads to a YES, then we accept; if all paths lead
    to NO, we reject.) This is where the N in NP comes from. It turns out the two
    definitions are equivalent, but the certificate one is now more widely used. (Also,
    Karp''s 1972 paper uses the polynomial-time verifiability definition.)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** NP的最初定义是关于*非确定性*图灵机的：NP是所有可以在非确定性图灵机上多项式时间内解决的决策问题的集合。粗略地说，确定性和非确定性图灵机之间的区别在于前者像传统计算机一样运行，按顺序执行每个指令，形成一个计算路径；非确定性图灵机可以“分支”，其中每个分支可以并行执行不同的语句，形成一个计算树（如果树中的任何路径导致YES，则我们接受；如果所有路径导致NO，则我们拒绝。）这就是NP中的N的含义。事实证明，这两个定义是等价的，但现在更广泛使用证书的定义。（此外，卡普尔的1972年论文使用了多项式时间可验证性的定义。）'
- en: '**Q.** What is the complexity class NP-hard?'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 复杂度类NP-hard是什么？'
- en: '**A.** Several competing definitions. We define a problem (decision, search,
    or optimization) problem to be NP-hard if solving it in polynomial-time would
    imply P = NP. Definition implicitly uses Turing reduction (extended to search
    problems).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 有几个竞争性的定义。我们定义一个问题（决策、搜索或优化）问题为NP难问题，如果在多项式时间内解决它将意味着P = NP。定义隐含地使用图灵归约（扩展到搜索问题）。'
- en: '**Q.** What''s so hard about factoring an integer N in polynomial time - can''t
    I just divide all potential factors less than N (or √N) into x and see if any
    have a remainder of zero?'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 在多项式时间内对一个整数N进行因式分解有什么困难之处 - 我不能只是将小于N（或√N）的所有潜在因子除以x，看看是否有余数为零吗？'
- en: '**A.** The algorithm is correct, but remember it takes only lg N bits to represent
    the integer N. Thus, for an algorithm to be polynomial in the input size, it must
    be polynomial in lg N, and not N.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 算法是正确的，但请记住只需要lg N位来表示整数N。因此，对于一个算法在输入大小上是多项式的，它��须在lg N上是多项式的，而不是N。'
- en: '**Q.** How is it possible that checking whether an integer is composite is
    solvable in polynomial-time, yet finding its factors is not known (or believed)
    to be?'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如何可能检查一个整数是否为合数可以在多项式时间内解决，但找到它的因子却不为人所知（或被认为）？'
- en: '**A.** There are ways to prove a number is composite without getting your hands
    on any of its factors. A famous theorem from number theory (Fermat''s little theorem)
    implies that if you have two integers a and p such that (i) a is not a multiple
    of p and (ii) a^(p-1) != 1 (mod p), then p is not prime.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 有方法可以证明一个数是合数而不需要得到它的任何因子。数论中的一个著名定理（费马小定理）暗示着，如果你有两个整数a和p，使得（i）a不是p的倍数且（ii）a^(p-1)
    != 1（mod p），那么p不是质数。'
- en: '**Q.** Is there a decision problem that is polynomial solvable on a quantum
    computers, but *provably* not in P?'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 有没有一个决策问题在量子计算机上可以多项式解决，但*可以*被证明不在P中？'
- en: '**A.** This is an open research problem. FACTOR is a candidate, but there is
    no proof that FACTOR is not in P, although this is widely believed to be outside
    P.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这是一个开放的研究问题。FACTOR是一个候选者，但没有证据表明FACTOR不在P中，尽管普遍认为它不在P中。'
- en: '**Q.** Does NP = EXPTIME?'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** NP = EXPTIME吗？'
- en: '**A.** The experts believe no, but have been unable to prove it.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 专家们认为不可能，但他们无法证明。'
- en: '**Q.** Suppose that someone proves P = NP. What would be the practical consequences?'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 假设有人证明P = NP。这会有什么实际后果？'
- en: '**A.** It depends on how the question is resolved. Obviously, it would be a
    remarkable theoretical breakthrough. In practice, it might have dramatic significance
    if the proof of P = NP established a fast algorithm for factoring integers or
    some other search problem. If the proof results in an 2^100 N^117 algorithm for
    the TSP (and the constant and exponent could not be reduced), it would have little
    practical impact. It could also be that someone proves P = NP by indirect means,
    thereby yielding no algorithm at all!'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这取决于问题的解决方式。显然，这将是一个显著的理论突破。在实践中，如果P = NP的证明建立了一个快速的整数因子分解算法或其他搜索问题的算法，那么可能会具有重大意义。如果证明导致TSP的2^100
    N^117算法（且常数和指数无法降低），那么它将几乎没有实际影响。也可能是有人通过间接手段证明了P = NP，从而根本没有产生算法！'
- en: '**Q.** Suppose someone proves P != NP. What would be the practical consequences?'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 假设有人证明P != NP。这会有什么实际后果？'
- en: '**A.** It would be a remarkable theoretical breakthrough and solidify the foundation
    of much of computational complexity.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这将是一个显著的理论突破，并巩固了计算复杂性的许多基础。'
- en: '**Q.** Suppose P = NP. Does that mean deterministic TM are the same as non-deterministic
    TM?'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 假设P = NP。这是否意味着确定性图灵机与非确定性图灵机相同？'
- en: '**A.** Not quite. For example, even if P = NP, a non-deterministic TM may be
    able to solve a problem in time proportional to N^2, where the best deterministic
    one would take N^3\. If P = NP, it just means that the two types of machines solve
    the same set of decision problems in polynomial time, but it says nothing about
    the degree of the polynomial.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 不完全相同。例如，即使P = NP，非确定性图灵机可能能够在与最佳确定性图灵机相比为N^3的时间内解决一个问题。如果P = NP，这只是意味着这两种类型的机器在多项式时间内解决相同的决策问题，但它并不涉及多项式的程度。'
- en: '**Q.** Where can I learn more about NP-completeness?'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我在哪里可以了解更多关于NP完全性的知识？'
- en: '**A.** The authoritative reference remains Garey and Johnson *Computers and
    Intractability: A Guide to the Theory of NP-completeness*. Many of the most important
    subsequent discoveries are documented in David Johnson''s [NP-completeness column](http://www.research.att.com/~dsj/columns/).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** ��威参考仍然是Garey和Johnson的《计算机与难解性：NP完全性理论指南》。许多最重要的后续发现都记录在David Johnson的[NP完全性专栏](http://www.research.att.com/~dsj/columns/)中。'
- en: Exercises
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Which of the following can we infer from the fact that the traveling salesperson
    problem is NP-complete, if we assume that P is not equal to NP?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从旅行推销员问题是NP完全问题这一事实中我们可以推断出什么，假设P不等于NP？
- en: There does not exist an algorithm that solves arbitrary instances of the TSP
    problem.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不存在一个解决TSP问题任意实例的算法。
- en: There does not exist an algorithm that efficiently solves arbitrary instances
    of the TSP problem.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不存在一个有效地解决TSP问题任意实例的算法。
- en: There exists an algorithm that efficiently solves arbitrary instances of the
    TSP problem, but no one has been able to find it.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一个有效地解决TSP问题任意实例的算法，但没有人能找到它。
- en: The TSP is not in P.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: TSP不在P中。
- en: All algorithms that are guaranteed to solve the TSP run in polynomial time for
    some family of input points.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有保证解决TSP问题的算法在某些输入点族的多项式时间内运行。
- en: All algorithms that are guaranteed to solve the TSP run in exponential time
    for all families of input points.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有保证解决TSP问题的算法在所有输入点族的指数时间内运行。
- en: '*Answer*: (b) and (d) only.'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：只有(b)和(d)。'
- en: Which of the following can we infer from the fact that FACTORING is in NP but
    not known to be NP-complete, if we assume that P is not equal to NP?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从FACTORING在NP中但不被认为是NP完全问题这一事实中我们可以推断出什么，假设P不等于NP？
- en: There exists an algorithm that solves arbitrary instances of FACTORING.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一个解决任意FACTORING实例的算法。
- en: There exists an algorithm that efficiently solves arbitrary instances of FACTORING.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一个有效地解决任意FACTORING实例的算法。
- en: If we found an efficient algorithm for FACTORING, we could immediately use it
    as a black box to solve TSP.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们找到了一个高效的FACTORING算法，我们可以立即将其用作黑匣子来解决TSP问题。
- en: '*Answer*: We can infer only (a) since all problems in NP are decidable. If
    P != NP, then there are problems in NP that are neither in P or NP-complete. Researcher
    conjecture that FACTORING is one of them. although this was recently disproved).
    Part (c) cannot be inferred since we don''t know if FACTORING is NP-complete.'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：我们只能推断出(a)，因为NP中的所有问题都是可判定的。如果P != NP，那么NP中存在一些既不在P中也不是NP完全问题的问题。研究人员猜想FACTORING就是其中之一（尽管最近已经被证明不是）。无法推断出(c)部分，因为我们不知道FACTORING是否是NP完全问题。'
- en: Which of the following are NP-complete?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是NP完全问题？
- en: The brute force TSP algorithm.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于TSP问题的蛮力算法。
- en: The quicksort algorithm for sorting.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于排序的快速排序算法。
- en: The Halting problem.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停机问题。
- en: Hilbert's 10th problem.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 希尔伯特第十问题。
- en: '*Answer*: None. NP-completeness deals with *problems* not specific algorithm
    for problems. The Halting problem and Hilbert''s 10th problem are undecidable,
    so they are not in NP (and all NP-complete problems are in NP).'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：没有。NP完全性涉及*问题*而不是问题的具体算法。停机问题和希尔伯特第十问题是不可判定的，因此它们不在NP中（所有NP完全问题都在NP中）。'
- en: Let X and Y be two decision problems. Suppose we know that X reduces to Y. Which
    of the following can we infer?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设X和Y是两个决策问题。假设我们知道X归约于Y。我们可以推断出以下哪些？
- en: If Y is NP-complete then so is X.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Y是NP完全问题，则X也是。
- en: If X is NP-complete then so is Y.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果X是NP完全问题，那么Y也是。
- en: If Y is NP-complete and X is in NP then X is NP-complete.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Y是NP完全问题且X在NP中，则X也是NP完全问题。
- en: If X is NP-complete and Y is in NP then Y is NP-complete.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果X是NP完全问题且Y在NP中，则Y也是NP完全问题。
- en: X and Y can't both be NP-complete.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: X和Y不能同时是NP完全问题。
- en: If X is in P, then Y is in P.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果X在P中，那么Y也在P中。
- en: If Y is in P, then X is in P.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Y在P中，那么X也在P中。
- en: '*Answer:* (d) and (g) only. X reduces to Y means that if you had a black box
    to solve Y efficiently, you could use it to solve X efficiently. X is no harder
    than Y.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：只有(d)和(g)。X归约于Y意味着如果你有一个有效地解决Y的黑匣子，你可以用它来有效地解决X。X不比Y难。'
- en: Suppose that X is NP-complete, X reduces to Y, and Y reduces to X. Is Y necessarily
    NP-complete?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设X是NP完全的，X归约到Y，Y归约到X。Y一定是NP完全的吗？
- en: '*Answer:* No, since Y may not be in NP. For example if X = CIRCUIT-SAT and
    Y = CO-CIRCUIT-SAT then X and Y satisfy the conditions, but it is unknown whether
    Y is in NP.'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：不，因为Y可能不在NP中。例如，如果X = 电路可满足问题（CIRCUIT-SAT）且Y = 互补电路可满足问题（CO-CIRCUIT-SAT），那么X和Y满足条件，但尚不清楚Y是否在NP中。'
- en: 'Show that CIRCUIT-SAT reduces to CIRCUIT-DIFF. *Hint*: create a circuit with
    N inputs that always outputs 0.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明电路可满足问题归约到电路差异问题。*提示*：创建一个具有N个输入的电路，总是输出0。
- en: Show that CIRCUIT-DIFF reduces to CIRCUIT-SAT.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明电路差异问题归约到电路可满足问题。
- en: 'Show that DETERMINANT is in NP: given an N-by-N integer matrix A, is det(A)
    = 0?'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明行列式问题在NP中：给定一个N×N的整数矩阵A，det(A) = 0吗？
- en: '*Solution:* certificate is a nonzero vector x such that Ax = 0.'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：证书是一个非零向量x，使得Ax = 0。'
- en: 'Show that FULL-RANK is in NP: given an N-by-N integer matrix A, is det(A) ≠
    0?'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明全秩问题在NP中：给定一个N×N的整数矩阵A，det(A) ≠ 0吗？
- en: '*Solution:* certificate is an N-by-N inverse matrix B such that AB = I.'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：证书是一个N×N的逆矩阵B，使得AB = I。'
- en: '**Search problems vs. decision problems.** We can formulate a search problem
    using a corresponding decision problem. For example, the problem of finding the
    prime factorization of an integer N can be formulate using the decision problem:
    given two integers N and and L, does N have a nontrivial factor strictly less
    than L. The search problem is solvable in polynomial time if and only if the corresponding
    decision problem is. To see why, we can efficiently find the smallest factor p
    of N by using different values of L along with binary search. Once we have the
    factor p, we can repeat the process on N/p.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**搜索问题与决策问题。** 我们可以使用相应的决策问题来制定一个搜索问题。例如，找到整数N的素因数分解问题可以使用决策问题来制定：给定两个整数N和L，N是否有一个小于L的非平凡因子。如果相应的决策问题可解，则搜索问题也可在多项式时间内解决。为了理解原因，我们可以通过使用不同的L值和二分查找来高效地找到N的最小因子p。一旦我们有了因子p，我们可以在N/p上重复这个过程。'
- en: Usually we can show that the search problem and the decision problem are equivalent
    up to polynomial factors in running time. Papadimitriou (Example 10.8) gives an
    interesting counterexample to the rule. Given N positive integers such that their
    sum is less than 2^N - 1, find two subsets whose sum is equal. For example, the
    10 numbers below sum to 1014 < 1023.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常我们可以证明搜索问题和决策问题在运行时间的多项式因子上是等价的。Papadimitriou（示例10.8）给出了一个有趣的反例。给定N个正整数，使得它们的和小于2^N
    - 1，找到两个和相等的子集。例如，下面的10个数字的和为1014 < 1023。
- en: 23 47 59 88 91 100 111 133 157 205
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 23 47 59 88 91 100 111 133 157 205
- en: 'Since there are more subsets of N integers (2^N) than numbers between 1 and
    1014, there must be two different subsets with the same sum. But nobody know a
    polynomial time algorithm for *finding* such a subset. On the other hand, the
    natural decision problem is trivial solvable in constant time: are there two subsets
    of numbers that sum to the same value?'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于N个整数的子集（2^N）比1到1014之间的数字更多，必然存在两个不同的子集具有相同的和。但是没有人知道一个多项式时间算法来*找到*这样的子集。另一方面，自然的决策问题在常数时间内是易解的：是否存在两个子集的和相等？
- en: '**Pratt''s primality certificate.** Show that PRIMES is in NP. Use Lehmer''s
    theorem (Fermat''s Little Theorem Converse) which asserts that an integer p >
    1 is prime if and only if there exists an integer x such that x^(N-1) = 1 (mod
    p) and x^((p-1)/d) ≠ 1 (mod p) for all prime divisors d of p-1. For example, if
    N = 7919, then the prime factorization of p-1 = 7918 = 2 × 37 × 107. Now x = 7
    satisfies 7^(7918) = 1 (mod 7919), but 7^(7918/2) ≠ 1 (mod 7919), 7^(7918/37)
    ≠ 1 (mod 7919), 7^(7918/107) ≠ 1 (mod 7919). This proves that 7919 is prime (assuming
    that you recursively certify that 2, 37, and 107 are prime).'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**普拉特素性证书。** 证明PRIMES在NP中。使用Lehmer定理（费马小定理的逆定理），该定理断言大于1的整数p是素数当且仅当存在一个整数x，使得x^(N-1)
    = 1（mod p）且x^((p-1)/d) ≠ 1（mod p），其中d是p-1的素数因子。例如，如果N = 7919，则p-1 = 7918 = 2 ×
    37 × 107的素因数分解。现在x = 7满足7^(7918) = 1（mod 7919），但7^(7918/2) ≠ 1（mod 7919），7^(7918/37)
    ≠ 1（mod 7919），7^(7918/107) ≠ 1（mod 7919）。这证明了7919是素数（假设您递归地证明2、37和107是素数）。'
- en: '**Pell''s equation.** Find all positive integer solutions to Pell''s equation:
    x^2 - 92y^2 = 1. *Solution*: (1151, 120), (2649601, 276240), etc. There are infinitely
    many solutions, but each successive one is about 2300 times the previous one.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**佩尔方程。** 找到佩尔方程x² - 92y² = 1的所有正整数解。*解决方案*：（1151, 120），（2649601, 276240），等等。有无穷多个解，但每个连续的解大约是前一个解的2300倍。'
- en: '**Pell''s equation.** In 1657, Pierre Fermat challenged his colleagues with
    the following problem: given a positive integer c, find a positive integer y such
    that cy² is a perfect square. Fermat used c = 109\. It turns out the smallest
    solution is (x, y) = (158,070,671,986,249, 15,140,424,455,100). Write a program
    [Pell.java](Pell.java.html) that reads in an integer c and finds the smallest
    solution to Pell''s equation: x² - c y² = 1. Try c = 61. The smallest solution
    is (1,766,319,049, 226,153,980). For c = 313, the smallest solution is ( 3,218,812,082,913,484,91,819,380,158,564,160).
    The problem is provably unsolvable in a polynomial number of steps (as a function
    of the number of bits in the input c) because the output may require exponentially
    many bits!'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**佩尔方程。** 1657年，皮埃尔·费马向他的同事提出了以下问题：给定一个正整数c，找到一个正整数y，使得cy²是一个完全平方数。费马使用了c =
    109。事实证明，最小的解是（x，y）=（158,070,671,986,249，15,140,424,455,100）。编写一个程序[Pell.java](Pell.java.html)，读入一个整数c，并找到佩尔方程x²
    - cy² = 1的最小解。尝试c = 61。最小的解是（1,766,319,049，226,153,980）。对于c = 313，最小的解是（3,218,812,082,913,484,91,819,380,158,564,160）。由于输出可能需要指数级的位数，该问题在多项式步骤中是不可解的（作为输入c位数的函数）！'
- en: '**3-COLOR reduced to 4-COLOR.** Show that 3-COLOR polynomial reduces to 4-COLOR.
    *Hint*: given an instance G of 3-COLOR, create an instance G'' of 4-COLOR by adding
    a special vertex x to G and connecting it to all of the vertices in G.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3-着色问题归约到4-着色问题。** 证明3-着色问题多项式归约到4-着色问题。*提示*：给定一个3-着色问题的实例G，通过在G中添加一个特殊顶点x并将其连接到G中的所有顶点来创建一个4-着色问题的实例G''。'
- en: '**3-SAT.** Show that 3-SAT is self-reducible.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3-SAT问题。** 证明3-SAT问题是自可归约的。'
- en: '**3-COLOR.** Show that 3-COLOR is self-reducible. That is, given an oracle
    that answers whether or not any graph G is 3-colorable, design an algorithm that
    can 3-color a graph (assuming it is 3-colorable). Your algorithm should run in
    polynomial-time plus a polynomial number of calls to the oracle.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3-COLOR。** 证明3-COLOR是自可归约的。也就是说，给定一个回答任何图G是否可3着色的oracle，设计一个算法可以为图着色（假设它是可3着色的）。你的算法应在多项式时间内运行，再加上多项式次数的oracle调用。'
- en: '**Connectivity.** Reduce USTCONN (undirected s-t connectivity). to STCONN (s-t
    connectivity)'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连通性。** 将USTCONN（无向s-t连通性）简化为STCONN（s-t连通性）。'
- en: '**LP standard form.** A standard form linear program is Ax = b, x ≥ 0. Show
    how to reduce a general linear program (with ≤, ≥, and = constraints) to standard
    form.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**LP标准形式。** 标准形式线性规划是Ax = b，x ≥ 0。展示如何将一般线性规划（带有≤、≥和=约束）简化为标准形式。'
- en: '**Ax = b, x integral.** Given a integer-valued N-by-N matrix A and an integer-valued
    vector b, is there an integer-valued vector x such that Ax = b.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Ax = b, x整数。** 给定一个整数值的N×N矩阵A和一个整数值的向量b，是否存在一个整数值的向量x使得Ax = b。'
- en: If A is of rank N, then solve Ax = b and check if x is integer-valued. Otherwise,
    the problem can still be solved in polynomial time, but it is much more tricky
    and involves Smith normal form. See [this blog post](https://rjlipton.wordpress.com/2015/01/14/forgetting-results/).
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果A的秩为N，则解Ax = b并检查x是否为整数值。否则，问题仍然可以在多项式时间内解决，但更加棘手，涉及到史密斯标准形式。参见[这篇博客文章](https://rjlipton.wordpress.com/2015/01/14/forgetting-results/)。
