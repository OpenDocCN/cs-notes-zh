- en: 5.1   Formal Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1   形式语言
- en: 原文：[https://introcs.cs.princeton.edu/java/51language](https://introcs.cs.princeton.edu/java/51language)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/51language](https://introcs.cs.princeton.edu/java/51language)
- en: In this section, we introduce formal languages, regular expressions, deterministic
    finite state automata, and nondeterministic finite state automata.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们介绍形式语言、正规表达式、确定性有限状态自动机和非确定性有限状态自动机。 '
- en: Basic definitions.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本定义。
- en: We begin with some important definitions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些重要的定义开始。
- en: A *symbol* is our basic building block, typically a character or a digit.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*符号* 是我们的基本构建块，通常是字符或数字。'
- en: An *alphabet* is a finite set of symbols.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字母表* 是一组有限的符号。'
- en: A *string* is a finite sequence of alphabet symbols.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串* 是字母表符号的有限序列。'
- en: A *formal language* is a set of strings (possibly infinite), all over the same
    alphabet.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*形式语言* 是一组字符串（可能是无限的），都属于相同的字母表。'
- en: Now, we consider some examples.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们考虑一些示例。
- en: '*Binary strings.* We begin with examples of formal languages over the binary
    alphabet. The simplest way to specify a formal language is to enumerate its strings.
    One complication is that languages can be large or infinite sets, so we often
    use informal descriptions.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二进制字符串。* 我们从二进制字母表上的形式语言的示例开始。指定形式语言的最简单方法是列举其字符串。一个复杂之处在于语言可以是大型或无限集合，因此我们经常使用非正式描述。'
- en: '![formal languages over a binary alphabet](../Images/17c863eab7acd64e19f182e67e1179f5.png)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![二进制字母表上的形式语言](../Images/17c863eab7acd64e19f182e67e1179f5.png)'
- en: '*Other alphabets.* We use whichever alphabet is suitable to the task at hand
    when working with formal languages: the standard Roman alphabet for processing
    text, decimal digits for processing numbers, the alphabet { A, T, C, G } for processing
    genetic data, and so forth.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他字母表。* 在处理形式语言时，我们使用适合任务的任何字母表：标准罗马字母表用于处理文本，十进制数字用于处理数字，字母表 { A, T, C, G
    } 用于处理遗传数据，依此类推。'
- en: '![commonly used alphabets](../Images/8481d342985366c57b3b5cf189f98e70.png)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![常用字母表](../Images/8481d342985366c57b3b5cf189f98e70.png)'
- en: 'Here are some example languages over different alphabets:'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一些关于不同字母表的示例语言：
- en: '![formal languages](../Images/d1dddb6c2c5a84d2e3d5d7ef7b3ab762.png)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![形式语言](../Images/d1dddb6c2c5a84d2e3d5d7ef7b3ab762.png)'
- en: '*Specification problem.* How do we completely and precisely define formal languages?
    This task is known as the *specification problem* for formal languages. Our informal
    English-language descriptions do the job in some cases but are rather inadequate
    in others.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*规范化问题。* 我们如何完全和准确地定义形式语言？这个任务被称为形式语言的*规范化问题*。我们的非正式英语描述在某些情况下可以胜任，但在其他情况下相当不足。'
- en: '*Recognition problem.* Given a language *L* and a string *x*, the *recognition
    problem* is to answer the following question: Is *x* in *L*?'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别问题。* 给定一个语言 *L* 和一个字符串 *x*，*识别问题*是回答以下问题：*x* 是否在 *L* 中？'
- en: Regular languages.
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正规语言。
- en: We now consider an important class of formal languages known as the *regular
    languages*, for which we can solve the specification and recognition problems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑一类重要的形式语言，称为*正规语言*，对于这类语言，我们可以解决规范化和识别问题。
- en: '*Basic operations.* We use the *union*, *concatenation*, and *closure* operations
    on sets, along with *parentheses*, to specify a regular language.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本操作。* 我们使用*并集*、*连接*和*闭包*操作在集合上，以及*括号*，来指定一个正规语言。'
- en: The *union* *R* | *S* of two formal languages *R* and *S* is the set of strings
    that are in either *R* or *S* (or both). For example,
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个形式语言 *R* 和 *S* 的*并集* *R* | *S* 是在 *R* 或 *S* 中的字符串的集合（或两者都有）。例如，
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We do not include duplicates in the union.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在并集中不包括重复项。
- en: The *concatenation* *RS* of two formal languages *R* and *S* is the set of all
    strings that can be created by appending a string from *R* to a string from *S*.
    For example,
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个形式语言 *R* 和 *S* 的*连接* *RS* 是通过将来自 *R* 的字符串附加到来自 *S* 的字符串而创建的所有字符串的集合。例如，
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Again, we do not include duplicates in the result.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，我们在结果中不包括重复项。
- en: The *closure* *R** of a formal language *R* is the concatenation of zero or
    more strings from *R*.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式语言 *R* 的*闭包* *R** 是从 *R* 中的零个或多个字符串的连接。
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that each time we take a string from *R*, we are free to use any string
    in the set. Here ε refers to the empty string—the string consisting of 0 characters.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，每次我们从 *R* 中取一个字符串时，我们可以自由使用集合中的任何字符串。这里 ε 指的是空字符串——由 0 个字符组成的字符串。
- en: We use *parentheses* or rely on a defined operator precedence order to specify
    in which order should the operators be applied. For REs, closure is performed
    before concatenation, and concatenation is performed before union.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用*括号*或依赖于定义的运算符优先级顺序来指定运算符应该应用的顺序。对于正规表达式，闭包在连接之前执行，连接在并集之前执行。
- en: '*Regular expressions.* ![anatomy of a regular expression](../Images/5c37c369804b9993c1eef084faf1381d.png)
    A regular expression (RE) is a string of symbols that specifies a formal language.  Every
    regular expression is either an alphabet symbol, specifying the singleton set
    containing that symbol, or composed from the following operations (where *R* and
    *S* are REs):'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正规表达式。* ![正规表达式的解剖](../Images/5c37c369804b9993c1eef084faf1381d.png) 正规表达式（RE）是指定形式语言的符号串。每个正规表达式都是一个字母表符号，指定包含该符号的单例集，或者由以下操作组成（其中
    *R* 和 *S* 是 REs）：'
- en: 'Union: *R* | *S*, specifying the union of the sets *R* and *S*,'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并集* *R* | *S*，指定集合 *R* 和 *S* 的并集，'
- en: 'Concatenation: *RS*, specifying the concatenation of the sets *R* and *S*,'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接：*RS*，指定集合 *R* 和 *S* 的连接，
- en: 'Closure: R*, specifying the closure of the set *R*,'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包：R*，指定集合 *R* 的闭包，
- en: 'Parentheses: (*R*), specifying the same set as *R*.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号：(*R*)，指定与 *R* 相同的集合。
- en: '*Regular languages.* A formal language is *regular* if and only if it can be
    specified by an RE. Here are some examples:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正规语言。* 如果且仅当可以通过正规表达式指定时，形式语言才是*正规*的。以下是一些示例：'
- en: '![regular languages](../Images/f6faf32632e79afdb2631f1d150c1b7d.png)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![正规语言](../Images/f6faf32632e79afdb2631f1d150c1b7d.png)'
- en: Generalized REs.
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广义 REs。
- en: Our definition of REs is a minimal one that includes the four basic operations
    that characterize regular languages (concatenation, union, closure, and parentheses).
    In practice, it is useful to make various additions to this set.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对RE的定义是一个包含表征正则语言的四个基本操作（连接、并集、闭包和括号）的最小定义。在实践中，对这个集合进行各种添加是有用的。
- en: '![anatomy of a generalized regular expression](../Images/8a55362ae70aada8ede82e053bde6497.png)'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![广义正则表达式的解剖](../Images/8a55362ae70aada8ede82e053bde6497.png)'
- en: '*Expanding the alphabet.* We need an *escape mechanism* to allow us to use
    the metasymbols `|`, `*`, `(`, and `)` both to specify REs and as symbols in the
    language alphabet. Specifically, to use a metasymbol as a symbol in the alphabet,
    we precede it with the backslash character (`/`).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*扩展字母表.* 我们需要一个*转义机制*，允许我们使用元符号`|`、`*`、`(`和`)`来指定RE并作为语言字母表中的符号。具体来说，为了将元符号用作字母表中的符号，我们在其前面加上反斜杠字符（`/`）。'
- en: '*Shorthand notations.* Generalized REs support a number of shorthand notations,
    such as the following:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简写符号.* 广义RE支持许多简写符号，例如以下内容：'
- en: The wildcard symbol `.` matches any alphabet symbol.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符符号`.`匹配任何字母表符号。
- en: The metasymbol `^` matches the beginning of a line and `$` matches the end of
    a line.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元符号`^`匹配行的开头，`$`匹配行的结尾。
- en: A list or range of symbols enclosed in square brackets `[]` matches any symbol
    in the list or range.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用方括号`[]`括起的符号列表或范围匹配列表或范围中的任何符号。
- en: If the first character within the square braces is the `^` character, the specification
    refers to the Unicode characters *not* in the list or range.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方括号内的第一个字符是`^`字符，则该规范指的是不在列表或范围内的Unicode字符。
- en: Several escape sequences consisting of a backslash followed by an alphabet symbol
    match a defined set of symbols. For example, `\s` matches any whitespace symbol.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由反斜杠后跟字母表符号组成的几个转义序列匹配一组定义的符号。例如，`\s`匹配任何空白符号。
- en: '*Extensions to the closure operation.* Accordingly, Java REs have the following
    option for specifying restrictions on the number of repetitions of the closure
    operation:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对闭包操作的扩展.* 因此，Java RE具有以下选项，用于指定对闭包操作的重复次数的限制：'
- en: 'One or more: `+`'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个：`+`
- en: 'Zero or one: `?`'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或一个：`?`
- en: 'Exactly *n*: `{n}`'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恰好*n*次：`{n}`
- en: 'Between *m* and *n*: `{m, n}`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介于*m*和*n*之间：`{m, n}`
- en: 'The following table illustrates several of these shorthand notations:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格说明了其中几个简写符号：
- en: '![generalized regular expressions](../Images/adad229537562de2de56df6e23ef0ede.png)'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![广义正则表达式](../Images/adad229537562de2de56df6e23ef0ede.png)'
- en: Java includes many more [shorthands and extensions](http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html)
    that we will not explore.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Java包含许多更多的[简写和扩展](http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html)，我们将不探讨。
- en: Regular expressions in Java.
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java中的正则表达式。
- en: The `matches()` method in Java’s [String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-)
    library solves the recognition problem for generalized regular expressions. If
    `s` is any Java `String` and `re` is any regular expression, then `s.matches(re)`
    is true if `s` is in the language specified by `re`, and `false` otherwise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Java的[String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-)库中的`matches()`方法解决了广义正则表达式的识别问题。如果`s`是任何Java
    `String`，`re`是任何正则表达式，那么如果`s`在`re`指定的语言中，则`s.matches(re)`为真，否则为假。
- en: '*Validity checking.* [Validate.java](Validate.java.html) takes an RE as a command-line
    argument and, for each string on standard input, prints `Yes` if it is in the
    language specified by the RE, and `No` if it is not.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有效性检查.* [Validate.java](Validate.java.html)将一个RE作为命令行参数，并对标准输入中的每个字符串打印`Yes`，如果它在RE指定的语言中，则打印`No`。'
- en: '*Searching.* [Grep.java](Grep.java.html) takes an RE as a command-line argument
    and prints to standard output all the lines in standard input having a substring
    in the language described by the RE.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索.* [Grep.java](Grep.java.html)将一个RE作为命令行参数，并打印标准输入中所有具有RE描述的语言中的子字符串的行。'
- en: Deterministic finite-state automata.
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定有限状态自动机。
- en: A DFA is an abstract machine that consists of
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: DFA是一个由以下组成的抽象机器
- en: A finite number of *states*, each of which is designated as either an *accept*
    state or a *reject* state.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限数量的*状态*，每个状态被指定为*接受*状态或*拒绝*状态。
- en: A set of *transitions* that specify how the machine changes state. Each state
    has one transition for each symbol in the alphabet.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组*转换*指定了机器如何改变状态。每个状态对于字母表中的每个符号都有一个转换。
- en: A *tape reader* initially positioned at the first symbol of an input string
    and capable only of reading a symbol and moving to the next symbol.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*磁带阅读器*最初位于输入字符串的第一个符号处，只能读取一个符号并移动到下一个符号。
- en: We represent each DFA as a directed graph where accept states are vertices labeled
    *Yes*, reject states are vertices labeled *No*, and each transition is a directed
    edge that is labeled with a symbol from the alphabet. ![DFA trace](../Images/ef1caf0aff7c82b98dd0b8fc393a1682.png)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个DFA表示为一个有向图，其中接受状态是标记为*Yes*的顶点，拒绝状态是标记为*No*的顶点，每个转换是一个由字母表中的符号标记的有向边。![DFA跟踪](../Images/ef1caf0aff7c82b98dd0b8fc393a1682.png)
- en: '![DFA](../Images/363cff1688929f5c27c33deb1a5fbb0b.png)'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![DFA](../Images/363cff1688929f5c27c33deb1a5fbb0b.png)'
- en: '*Operation.* All DFAs start at state 0 with an input string on the tape and
    the tape head on the leftmost symbol in the input string. The machine operates
    by reading a symbol, moving the tape head right one position, and then changing
    state as specified by the transition labeled with the input symbol just read.
    When the input is exhausted, the DFA halts.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作.* 所有DFA都从状态0开始，输入字符串在磁带上，磁带头位于输入字符串的最左边的符号上。机器通过读取一个符号，将磁带头向右移动一个位置，然后根据刚刚读取的输入符号标记的转换来改变状态来操作。当输入用尽时，DFA停止。'
- en: '*Characterizing the language.* Each DFA *recognizes* a formal language—the
    set of all strings it accepts. For example, the above DFA recognizes all binary
    strings for which the number of `b`s is a multiple of 3.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*描述语言。* 每个DFA*识别*一个形式语言—它接受的所有字符串的集合。例如，上述DFA识别所有`b`的数量是3的倍数的二进制字符串。'
- en: '*Java implementation.* [DFA.java](DFA.java.html) takes a DFA specification
    (from a file named on the command line) and a sequence of strings from standard
    input and prints the result of running the DFA on the given input strings.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java实现。* [DFA.java](DFA.java.html)接受一个DFA规范（来自命令行上命名的文件）和一系列来自标准输入的字符串，并打印在给定输入字符串上运行DFA的结果。'
- en: Nondeterministic finite-state automata.
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非确定有限状态自动机。
- en: 'The behavior of a DFA is *deterministic*: for each input symbol and each state,
    there is exactly one possible state transition. A *nondeterministic finite automaton*
    (NFA) is the same as a DFA, but with restrictions on the transitions leaving each
    state removed, so that'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: DFA的行为是*确定性*的：对于每个输入符号和每个状态，都有一个可能的状态转换。*非确定性有限自动机*（NFA）与DFA相同，但是去除了离开每个状态的转换的限制，因此
- en: Multiple transitions labeled with the same symbol are allowed.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许有多个标记相同符号的转换。
- en: Unlabeled state transitions (*null transitions*) are allowed. Following a null
    transition does not consume an input symbol.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许未标记的状态转换（*空转换*）。跟随空转换不会消耗输入符号。
- en: Not all symbols need be included among the transitions leaving each state.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要将所有符号包含在离开每个状态的转换中。
- en: An NFA accepts a string if there is *any* sequence of transitions that can take
    the machine from the start state to an accept state.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果NFA接受一个字符串，则存在*任何*一系列转换可以将机器从起始状态转移到接受状态。
- en: '![nondeterministic finite-state automaton](../Images/90d6324544650249004c3ac327cd1573.png)
          ![nondeterministic finite-state automaton](../Images/a624649ba37c6633c429446e42853764.png)'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![非确定有限状态自动机](../Images/90d6324544650249004c3ac327cd1573.png)       ![非确定有限状态自动机](../Images/a624649ba37c6633c429446e42853764.png)'
- en: In the NFA at left, when in state 0 and reading an `a`, it can choose to stay
    in state 0 or make the transition to state 1. It recognizes binary strings whose
    second-to-last symbol is `a`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧的NFA中，当处于状态0并读取`a`时，它可以选择留在状态0或转移到状态1。它识别的是倒数第二个符号为`a`的二进制字符串。
- en: In the NFA at right, when it state 0, it can follow the null transition to state
    1, without consuming an input symbol. It recognizes binary strings that do not
    contain the substring `bba`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧的NFA中，当它处于状态0时，它可以跟随空转换到状态1，而不消耗输入符号。它识别的是不包含子字符串`bba`的二进制字符串。
- en: Kleene's theorem.
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克林定理。
- en: There is a striking connection among regular expressions, DFAs, and NFAs that
    has dramatic practical and theoretical consequences. Kleene's theorem asserts
    that REs, DFAs, and NFAs are equivalent models, in the sense that they all characterize
    the regular languages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式、DFA和NFA之间存在着引人注目的联系，这对实践和理论都有戏剧性的影响。克林定理断言，RE、DFA和NFA是等价的模型，因为它们都表征了正则语言。
- en: '*RE recognition.* Kleene''s theorem serves as the basis for a solution to the
    recognition problem for REs.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RE识别。* 克林定理为RE的识别问题提供了解决方案的基础。'
- en: Build an NFA that corresponds to the given RE.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建与给定RE对应的NFA。
- en: Simulate the operation of the NFA on the given input string.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟NFA对给定输入字符串的操作。
- en: That is the approach taken by Java to implement its `matches()` method that
    we considered earlier.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是Java实现其`matches()`方法所采取的方法。
- en: '*Limits on the power of DFAs.* Kleene’s theorem is also instrumental in helping
    us to shed light on a fundamental theoretical question: which formal languages
    can be described with an RE and which cannot? For example, the language containing
    all binary strings with an equal number of `a` and `b` symbols is not regular.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DFA能力的限制。* 克林定理还有助于我们阐明一个基本的理论问题：哪些形式语言可以用RE描述，哪些不行？例如，包含所有具有相等数量的`a`和`b`符号的二进制字符串的语言不是正则的。'
- en: '*Machines with more power.* One simple way to define a machine that can recognize
    more languages is to add a *pushdown stack* to the DFA, yielding a machine known
    as a *pushdown automaton* (PDA).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*功能更强大的机器。* 定义一个可以识别更多语言的机器的简单方法是向DFA添加一个*下推栈*，得到一个称为*下推自动机*（PDA）的机器。'
- en: '![pushdown automata (PDA)](../Images/6c6f594a9df5807ead4b4f53eeadffbc.png)'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![下推自动机（PDA）](../Images/6c6f594a9df5807ead4b4f53eeadffbc.png)'
- en: It is not difficult to develop a PDA that can recognize binary strings with
    an equal number of `a` and `b` symbols. In the next section, we will consider
    *Turing machines*, which is the abstract machine that lies at the heart of computer
    science.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开发一个PDA来识别具有相等数量的`a`和`b`符号的二进制字符串并不困难。在下一节中，我们将考虑*图灵机*，这是计算机科学核心的抽象机器。
- en: Exercises
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Give an RE that specifies each of the following languages over the binary alphabet.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出一个RE，指定以下二进制字母表中的每种语言。
- en: All strings except empty string
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有字符串除了空字符串
- en: Contains at least three consecutive `b`s
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含至少三个连续的`b`
- en: Starts with `a` and has odd length, or starts with `b` and has even length
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`a`开头且长度为奇数，或以`b`开头且长度为偶数
- en: No consecutive `b`s
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有连续的`b`
- en: Any string except `bb` or `bbb`
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了`bb`或`bbb`之外的任何字符串
- en: Starts and ends with the same symbol
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同符号开头和结尾
- en: Contains at least two `a`s and at most one `b`
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含至少两个`a`且最多一个`b`
- en: '*Solutions*: `(a|b)(a|b)*`, `(a|b)*bbb(a|b)*`, `a((a|b)(a|b))* | b(a|b)((a|b)(a|b))*`,
    ...'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：`(a|b)(a|b)*`，`(a|b)*bbb(a|b)*`，`a((a|b)(a|b))* | b(a|b)((a|b)(a|b))*`，...'
- en: Creative Exercises
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Harvester.** Write a [Pattern](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)
    and [Matcher](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html)
    client [Harvester.java](Harvester.java.html) that takes a file name (or URL) andd
    an RE as command-line inputs and prints all substrings in a file that match the
    RE.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**收割机。** 编写一个[Pattern](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)和[Matcher](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html)客户端[Harvester.java](Harvester.java.html)，它接受文件名（或URL）和RE作为命令行输入，并打印文件中与RE匹配的所有子字符串。'
- en: '**Web crawling.** Develop a program [WebCrawler.java](WebCrawler.java.html)
    that prints all web pages that can be accessed from the web page given as a command-line
    argument.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**网络爬虫。** 开发一个程序[WebCrawler.java](WebCrawler.java.html)，打印出可以从作为命令行参数给出的网页访问的所有网页。'
- en: '**Search and replace.** Write a filter [SearchAndReplace.java](SearchAndReplace.java.html)
    that takes an RE and a string `str` as command-line arguments, reads a string
    from standard input, replaces all substrings on standard input that match the
    RE with `str`, and sends the results to standard output. First solve the problem
    using the `replaceAll()` method in Java’s `String` library; then solve it without
    using that method.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**搜索和替换。** 编写一个过滤器[SearchAndReplace.java](SearchAndReplace.java.html)，它接受一个RE和一个字符串`str`作为命令行参数，从标准输入读取一个字符串，用`str`替换所有与RE匹配的标准输入上的子字符串，并将结果发送到标准输出。首先使用Java的`String`库中的`replaceAll()`方法解决问题；然后解决方法是不使用该方法。'
- en: Web Exercises (Regular Expressions)
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习（正则表达式）
- en: Give an RE that specifies each of the following languages over {0, 1}.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出一个RE，指定以下每个语言{0, 1}。
- en: '`a` or `bb` or `bab`'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`或`bb`或`bab`'
- en: only `a`s
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有`a`
- en: all binary strings
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有二进制字符串
- en: begins with `a`, ends with `a`
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`a`开头，以`a`结尾
- en: ends with `aa`
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`aa`结尾
- en: '*Answers*: a | bb | bab, a*, (a|b)*, a(a|b)*a | a, (a|b)*aa'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：a | bb | bab, a*, (a|b)*, a(a|b)*a | a, (a|b)*aa'
- en: 'Write a regular expression to describe inputs over the alphabet {a, b, c} that
    are in sorted order. *Answer*: a*b*c*.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式来描述字母表{a, b, c}上的输入，这些输入按排序顺序排列。*答案*：a*b*c*。
- en: Write a regular expression for each of the following sets of binary strings.
    Use only the basic operations.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以下每组二进制字符串编写一个正则表达式。仅使用基本操作。
- en: contains at least three consecutive 1s
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含至少三个连续的1
- en: contains the substring 110
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含子字符串110
- en: contains the substring 1101100
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含子字符串1101100
- en: doesn't contain the substring 110
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不包含子字符串110
- en: '*Answers*: (0|1)*111(0|1)*, (0|1)*110(0|1)*, (0|1)*1101100(0|1)*, (0|10)*1*.
    The last one is by far the trickiest.'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：(0|1)*111(0|1)*, (0|1)*110(0|1)*, (0|1)*1101100(0|1)*, (0|10)*1*。最后一个是最棘手的。'
- en: Write a regular expression for binary strings with at least two 0s but not consecutive
    0s.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为至少有两个0但不连续的0的二进制字符串编写一个正则表达式。
- en: Write a regular expression for each of the following sets of binary strings.
    Use only the basic operations.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以下每组二进制字符串编写一个正则表达式。仅使用基本操作。
- en: has at least 3 characters, and the third character is 0
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少有3个字符，第三个字符是0
- en: number of 0s is a multiple of 3
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0的数量是3的倍数
- en: odd length
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奇数长度
- en: length is at least 1 and at most 3
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 长度至少为1且最多为3
- en: '*Answers*: (0|1)(0|1)0(0|1)*,   1* | (1*01*01*01*)*,   (0|1)((0|1)(0|1))*,
      (0|1) | (0|1)(0|1) | (0|1)(0|1)(0|1).'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：(0|1)(0|1)0(0|1)*,   1* | (1*01*01*01*)*,   (0|1)((0|1)(0|1))*,   (0|1)
    | (0|1)(0|1) | (0|1)(0|1)(0|1)。'
- en: 'For each of the following, indicate how many bit strings of length exactly
    1000 are matched by the regular expression: `0(0 | 1)*1`, `0*101*`, `(1 | 01)*`.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于以下每个问题，指出正则表达式`0(0 | 1)*1`，`0*101*`，`(1 | 01)*`精确匹配长度为1000的位字符串的数量。
- en: 'Write a regular expression that matches all strings over the alphabet {a, b,
    c} that contain:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式，匹配包含以下内容的字母表{a, b, c}的所有字符串：
- en: starts and ends with a
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`a`开头并以`a`结尾
- en: at most one a
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最多一个a
- en: at least two a's
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少有两个a
- en: an even number of a's
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 偶数个a
- en: number of a's plus number of b's is even
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a的数量加上b的数量是偶数
- en: 'Find long words whose letters are in alphabetical order, e.g., `almost` and
    `beefily`. *Answer*: use the regular expression ''^a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*$''.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出字母按字母顺序排列的长单词，例如`almost`和`beefily`。*答案*：使用正则表达式'^a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*$'。
- en: Write a Java regular expression to match phone numbers, with or without area
    codes. The area codes should be of the form (609) 555-1234 or 555-1234.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，匹配电话号码，带有或不带有区号。区号应为(609) 555-1234或555-1234的形式。
- en: Find all English words that end with `nym`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出所有以`nym`结尾的英文单词。
- en: 'Final all English words that contain the trigraph `bze`. *Answer*: subzero.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出所有包含三连字母`bze`的英文单词。*答案*：subzero。
- en: 'Find all English words that start with g, contain the trigraph `pev` and end
    with e. *Answer*: grapevine.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出所有以g开头，包含三连字母`pev`且以e结尾的英文单词。*答案*：grapevine。
- en: Find all English words that contain the trigraph `spb` and have at least two
    r's.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出所有包含三连字母`spb`且至少有两个r的英文单词。
- en: 'Find the longest English word that can be written with the top row of a standard
    keyboard. *Answer*: proprietorier.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出可以用标准键盘顶行打出的最长英文单词。*答案*：proprietorier。
- en: 'Find all words that contain the four letters a, s, d, and f, not necessarily
    in that order. *Solution*: `cat words.txt | grep a | grep s | grep d | grep f`.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出包含字母a、s、d和f的所有单词，不一定按顺序。*解决方案*：`cat words.txt | grep a | grep s | grep d |
    grep f`。
- en: Given a string of A, C, T, and G, and X, find a string where X matches any single
    character, e.g., CATGG is contained in ACTGGGXXAXGGTTT.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个由A、C、T和G以及X组成的字符串，找到一个字符串，其中X匹配任何单个字符，例如，CATGG包含在ACTGGGXXAXGGTTT中。
- en: Write a Java regular expression, for use with [Validate.java](Validate.java.html),
    that validates Social Security numbers of the form 123-45-6789. *Hint:* use `\d`
    to represent any digit. *Answer:* `[0-9]{3}-[0-9]{2}-[0-9]{4}`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，用于[Validate.java](Validate.java.html)，验证形式为123-45-6789的社会安全号码。*提示*：使用`\d`表示任何数字。*答案*：`[0-9]{3}-[0-9]{2}-[0-9]{4}`。
- en: Modify the previous exercise to make the `-` optional, so that 123456789 is
    considered a legal input.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改上一个练习，使`-`成为可选项，这样123456789被视为合法输入。
- en: Write a Java regular expression to match all strings that contain exactly five
    vowels and the vowels are in alphabetical order. *Answer:* `[^aeiou]*a[^aeiou]*e[^aeiou]*i[^aeiou]*o[^aeiou]*u[^aeiou]*`
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，匹配所有包含正好五个元音字母且元音字母按字母顺序排列的字符串。*答案*：`[^aeiou]*a[^aeiou]*e[^aeiou]*i[^aeiou]*o[^aeiou]*u[^aeiou]*`
- en: Write a Java regular expression to match valid Windows XP file names. Such a
    file name consists of any sequence of characters other than
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式来匹配有效的Windows XP文件名。这样的文件名由除了任意字符序列组成
- en: '[PRE3]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Additionally, it cannot begin with a space or period.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，不能以空格或句号开头。
- en: Write a Java regular expression to match valid OS X file names. Such a file
    name consists of any sequence of characters other than a colon. Additionally,
    it cannot begin with a period.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，匹配有效的OS X文件名。这样的文件名由除冒号外的任意字符序列组成。此外，它不能以句点开头。
- en: Given a string `s` that represents the name of an IP address in *dotted quad*
    notation, break it up into its constituent pieces, e.g., 255.125.33.222. Make
    sure that the four fields are numeric.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个表示IP地址名称的字符串`s`，采用*dotted quad*表示法，将其分解为其组成部分，例如，255.125.33.222。确保四个字段都是数字。
- en: 'Write a Java regular expression to describe valid IP addresses of the form
    a.b.c.d where each letter can represent 1, 2, or 3 digits, and the periods are
    required. Yes: 196.26.155.241.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，描述形式为a.b.c.d的有效IP地址，其中每个字母可以表示1、2或3位数字，并且必须有句点。是的：196.26.155.241。
- en: Write a Java regular expression to match license plates that start with 4 digits
    and end with two uppercase letters.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，匹配以4位数字开头并以两个大写字母结尾的车牌。
- en: Write a regular expression to extract the coding sequence from a DNA string.
    It starts with the ATG codon and ends with a stop codon (TAA, TAG, or TGA). [reference](http://bioportal.weizmann.ac.il/course/prog/regexps/5.html)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式，从DNA字符串中提取编码序列。它以ATG密码子开头，并以终止密码子（TAA、TAG或TGA）结尾。[参考](http://bioportal.weizmann.ac.il/course/prog/regexps/5.html)
- en: 'Write a regular expression to check for the sequence rGATCy: that is, does
    it start with A or G, then GATC, and then T or C.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式，检查序列是否以rGATCy开头：即，它是否以A或G开头，然后是GATC，最后是T或C。
- en: Write a regular expression to check whether a sequence contains two or more
    repeats of the the GATA tetranucleotide.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式，检查序列是否包含两个或更多次重复的GATA四核苷酸。
- en: Modify [Validate.java](Validate.java.html) to make the searches case insensitive.
    *Hint:* use the `(?i)` embedded flag.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[Validate.java](Validate.java.html)以使搜索不区分大小写。*提示*：使用嵌入式标志`(?i)`。
- en: 'Write a Java regular expression to match various spellings of Libyan dictator
    Moammar Gadhafi''s last name using the folling template: (i) starts with K, G,
    Q, (ii) optionally followed by H, (iii) followed by AD, (iv) optionally followed
    by D, (v) optionally followed by H, (vi) optionally followed by AF, (vii) optionally
    followed by F, (vii) ends with I.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java正则表达式，匹配利比亚独裁���穆阿迈尔·卡扎菲姓氏的各种拼写，使用以下模板：（i）以K、G、Q开头，（ii）可选地跟随H，（iii）后跟AD，（iv）可选地跟随D，（v）可选地跟随H，（vi）可选地跟随AF，（vii）可选地跟随F，（vii）以I结尾。
- en: Write a Java program that reads in an expression like `(K|G|Q)[H]AD[D][H]AF[F]I`
    and prints out all matching strings. Here the notation `[x]` means 0 or 1 copy
    of the letter `x`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Java程序，读取类似`(K|G|Q)[H]AD[D][H]AF[F]I`的表达式，并打印出所有匹配的字符串。这里的符号`[x]`表示字母`x`的0或1个副本。
- en: Why doesn't `s.replaceAll("A", "B");` replace all occurrences of the letter
    A with B in the string s?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`s.replaceAll("A", "B");`不会替换字符串`s`中所有出现的字母A为B？
- en: '*Answer*: Use `s = s.replaceAll("A", "B");` instead The method `replaceAll`
    returns the resulting string, but does not change `s` itself. Strings are immutable.'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：使用`s = s.replaceAll("A", "B");`。方法`replaceAll`返回结果字符串，但不更改`s`本身。字符串是不可变的。'
- en: Write a program [Clean.java](Clean.java.html) that reads in text from standard
    input and prints it back out, removing any trailing whitespace on a line and replacing
    all tabs with 4 spaces.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Clean.java](Clean.java.html)，从标准输入读取文本并将其打印出来，删除每行末尾的空格，并用4个空格替换所有制表符。
- en: '*Hint:* use `replaceAll()` and the regular expression `\s` for whitespace.'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：使用`replaceAll()`和正则表达式`\s`匹配空格。'
- en: 'Write a regular expression to match all of the text between the text `a href
    ="` and the next `"`. *Answer*: `href=\"(.*?)\"`. The `?` makes the `.*` reluctant
    instead of greedy. In Java, use `Pattern.compile("href=\\\"(.*?)\\\"", Pattern.CASE_INSENSITIVE)`
    to escape the backslash characters.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式，匹配文本`a href ="`和下一个`"`之间的所有文本。*答案*：`href=\"(.*?)\"`。`?`使`.*`变得不贪婪而是勉强。在Java中，使用`Pattern.compile("href=\\\"(.*?)\\\"",
    Pattern.CASE_INSENSITIVE)`来转义反斜杠字符。
- en: Write a program [Title.java](Title.java.html) to extract all of the text between
    the tags `<title>` and `<\title>`. The `(?i)` is makes the match case insensitive.
    The `$2` refers to the second captured subsequence, i.e., the stuff between the
    `title` tags.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Title.java](Title.java.html)，提取标签`<title>`和`<\title>`之间的所有文本。`(?i)`使匹配不区分大小写。`$2`指的是第二个捕获的子序列，即`title`标签之间的内容。
- en: '[PRE4]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Write a regular expression to match all of the text between <TD ...> and </TD>
    tags. *Answer*: `<TD[^>]*>([^<]*)</TD>`'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个正则表达式，匹配在<TD ...>和</TD>标签之间的所有文本。*答案*：`<TD[^>]*>([^<]*)</TD>`
- en: '**Regular expression for permutations.** Find the shortest regular expression
    (using only the basic operations) you can for the set of all permutations on n
    elements for n = 5 or 10. For example if n = 3, then the language is abc, acb,
    bac, bca, cab, cba. *Answer*: difficult. Solution has length exponential in n.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排列的正则表达式。**找到一组所有n个元素的排列的最短正则表达式（仅使用基本操作），其中n = 5或10。例如，如果n = 3，则语言是abc、acb、bac、bca、cab、cba。*答案*：困难。解决方案的长度与n的指数成正比。'
- en: Web Exercises (DFAs and NFAs)
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Web练习（DFAs和NFAs）
- en: Draw a 4-state DFA that accepts the set of all bitstrings ending with 11\. (Each
    state represents whether the input string read in so far ends with 00, 01, 10,
    or 11.) Draw a 3-state DFA that accomplishes the same task.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个接受以11结尾的所有比特串的4状态DFA。（每个状态表示到目前为止读入的输入字符串是否以00、01、10或11结尾。）绘制一个完成相同任务的3状态DFA。
- en: Draw a DFA for bitstrings with at least one 0 and at least one 1.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为至少包含一个0和至少包含一个1的比特串编写一个DFA。
- en: 'Draw an NFA that matches all strings that contain either a multiple of three
    0s or a multiple of five 1s. *Hint*: Use 3 + 5 + 1 = 9 states and one epsilon
    transition.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个NFA，匹配所有包含三个0的倍数或五个1的倍数的字符串。*提示*：使用3 + 5 + 1 = 9个状态和一个ε转换。
- en: Draw an NFA that recognize the language of all strings that end in aaab.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个NFA，识别所有以aaab结尾的字符串的语言。
- en: Draw an NFA that recognize the language of all strings whose 4th to the last
    character is a.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个NFA，识别所有倒数第四个字符为a的字符串的语言。
- en: Draw an NFA that recognize the language of all strings whose 5th to the last
    character is a.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个识别语言的 NFA，该语言的所有字符串的第五个到最后一个字符是 a。
- en: Give a NFA with 5 accept states. Write an equivalent NFA that has exactly one
    accept state.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出一个具有 5 个接受状态的 NFA。写出一个具有仅一个接受状态的等价 NFA。
- en: Give a NFA with ε-transitions. Write an equivalent NFA that has no ε-transitions.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出一个具有 ε-转换的 NFA。写出一个没有 ε-转换的等价 NFA。
- en: '**Unary divisibility.** Given an DFA that accepts bitstrings with a multiple
    of three 0s and a multiple of five 1s.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一元可除性。** 给定一个接受具有三个 0 的倍数和五个 1 的倍数的比特串的 DFA。'
- en: '**DFA for permutations.** Find the shortest DFA you can for the set of all
    permutations on n elements for n = 5 or 10.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排列的 DFA。** 找出对于 n = 5 或 10 的所有 n 元素排列集合的最短 DFA。'
- en: '**Mealy and Moore machines.** Mealy: DFA with output on each transition edge.
    Moore: DFA with output on each state.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Mealy 和 Moore 机。** Mealy：每个转换边上都有输出的 DFA。Moore：每个状态上都有输出的 DFA。'
- en: Web Exercises
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习
- en: '**Text-to-speech synthesis.** Original motivation for grep. "For example, how
    do you cope with the digraph ui, which is pronounced many different ways: fruit,
    guile, guilty, anguish, intuit, beguine?"'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文本到语音合成。** grep 的原始动机。"例如，你如何处理发音多种不同的二合字 ui：fruit, guile, guilty, anguish,
    intuit, beguine?"'
- en: '**Boston accent.** Write a program to replace all of the r''s with h''s to
    translate a sentence like "Park the car in Harvard yard" into the Bostonian version
    "Pahk the cah in Hahvahd yahd".'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波士顿口音。** 编写一个程序，将所有的 r 替换为 h，将句子翻译成波士顿版本，如 "Park the car in Harvard yard"
    翻译成波士顿版本 "Pahk the cah in Hahvahd yahd"。'
- en: '**File extension.** Write a program that takes the name of a file as a command
    line argument and prints out its file type extension. The *extension* is the sequence
    of characters following the last `.`. For example the file `sun.gif` has the extension
    `gif`. Hint: use `split("\\.")`; recall that `.` is a regular expression meta-character,
    so you need to escape it.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文件扩展名。** 编写一个程序，接受文件名作为命令行参数并打印出其文件类型扩展名。*扩展名* 是最后一个 `.` 后面的字符序列。例如，文件 `sun.gif`
    的扩展名是 `gif`。提示：使用 `split("\\.")`；回想一下 `.` 是一个正则表达式元字符，所以你需要转义它。'
- en: '**Reverse subdomains.** For web log analysis, it is convenient to organize
    web traffic based on subdomains like `wayne.faculty.cs.princeton.edu`. Write a
    program to read in a domain name and print it out in reverse order like `edu.princeton.cs.faculty.wayne`.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反转子域。** 对于网络日志分析，根据子域（如 `wayne.faculty.cs.princeton.edu`）方便地组织网络流量。编写一个程序，读取一个域名并以反向顺序打印出来，如
    `edu.princeton.cs.faculty.wayne`。'
- en: '**Bank robbery.** You just witnessed a bank robbery and got a partial license
    plate of the getaway vehicle. It started with `ZD`, had a `3` somewhere in the
    middle and ended with `V`. Help the police officer write regular expression for
    this plate.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**银行抢劫。** 你刚刚目击了一起银行抢劫，并得到了逃跑车辆的部分车牌。它以 `ZD` 开头，中间某处有一个 `3`，以 `V` 结尾。帮助警官为这个车牌写一个正则表达式。'
- en: '**Parsing quoted strings.** Read in a text file and print out all quote strings.
    Use a regular expression like `"[^"]*"`, but need to worry about escaping the
    quotation marks.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析带引号的字符串。** 读取一个文本文件并打印出所有带引号的字符串。使用类似 `"[^"]*"` 的正则表达式，但需要担心转义引号。'
- en: '**Parsing HTML.** A >, optionally followed by whitespace, followed by `a`,
    followed by whitespace, followed by `href`, optionally followed by whitespace,
    followed by `=`, optionally followed by whitespace, followed by `"http://`, followed
    by characters until `"`, optionally followed by whitespace, then a `<`.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析 HTML。** 一个 >，可选跟随空格，跟随 `a`，跟随空格，跟随 `href`，可选跟随空格，跟随 `=`，可选跟随空格，跟随 `"http://`，跟随直到
    `" `的字符，可选跟随空格，然后是一个 `<`。'
- en: '[PRE5]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Subsequence.** Given a string s, determine whether it is a subsequence of
    another string t. For example, abc is a subsequence of achfdbaabgabcaabg. Use
    a regular expression. Now repeat the process without using regular expressions.
    Answer: (a) a.*b.*c.*, (b) use a greedy algorithm.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**子序列。** 给定一个字符串 s，确定它是否是另一个字符串 t 的子序列。例如，abc 是 achfdbaabgabcaabg 的子序列。使用正则表达式。现在重复这个过程，不使用正则表达式。答案：(a)
    a.*b.*c.*，(b) 使用贪婪算法。'
- en: '**Huntington''s disease diagnostic.** The gene that causes Huntington''s disease
    is located on chromosome 4, and has a variable number of repeats of the CAG trinucleotide
    repeat. Write a program to determine the number of repeats and print `will not
    develop HD` If the number of repeats is less than 26, `offspring at risk` if the
    number is 37-35, `at risk` if the number is between 36 and 39, and `will develop
    HD` if the number is greater than or equal to 40. This is how Huntington''s disease
    is identified in genetic testing.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**亨廷顿病诊断。** 导致亨廷顿病的基因位于染色体 4 上，并具有 CAG 三核苷酸重复的可变次数。编写一个程序来确定重复次数，并打印出 `will
    not develop HD` 如果重复次数小于 26，`offspring at risk` 如果次数为 37-35，`at risk` 如果次数在 36
    和 39 之间，如果次数大于或等于 40，则打印 `will develop HD`。这就是亨廷顿病在遗传测试中的识别方式。'
- en: '**Repeat finder.** Write a program `Repeat.java` that takes two command line
    arguments, and finds the maximum number of repeats of the first command line argument
    in the file specified by the second command line argument.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重复查找器。** 编写一个程�� `Repeat.java`，它接受两个命令行参数，并在指定的文件中找到第一个命令行参数的最大重复次数。'
- en: '**Character filter.** Given a string `t` of *bad characters*, e.g. `t = "!@#$%^&*()-_=+"`,
    write a function to read in another string `s` and return the result of removing
    all of the bad characters.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字符过滤器。** 给定一组 *坏字符* 的字符串 `t`，例如 `t = "!@#$%^&*()-_=+"`，编写一个函数来读取另一个字符串 `s`
    并返回删除所有坏字符的结果。'
- en: '[PRE6]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Wildcard pattern matcher.** Without using Java''s built in regular expressions,
    write a program [Wildcard.java](Wildcard.java.html) to find all words in the dictionary
    matching a given pattern. The special symbol * matches any zero or more characters.
    So, for example the pattern "w*ard" matches the word "ward" and "wildcard". The
    special symbol . matches any one character. Your program should read the pattern
    as a command line parameter and the list of words (separated by whitespace) from
    standard input.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通配符模式匹配器。** 在不使用Java内置正则表达式的情况下，编写一个程序[Wildcard.java](Wildcard.java.html)来查找字典中与给定模式匹配的所有单词。特殊符号*匹配任意零个或多个字符。因此，例如模式"w*ard"匹配单词"ward"和"wildcard"。特殊符号.匹配任何一个字符。您的程序应该将模式作为命令行参数读取，并从标准输入读取单词列表（以空格分隔）。'
- en: '**Wildcard pattern matcher.** Repeat the previous exercise, but this time use
    Java''s built in regular expressions. *Warning:* in the context of wildcards,
    * has a different meaning than with regular expressions.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通配符模式匹配器。** 重复上一个练习，但这次使用Java内置的正则表达式。*警告:*在通配符的上下文中，*与正则表达式的含义不同。'
- en: '**Password validator.** Suppose that for security reasons you require all passwords
    to have at least one of the following characters'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**密码验证器。** 假设出于安全原因，您要求所有密码至少包含以下字符之一'
- en: '[PRE7]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Write a regular expression for use with `String.matches` that returns `true`
    if and only if the password contains one of the required characters. *Answer*:
    "^[^~!@#$%^&*|]+$"'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为`String.matches`编写一个正则表达式，如果密码包含所需字符之一，则返回`true`。*答案*："^[^~!@#$%^&*|]+$"
- en: '**Alphanumeric filter.** Write a program [Filter.java](Filter.java.html) to
    read in text from standard input and eliminate all characters that are not whitespace
    or alpha-numeric. *Answer* here''s the key line.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字母数字过滤器。** 编写一个程序[Filter.java](Filter.java.html)从标准输入读取文本并消除所有不是空格或字母数字的字符。*答案*这是关键行。'
- en: '[PRE8]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Converting tabs to spaces.** Write a program to convert all tabs in a Java
    source file to 4 spaces.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将制表符转换为空格。** 编写一个程序，将Java源文件中的所有制表符转换为4个空格。'
- en: '**Parsing delimited text files.** A popular way to store a database is in a
    text file with one record per line, and each field separated by a special character
    called the delimiter.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析分隔文本文件。** 存储数据库的一种流行方式是在文本文件中每行一个记录，并且每个字段由称为分隔符的特殊字符分隔。'
- en: '[PRE9]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Write a program [Tokenizer.java](Tokenizer.java.html) that reads in a delimiter
    character and the name of a file, and creates an array of tokens in the file.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[Tokenizer.java](Tokenizer.java.html)，该程序读取一个分隔符字符和一个文件名，并在文件中创建一个令牌数组。
- en: '**Parsing delimited text files.** Repeat the previous exercise, but use the
    `String` library method `split()`.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析分隔文本文件。** 重复上一个练习，但使用`String`库方法`split()`。'
- en: '**PROSITE to Java regular expression.** Write a program to read in a PROSITE
    pattern and print out the corresponding Java regular expression.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PROSITE到Java正则表达式。** 编写一个程序来读取PROSITE模式并打印出相应的Java正则表达式。'
- en: '**Misspellings.** Write a Java program to verify that this list of [common
    misspellings](misspellings.txt) adapted from [Wikipedia](http://en.wikipedia.org/wiki/Wikipedia:List_of_common_misspellings)
    contains only lines of the form'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拼写错误。** 编写一个Java程序来验证这个[常见拼写错误列表](misspellings.txt)是否只包含形式为的行'
- en: '[PRE10]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: where the first word is the misspelling and the string in parentheses is a possible
    replacement.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中第一个单词是拼写错误，括号中的字符串是可能的替换。
- en: '**Comment stripper.** Write a program [CommentStripper.java](CommentStripper.java.html)
    that reads in a Java (or C++) program from standard input, removes all comments,
    and prints the result to standard output. This would be useful as part of a Java
    compiler. It removes `/* */` and `//` style comments using a 5 state finite state
    automaton. It is meant to illustrate the power of DFAs, but to properly strip
    Java comments, you would need a few more states to handle extra cases, e.g., quoted
    string literals like `s = "/***//*"`. The picture below is courtesy of [David
    Eppstein](http://www.ics.uci.edu/~eppstein/161/960222.html).![DFA for stripping
    comments](../Images/14869da7ef48cc676ca8d7ae0244ec00.png)'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注释剥离器。** 编写一个程序[CommentStripper.java](CommentStripper.java.html)，从标准输入读取Java（或C++）程序，删除所有注释，并将结果打印到标准输出。这在Java编译器的一部分中很有用。它使用一个5状态有限状态自动机来删除`/*
    */`和`//`样式的注释。它旨在说明DFA的强大之处，但要正确剥离Java注释，您需要更多状态来处理额外情况，例如，像`s = "/***//*"`这样的引号字符串文字。下面的图片由[David
    Eppstein](http://www.ics.uci.edu/~eppstein/161/960222.html)提供。![用于剥离注释的DFA](../Images/14869da7ef48cc676ca8d7ae0244ec00.png)'
- en: '**Improved comment stripper.** Modify [CommentStripper.java](CommentStripper.java.html)
    to properly handle characters within quote strings.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**改进的注释剥离器。** 修改[CommentStripper.java](CommentStripper.java.html)以正确处理引号字符串内的字符。'
- en: '**Sleep on it.** An experiment conducted by German neurologists and documented
    in Nature, volume 427 (2004), p. 352 hypothesizes that students who get more sleep
    are able to solve tricky problems better than students who are sleep deprived.
    The problem they used involves a string consisting of the three digits 1, 4, and
    9. "Comparing" two digits that are the same yields the original digit; comparing
    two digits that are different yields the missing digit. For example f(1, 1) =
    1, f(4, 4) = 4, f(1, 4) = 9, f(9, 1) = 4. Compare the first two digits of the
    input string, and then repeatedly compare the current result with the next digit
    in the string. Given a specific string, what number do you end up with? For example,
    if the input is string 11449494, you end up with 9.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**睡一觉吧。** 德国神经学家在《自然》杂志427卷（2004年）第352页记录的一项实验假设，睡眠充足的学生比睡眠不足的学生更能解决棘手的问题。他们使用的问题涉及一个由三个数字1、4和9组成的字符串。"比较"两个相同的数字会产生原始数字；比较两个不同的数字会产生缺失的数字。例如f(1,
    1) = 1, f(4, 4) = 4, f(1, 4) = 9, f(9, 1) = 4。比较输入字符串的前两个数字，然后重复比较当前结果与字符串中的下一个数字。给定一个特定的字符串，你最终得到什么数字？例如，如果输入是字符串11449494，你最终得到9。'
- en: '[PRE11]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
