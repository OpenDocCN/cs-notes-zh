- en: 3.3   Designing Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/java/33design](https://introcs.cs.princeton.edu/java/33design)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this section we discuss *encapsulation*, *immutability*, and *inheritance*,
    with particular attention to the use of these mechanisms in *data-type design*
    to enable modular programming, facilitate debugging, and write clear and correct
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of separating clients from implementations by hiding information
    is known as *encapsulation*. We use encapsulation to enable modular programming,
    facilitate debugging, and clarify program code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Complex numbers revisited.* ![polar representation](../Images/0747bc2d9355e592411282422db02eaa.png)
    [Complex.java](Complex.java.html) has the same API as [Complex.java](../32class/Complex.java.html),
    except that it represents a complex number using *polar coordinates* \(r (\cos
    \theta + i \sin \theta)\) instead of *Cartesian coordinates* as \(x + iy\).  The
    idea of encapsulation is that we can substitute one of these programs for the
    other without changing client code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Private.* When you declare an instance variable (or method) to be `private`,
    you are making it impossible for any client (code in another class) to directly
    access that instance variable (or method). This helps enforce encapsulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Limiting the potential for error.* Encapsulation also helps programmers ensure
    that their code operates as intended. To understand the problem, consider [Counter.java](Counter.java.html),
    which encapsulates a single integer and ensures that the only operation that can
    be performed on the integer is *increment by 1*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Counter API](../Images/425bb62facc3778099b32924bb7ff3e3.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'Without the `private` modifier, a client could write code like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `private` modifier, code like this will not compile.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Immutability.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Immutable and mutable data types](../Images/d9ca53c7d0d086d77e7b3b10ed75ceff.png)
    An object from a data type is *immutable* if its data-type value cannot change
    once created. An *immutable data type* is one in which all objects of that type
    are immutable.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Advantages of immutability.* We can use immutable objects in assignment statements
    (or as arguments and return values from methods) without having to worry about
    their values changing. This makes immutable type easier to reason about and debug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cost of immutability.* The main drawback of immutability is that a new object
    must be created for every value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Final.* When you declare an instance variable as `final`, you are promising
    to assign it a value only once. This helps enforce immutability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reference types.* The `final` access modifier does not guarantee immutability
    for instance variables of mutable types. In such cases, you must make a *defensive
    copy*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spatial vectors.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Vector](../Images/0032311a95197dd29f29960fa72a53b2.png)  A *spatial vector*
    is an abstract entity that has a *magnitude* and a *direction*.  A sequence of
    *n* real numbers suffices to specify a vector in *n*-dimensional space. We use
    a boldface letter like \( \boldsymbol{x} \) to denote the vector \( ( x_0, x_1,
    \; \ldots, \; x_{n-1}) \).'
  prefs: []
  type: TYPE_NORMAL
- en: '*API.* The basic operations on vectors are to add two vectors, multiply a vector
    by a scalar, compute the dot product of two vectors, and to compute the magnitude
    and direction, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Addition*: \( \boldsymbol{x} + \boldsymbol{y} = ( x_0 + y_0, x_1 + y_1, \;
    \ldots, \; x_{n-1} + y_{n-1}) \)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vector scaling*: \( \alpha \boldsymbol{x} = (\alpha x_0, \alpha x_1, \; \ldots,
    \; \alpha x_{n-1}) \)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dot product* \( \boldsymbol{x} \cdot \boldsymbol{y} = x_0y_0 + x_1y_1 + \,
    \ldots \, + x_{n-1}y_{n-1} \)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Magnitude*: \( \left | \boldsymbol{x} \right | = \sqrt{x_0^2 + x_1^2 + \,
    \ldots \, + x_{n-1}^2} \)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Direction*: \( \boldsymbol{x} \,/\, \left | \boldsymbol{x} \right | = (x_0
    \,/\, \left | \boldsymbol{x} \right |, x_1 \,/\, \left | \boldsymbol{x} \right
    |, \; \ldots, \; x_{n-1} \,/\, \left | \boldsymbol{x} \right |) \)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These basic mathematical definitions lead immediately to an API:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Vector API](../Images/ccb39170a5f0e8c2263d0481300effab.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Implementation.* [Vector.java](Vector.java.html) is an immutable data type
    that implements this API. Internally, it uses an array of length *n* to store
    the Cartesian coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The this reference.* Within an instance method (or constructor), the `this`
    keyword gives us a way to refer to the object whose instance method (or constructor)
    is being called. For example, the `magnitude()` method in Vector uses the `this`
    keyword in two ways: to invoke the `dot()` method and as the argument to the `dot()`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Interface inheritance (subtyping).
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java provides the `interface` construct for declaring a relationship between
    otherwise unrelated classes, by specifying a common set of methods that each implementing
    class must include. Interfaces enable us to write client programs that can manipulate
    objects of varying types, by invoking common methods from the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '*Defining an interface.* [Function.java](Function.java.html) defines an interface
    for real-valued functions of a single variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The body of the interface contains a list of *abstract methods*. An abstract
    method is a method that is declared but does not include any implementation code;
    it contains only the method signature. You must save a Java interface in a file
    whose name matches the name of the interface, with a `.java` extension.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Implementing an interface.* To write a class that implements an interface,
    you must do two things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include an `implements` clause in the class declaration with the name of the
    interface.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement each of the abstract methods in the interface.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, [Square.java](Square.java.html) and [GaussianPDF.java](GaussianPDF.java.html)
    implements the `Function` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Using an interface.* An interface is a reference type. So, you can declare
    the type of a variable to be the name of an interface. When you do so, any object
    you assign to that variable must be an instance of a class that implements the
    interface. For example, a variable of type `Function` may store an object of type
    `Square` or `GaussianPDF`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a variable of an interface type invokes a method declared in the interface,
    Java knows which method to call because it knows the type of the invoking object.
    This powerful programming mechanism is known as *polymorphism* or *dynamic dispatch*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Plotting functions.* [FunctionGraph.java](FunctionGraph.java.html) plots the
    graph of a real-valued function *f* in the interval [*a*, *b*] by sampling the
    function at *n* + 1 evenly spaced points. It works for any sufficiently smooth
    function `f` that implements the `Function` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![plotting a function graph](../Images/6413348270fbdc0917bf7ac7889bcc4b.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Numerical integration.* [RectangleRule.java](RectangleRule.java.html) estimates
    the integral of a positive real-valued function *f* in an interval (*a*, *b*)
    using the *rectangle rule*. It works for any sufficiently smooth function `f`
    that implements the `Function` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![rectangle rule](../Images/3244b4f0c7bf2b0e53736bdc61c0afc0.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Lambda expressions.* To simplify syntax, Java provides a powerful functional
    programming feature known as *lambda expressions*. You should think of a lambda
    expression as a block of code that you can pass around and execute later. In its
    simplest form, a lambda expression consists of the three elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of parameters variables, separated by commas, and enclosed in parentheses
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lambda operator* `->`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A single expression, which is the value returned by the lambda expression
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following lambda expression implements the hypotenuse function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![anatomy of a lambda expression](../Images/9fd3e4ec1fb6072a7fbddb64ab41f0dc.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'Our primary use of lambda expressions is as a concise way to implement a *functional
    interface* (an interface with a single abstract method). Specifically, you can
    use a lambda expression wherever an object from a functional interface is expected.
    For example, all of the following expressions implement the [Function.java](Function.java.html)
    interface:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![functional interface](../Images/60babd1236056ffeb2c0b388240fec46.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Consequently, you can can integrate the square function with the call `integrate(x
    -> x*x, 0, 10, 1000)`, bypassing the need to define a separate `Square` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Built-in interfaces.* Java includes three built-in interfaces that we will
    consider later this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface [java.util.Comparable](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)
    defines an order in which to compare objects of the same type, such as alphabetical
    order for strings or ascending order for integers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The interfaces [java.util.Iterator](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)
    and [java.lang.Iterable](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html)
    enable clients to iterate over the items in a collection, without relying on the
    underlying representation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation inheritance (subclassing).
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java also supports another inheritance mechanism known as *subclassing*. The
    idea is to define a new class (*subclass*, or *derived class*) that inherits instance
    variables (state) and instance methods (behavior) from another class (*superclass*,
    or *base class*), enabling code reuse. Typically, the subclass redefines or *overrides*
    some of the methods in the superclass. For example, Java provides an elaborate
    inheritance hierarchy for GUI components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Java inheritance hierarchy for GUI elements](../Images/79cf04ee6b9dff0a5b4b6be15a4f5766.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: In this book, we avoid subclassing because it works against encapsulation and
    immutability (e.g., the [fragile base class problem](https://en.wikipedia.org/wiki/Fragile_base_class)
    and the [circle–ellipse](https://en.wikipedia.org/wiki/Circle-ellipse_problem)
    problem).
  prefs: []
  type: TYPE_NORMAL
- en: '*Java''s Object superclass.* Certain vestiges of subclassing are built into
    Java and therefore unavoidable. Specifically, every class is a subclass of [java.lang.Object](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html).
    When programming in Java, you will often override one or more of these inherited
    methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Object API](../Images/df6e17af8ade51966127aea05c279980.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*String conversion.* Every Java class inherits the [`toString()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--)
    method, so any client can invoke `toString()` for any object. This convention
    is the basis for Java’s automatic conversion of one operand of the string concatenation
    operator `+` to a string whenever the other operand is a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reference equality.* If we test equality with `(x == y)`, where `x` and `y`
    are object references, we are testing whether they have the same identity: whether
    the *object references* are equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object equality.* ![Overriding toString(), equals(), and hashCode()](../Images/6c5cf9c2d17d3b8e2682ef5d49e46dbd.png)
    The purpose of the [`equals()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-)
    method is to test whether two *objects* are equal (correspond to the same data-type
    value). It must implement an *equivalence relation*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reflexive: `x.equals(x)` is `true`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Symmetric: `x.equals(y)` is `true` if and only if `y.equals(x)` is `true`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transitive: if `x.equals(y)` is `true` and `y.equals(z)` is `true`, then `x.equals(z)`
    is `true`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the following two properties must hold:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Multiple calls to `x.equals(y)` return the same truth value, provided neither
    object is modified between calls.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x.equals(null)` returns `false`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the `equals()` method is unexpectedly intricate because its argument
    can be a reference to an object of any type (or `null`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Hashing.* The purpose of the [`hashCode()`](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--),
    method is to support *hashing*, which is a fundamental operation that maps an
    object to an integer, known as a *hash code*. It must satisfy the following two
    properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `x.equals(y)` is `true`, then `x.hashCode()` is equal to `y.hashCode()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple calls of `x.hashCode()` return the same integer, provided the object
    is not modified between calls.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typically, we use the hash code to map an object `x` to an integer in a small
    range, say between `0` and `m-1`, using this *hash function*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Objects whose values are not equal can have the same hash function value but
    we expect the hash function to divide `n` typical objects from the class into
    `m` groups of roughly equal size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Wrapper types.* ![Wrapper types](../Images/31ae0730f9e7379357052b0abf192a65.png)
    The `toString()`, `hashCode()`, and `equals()` methods apply only to reference
    types, not primitive types. For example, the expression `x.hashCode()` works if
    `x` is a variable of type `Integer` but not if it is of type `int`. For situations
    where we wish want to represent a value from a primitive type as an object, Java
    supplies built-in reference types known as *wrapper types*, one for each of the
    eight primitive types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Autoboxing and unboxing.* Java automatically converts between values from
    a wrapper type and the corresponding primitive type, so that you can write code
    like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Application: data mining.'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We consider a *data mining* application in which the goal is to associate with
    each document a vector known as a *sketch* so that so that documents that are
    different have sketches that are different and documents that are similar have
    sketches that are similar. Our API abstracts away this notion into the method
    `similarTo()`, which is a real number between 0 (not similar) and 1 (similar).
    The parameters *k* and *d* control the quality of the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sketch API](../Images/c6313d389eedbb7a12e46cddd6181d4e.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: '*Computing sketches.* ![Sketch of DNA](../Images/2e814bb10b353352802ebe70fd3d1b07.png)
    [Sketch.java](Sketch.java.html) uses a simple frequency count approach to compute
    the sketch of a text document. In its simplest form, it counts the number of time
    each *k*-gram (substring of length *k*) appears in the text. The sketch that we
    use is the direction of the vector defined by these frequencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hashing.* For ASCII text strings there are 128 different possible values for
    each character, so there are 128^(*k*) possible *k*-grams. For efficiency, [Sketch.java](Sketch.java.html)
    uses *hashing*. That is, instead of counting the number of times each *k*-gram
    appears, we hash each *k*-gram to an integer between 0 and *d*−1 and count the
    number of times each hash value appears.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Comparing sketches.* [Sketch.java](Sketch.java.html) uses the *cosine similarity
    measure* to compare two sketches:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \( x \cdot y = x_0y_0 + x_1y_1 + \; \ldots \; + x_{d-1}y_{d-1} \)
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is a real number between 0 and 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Comparing all pairs.* [CompareDocuments.java](CompareDocuments.java.html)
    prints the cosine similarity measure for all pairs of documents on an input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![text documents](../Images/fd4da740f9535894bda439b8bda97674.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Design by contract.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly discuss two Java language mechanisms that enable you to verify assumptions
    about your program while it is running—exceptions and assertions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Exceptions.* An *exception* is a disruptive event that occurs *while* a program
    is running, often to signal an error. The action taken is known as *throwing an
    exception*. Java includes an elaborate inheritance hierarchy of predefined exceptions,
    several of which we have encountered previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Java exceptions](../Images/67eb76023dce2c3e9939a903fa9e1e91.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'It is good practice to use exceptions when they can be helpful to the user.
    For example, in [Vector.java](Vector.java.html), we should throw an exception
    in `plus()` if the two vectors to be added have different dimensions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Assertions.* An *assertion* is a boolean expression that you are affirming
    is true at some point *during* the execution of a program. If the expression is
    false, the program will throw an `AssertionError`, which typically terminates
    the program and reports an error message. For example, in [Counter.java](Counter.java.html),
    we might check that the counter is never negative by adding the following assertion
    as the last statement in `increment()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, assertions are disabled, but you can enable them from the command
    line by using the `-enableassertions` flag (`-ea` for short). Assertions are for
    debugging only; your program should not rely on assertions for normal operation
    since they may be disabled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the *design-by-contract* model of programming, the designer expresses conditions
    about the behavior of the program using assertions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Precondition.* A condition that the client promises to satisfy when calling
    a method.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Postcondition.* A condition that the implementation promises to achieve when
    returning from a method.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Invariant.* A condition that the implementation promises to satisfy while
    the method is executing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Give an implementation of `minus()` for [Vector.java](Vector.java.html) solely
    in terms of the other `Vector` methods, such as `direction()` and `magnitude()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a `toString()` method to [Vector.java](Vector.java.html) that returns the
    vector components, separated by commas, and enclosed in matching parentheses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Statistics.** Develop a data type for maintaining statistics for a set of
    real numbers. Provide a method to add data points and methods that return the
    number of points, the mean, the standard deviation, and the variance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: $$ \begin{eqnarray*} \bar x &=& \frac{1}{n} \sum_i x_i \\ s^2 &=& \frac{\sum_i
    (x_i - \mu)^2}{n-1} \;\; = \;\; \frac{n \sum_i x_i^2 - (\sum_i x_i)^2}{n(n-1)}
    \end{eqnarray*} $$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Develop two implementations: [OnePass.java](OnePass.java.html) whose instance
    values are the number of points and the sum of the values, and the sum of the
    squares of the values, [TwoPass.java](TwoPass.java.html) that keeps an array containing
    all the points. For simplicity, you may take the maximum number of points in the
    constructor. Your first implementation is likely to be faster and use substantially
    less space, but is also likely to be susceptible to roundoff error.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: [StableOnePass.java](StableOnePass.java.html) is a well-engineered
    alternative that is is numerically stable and does not require an array to store
    the elements.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $$ \begin{eqnarray*} m_0 &=& 0 \\ s_0 &=& 0 \\ m_n &=& m_{n-1} + \frac{1}{n}
    \; (x_n - m_{n-1}) \\ s_n &=& s_{n-1} + \frac{n-1}{n} \; (x_n - m_{n-1})^2 \\
    \bar x &=& m_n \\ s^2 &=& \frac{1}{n-1} s_n \end{eqnarray*} $$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Genome.** Develop a data type to store the genome of an organism. Biologists
    often abstract away the genome to a sequence of nucleotides (A, C, G, or T). The
    data type should support the method `addNucleotide()`, `nucleotideAt()`, as well
    as `isPotentialGene()`. Develop three implementations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use one instance variable of type `String`, implementing `addCodon()` with string
    concatenation. Each method call takes time proportional to the length of the current
    genome.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an array of characters, doubling the length of the array each time it fills
    up.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a boolean array, using two bits to encode each codon, and doubling the length
    of the array each time it fills up.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Solution*: [StringGenome.java](StringGenome.java.html), [Genome.java](Genome.java.html),
    and [CompactGenome.java](CompactGenome.java.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Encapsulation.** Is the following class immutable?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Solution*: No, because Java''s [java.util.Date](https://docs.oracle.com/javase/8/docs/api/java/util/Date.html)
    is mutable. To correct, make a defensive copy of the date in the constructor and
    make a defensive copy of the date before returning to the client.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Date.** Design an implementation of Java''s [java.util.Date](https://docs.oracle.com/javase/8/docs/api/java/util/Date.html)
    API that is immutable and therefore corrects the defects of the previous exercise.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Partial solution*: [Date.java](Date.java.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Web Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add methods to [Genome.java](Genome.java.html) to test for equality and return
    the reverse-complemented genome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add methods to [Date.java](Date.java.html) to check which season (Spring, Summer,
    Fall, Winter) or astrological sign (Pisces, Libra, ...) a given date lies. Be
    careful about events that span December to January.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a method `daysUntil()` to [Date.java](Date.java.html) that takes a `Date`
    as an argument and returns the number of days between the two dates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an implementation [Date2.java](Date2.java.html) that represents a date
    a single integer that counts the number of days since January 1, 1970. Compare
    to [Date.java](Date.java.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Rectangle` ADT that represents a rectangle. Represent a rectangle
    by two points. Include a constructor, a `toString` method, a method for computing
    the area, and a method for drawing using our graphics library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous exercise, but this time represent a `Rectangle` as the lower
    left endpoint and the width and height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous exercise, but this time represent a `Rectangle` as the center
    and the width and height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sparse vector.** Create a data type for sparse vectors. Represent a sparse
    vector by an array of indices (of nonzeros) and a parallel array of the corresponding
    nonzero values. Assume the indices are in ascending order. Implement the dot product
    operation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Copy constructor.** Only needed if data type is mutable. Otherwise, assignment
    statement works as desired.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define an interface [DifferentiableFunction.java](DifferentiableFunction.java.html)
    for twice-differentiable function. Write a class [Sqrt.java](Sqrt.java.html) that
    implements the function f(x) = c - x^2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program [Newton.java](Newton.java.html) that implements Newton's method
    to find a real root of a sufficiently smooth function, given that you start sufficiently
    close to a root. When method converges, it does so quadratically. Assume that
    it takes a `DifferentiableFunction` as argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Generating random numbers.** Different methods to generate a random number
    from the standard Gaussian distribution. Here, encapsulation enables us to replace
    one version with another that is more accurate or efficient. Trigonometric method
    is simple, but may be slow due to calling several transcendental functions. More
    importantly, it suffers from numerical stability problems when x1 is close to
    0. Better method is alternate form of Box-Muller method. [reference](http://en.wikipedia.org/wiki/Box-Muller_transform).
    Both methods require two values from a uniform distribution and produce two values
    from the Gaussian distribution with mean 0 and standard deviation 1\. Can save
    work by remembering the second value for the next call. (This is how it is implemented
    in `java.util.Random`.) Their implementation is the polar method of Box-Muller,
    saving the second random number for a subsequent call. (See Knuth, ACP, Section
    3.4.1 Algorithm C.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**LAX airport shutdown.** On September 14, 2004 Los Angeles airport was [shut
    down](http://msdn.microsoft.com/library/default.asp?url= /library/en-us/sysinfo/base/gettickcount.asp)
    due to software breakdown of a radio system used by air traffic controllers to
    communicate with pilots. The program used a Windows API function call `GetTickCount()`
    which returns the number of milliseconds since the system was last rebooted. The
    value is returned as a 32 bit integer, so after approximately 49.7 days it "wraps
    around." The software developers were aware of the bug, and instituted a policy
    that a technician would reboot the machine every month so that it would never
    exceed 31 days of uptime. Oops. LA Times blamed the technician, but the developers
    are more to blame for shoddy design.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Polar representation of points.** Re-implement the [Point.java](Point.java.html)
    data type using polar coordinates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*: [PointPolar.java](PointPolar.java.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Spherical coordinates.** Represent a point in 3D space using Cartesian coordinates
    \((x, y, z)\) or spherical coordinates \((r, \theta, \phi)\). To convert from
    one to the other, use'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: $$ \begin{array}{lllllll} r &=& \sqrt{x^2 + y^2 + z^2} &\hspace{.3in} & x &=&
    r \cos \theta \sin \phi \\ \theta &=& \tan^{-1}(y/x) & & y &=& r \sin \theta \sin
    \phi \\ \phi &=& \cos^{-1}(z/r) & & z &=& r \cos \phi \\ \end{array} $$
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Colors.** Can represent in RGB, CMYK, or HSV formats. Natural to have different
    implementations of same interface.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ZIP codes.** Implement an ADT that represents a USPS ZIP code. Support both
    the original 5 digit format and the newer (but optional) ZIP+4 format.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
