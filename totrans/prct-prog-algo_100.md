# 3.5   搜索应用

> 原文：[`algs4.cs.princeton.edu/35applications`](https://algs4.cs.princeton.edu/35applications)

本节正在大规模施工中。

从计算机的早期时代，当符号表允许程序员从在机器语言中使用数值地址进展到在汇编语言中使用符号名称，到新千年的现代应用，当符号名称在全球计算机网络中具有意义时，快速搜索算法在计算中发挥了并将继续发挥重要作用。符号表的现代应用包括组织科学数据，从在基因组数据中搜索标记或模式到绘制宇宙；在网络上组织知识，从在线商务搜索到将图书馆放在线；以及实现互联网基础设施，从在网络上的机器之间路由数据包到共享文件系统和视频流。

## 集合 API。

一些符号表客户端不需要值，只需要将键插入表中并测试键是否在表中。由于我们不允许重复键，这些操作对应于以下 API，我们只对表中的键集感兴趣。

为了说明 SET.java 的用途，我们考虑*过滤*客户端，从标准输入读取一系列键，并将其中一些写入标准输出。

+   *去重。*程序 DeDup.java 从输入流中删除重复项。

+   *白名单和黑名单过滤。*另一个经典示例，使用单独的文件中的键来决定哪些来自输入流的键传递到输出流。程序 AllowFilter.java 实现了*白名单*，其中文件中的任何键都会传递到输出，而文件中没有的键将被忽略。程序 BlockFilter.java 实现了*黑名单*，其中文件中的任何键都将被忽略，而文件中没有的键将传递到输出。

## 字典客户端。

最基本的符号表客户端通过连续的*put*操作构建符号表，以支持*get*请求。下面列举的熟悉示例说明了这种方法的实用性。![典型的字典应用](img/e4d99652d1363f0ad20189abd94cf592.png)

作为一个具体的例子，我们考虑一个符号表客户端，您可以使用它查找使用*逗号分隔值*（.csv）文件格式保存的信息。LookupCSV.java 从命令行指定的逗号分隔值文件中构建一组键值对，然后打印出与从标准输入读取的键对应的值。命令行参数是文件名和两个整数，一个指定用作键的字段，另一个指定用作值的字段。

## 索引客户端。

这个应用是符号表客户端的另一个典型示例。我们有大量数据，想知道感兴趣的字符串出现在哪里。这似乎是将多个值与每个键关联起来，但实际上我们只关联一个`SET`。![典型的索引应用](img/cc0f5f57e7ba790cfcdb960b6318d833.png)FileIndex.java 将一系列文件名作为命令行参数，并构建一个符号表，将每个关键字与可以找到该关键字的文件名的`SET`关联起来。然后，它从标准输入接受关键字查询。

MovieIndex.java 读取一个包含表演者和电影的数据文件。

## 稀疏向量和矩阵。

程序 SparseVector.java 使用索引-值对的符号表实现了一个稀疏向量。内存与非零数目成比例。*set*和*get*操作在最坏情况下需要 log n 时间；计算两个向量的点积所需的时间与两个向量中的非零条目数成比例。

## 系统符号表。

Java 有几个用于集合和符号表的库函数。API 类似，但你可以将`null`值插入符号表。

+   TreeMap 库使用红黑树。保证每次插入/搜索/删除的性能为 log N。他们的实现为每个节点维护三个指针（两个子节点和父节点），而我们的实现只存储两个。

+   Sun 在 Java 1.5 中的`HashMap`实现使用具有分离链接的哈希表。表大小为 2 的幂（而不是素数）。这用 AND 替换了相对昂贵的% M 操作。默认负载因子= 0.75。为防止一些编写不佳的哈希函数，他们对`hashCode`应用以下混淆例程。

    ```
    static int hash(Object x) {
       int h = x.hashCode();
       h += ~(h <<   9);
       h ^=  (h >>> 14);
       h +=  (h <<   4);
       h ^=  (h >>> 10);
       return h;
    }

    ```

#### Q + A

**Q.** 运行性能基准测试时，插入、搜索和删除操作的合理比例是多少？

**A.** 这取决于应用程序。Java 集合框架针对大约 85%的搜索/遍历，14%的插入/更新和 1%的删除进行了优化。

#### 练习

#### 创意练习

1.  **词汇表。** 编写一个 ST 客户端 Concordance.java，在标准输出中输出标准输入流中字符串的词汇表。

1.  **稀疏矩阵。** 为稀疏 2D 矩阵开发一个 API 和一个实现。支持矩阵加法和矩阵乘法。包括行和列向量的构造函数。

    *解决方案*：SparseVector.java 和 SparseMatrix.java。

#### 网页练习

1.  修改`FrequencyCount`以读取一个文本文件（由 UNICODE 字符组成），并打印出字母表大小（不同字符的数量）和一个按频率降序排序的字符及其频率表。

1.  **集合的交集和并集。** 给定两组字符串，编写一个代码片段，计算一个包含这两组中出现的字符串的第三组（或任一组）。

1.  **双向符号表。** 支持 put(key, value)和 getByKey(key)或 getByValue(value)。在幕后使用两个符号表。例如：DNS 和反向 DNS。

1.  **突出显示浏览器超链接。** 每次访问网站时，保留上次访问网站的时间，这样你只会突出显示那些在过去一个月内访问过的网站。

1.  **频率符号表。** 编写一个支持以下操作的抽象数据类型 FrequencyTable.java：`hit(Key)`和`count(Key)`。`hit`操作将字符串出现的次数增加一。`count`操作返回给定字符串出现的次数，可能为 0。应用：网页计数器，网页日志分析器，音乐点播机统计每首歌曲播放次数等。

1.  **非重叠区间搜索。** 给定一个非重叠整数（或日期）区间列表，编写一个函数，接受一个整数参数，并确定该值位于哪个（如果有）区间中，例如，如果区间为 1643-2033、5532-7643、8999-10332、5666653-5669321，则查询点 9122 位于第三个区间，8122 不在任何区间中。

1.  **注册调度。** 一所东北部知名大学的注册处最近安排一名教师在完全相同的时间上教授两门不同的课程。通过描述一种检查此类冲突的方法来帮助注册处避免未来的错误。为简单起见，假设所有课程从 9 点开始，每门课程持续 50 分钟，时间分别为 9、10、11、1、2 或 3。

1.  **列表。** 实现以下列表操作：size()、addFront(item)、addBack(item)、delFront(item)、delBack(item)、contains(item)、delete(item)、add(i, item)、delete(i)、iterator()。所有操作应高效（对数时间）。提示：使用两个符号表，一个用于高效查找列表中的第 i 个元素，另一个用于按项目高效搜索。Java 的 List 接口包含这些方法，但没有提供支持所有操作高效的实现。

1.  **间接 PQ。** 编写一个实现间接 PQ 的程序 IndirectPQ.java。

1.  **LRU 缓存。** 创建一个支持以下操作的数据结构：`access`和`remove`。访问操作将项目插入到数据结构中（如果尚未存在）。删除操作删除并返回最近访问的项目。*提示*：在双向链表中按访问顺序维护项目，并在符号表中使用键=项目，值=链表中的位置。当访问一个元素时，从链表中删除它并重新插入到开头。当删除一个元素时，从末尾删除它并从符号表中删除它。

1.  **UniQueue.** 创建一个数据类型，它是一个队列，但是一个元素只能被插入队列一次。使用存在性符号表来跟踪所有曾经被插入的元素，并忽略重新插入这些项目的请求。

1.  **带随机访问的符号表。** 创建一个支持插入键值对、搜索键并返回关联值、删除并返回随机值的数据类型。*提示*：结合符号表和随机队列。

1.  **纠正拼写错误。** 编写一个程序，从标准输入中读取文本，并用建议的替换替换任何常见拼写错误的单词，并将结果打印到标准输出。使用这个常见拼写错误列表（改编自[Wikipedia](http://en.wikipedia.org/wiki/Wikipedia:List_of_common_misspellings)）。

1.  **移至前端。** 编码：需要排名查询、删除和插入。解码：需要查找第 i 个、删除和插入。

1.  **可变字符串。** 创建一个支持字符串上述操作的数据类型：`get(int i)`、`insert(int i, char c)`和`delete(int i)`，其中`get`返回字符串的第 i 个字符，`insert`插入字符 c 并使其成为第 i 个字符，`delete`删除第 i 个字符。使用二叉搜索树。

    *提示*：使用 BST（键=0 到 1 之间的实数，值=字符）使得树的中序遍历产生适当顺序的字符。使用`select()`找到第 i 个元素。在位置 i 插入字符时，选择实数为当前位置 i-1 和 i 的键的平均值。

1.  **幂法和最大特征值。** 要计算具有最大幅度的特征值（及相应的特征向量），请使用幂法。在技术条件下（最大两个特征值之间的差距），它会迅速收敛到正确答案。

    +   进行初始猜测 x[1]

    +   y[n] = x[n] / ||x[n]||

    +   x[n+1] = A y[n]

    +   λ = x[n+1]^T y[n]

    +   n = n + 1 如果 A 是稀疏的，那么这个算法会利用稀疏性。例如：Google PageRank。

1.  **外积。** 向`Vector`添加一个方法`outer`，使得`a.outer(b)`返回两个长度为 N 的向量 a 和 b 的外积。结果是一个 N×N 矩阵。

1.  **网络链接的幂律分布。**（Michael Mitzenmacher）全球网络的入度和出度遵循幂律分布。可以通过[优先附加](http://citeseer.nj.nec.com/553345.html)过程来建模。假设每个网页只有一个外链。每个页面逐一创建，从指向自身的单个页面开始。以概率 p < 1，它将链接到现有页面之一，随机选择。以概率 1-p，它将链接到现有页面，概率与该页面的入链数成比例。这一规则反映了新网页倾向于指向热门页面的普遍趋势。编写一个程序来模拟这个过程，并绘制入链数的直方图。

1.  **VMAs.** Unix 内核中用于管理一组虚拟内存区域（VMAs）的 BST。每个 VMA 代表 Unix 进程中的一部分内存。VMAs 的大小从 4KB 到 1GB 不等。还希望支持范围查询，以确定哪些 VMAs 与给定范围重叠。[参考资料](http://www.stanford.edu/~blp/papers/libavl-abstract.pdf)

1.  **互联网对等缓存。**由互联网主机发送的每个 IP 数据包都带有一个必须对于该源-目的地对是唯一的 16 位 ID。Linux 内核使用以 IP 地址为索引的 AVL 树。哈希会更快，但希望避免攻击者发送具有最坏情况输入的 IP 数据包。[参考资料](http://www.stanford.edu/~blp/papers/libavl-abstract.pdf)

1.  **文件索引变体。**

    +   移除停用词，例如，a，the，on，of。使用另一个集合来实现。

    +   支持多词查询。这需要进行集合交集操作。如果总是先与最小集合进行交集，那么这将花费与最小集合大小成正比的时间。

    +   实现 OR 或其他布尔逻辑。

    +   记录文档中单词的位置或单词出现的次数。

1.  **算术表达式解释器。**编写一个程序 Interpreter.java 来解析和评估以下形式的表达式。

    ```
    >> x := 34
    x := 34.0

    >> y := 23 * x    
    y := 782.0

    >> z := x ^ y
    z := Infinity

    >> z := y ^ 2
    z := 611524.0

    >> x
    x := 34.0

    >> x := sqrt 2
    x := 1.4142135623730951

    ```

    变体。

    +   添加更复杂的表达式，例如，z = 7 * (x + y * y)，使用传统的运算符优先级。

    +   添加更多的错误检查和恢复。
