# 4.1 算法分析

> 原文：[`introcs.cs.princeton.edu/python/41analysis`](https://introcs.cs.princeton.edu/python/41analysis)

<title>4.1 算法分析</title>

我们编写的程序的成本是值得关注的。为了研究我们程序的运行成本，我们通过*科学方法*进行研究，这是科学家们普遍使用的一套技术，用于开发关于自然界的知识。以下五步方法简要总结了科学方法：

+   *观察*自然界的某些特征。

+   提出与观察一致的模型的*假设*。

+   使用假设*预测*事件。

+   通过进一步观察*验证*预测。

+   通过重复直到假设和观察一致来*验证*。

我们还应用*数学分析*来推导成本的简洁模型。在大多数情况下，我们对一个基本特征感兴趣：时间。

* * *

## 观察

我们的第一个挑战是对程序的运行时间进行定量测量。有许多工具可用于帮助我们获得近似值。也许最简单的是物理秒表或在 stopwatch.py（来自第 3.2 节）中定义的`Stopwatch`数据类型。我们可以简单地在各种输入上运行程序，测量处理每个输入所需的时间。

对于大多数程序，存在一个表征计算任务难度的问题大小。通常，问题大小要么是输入的大小，要么是命令行参数的值。直观地，运行时间应该随问题大小增加而增加，但每次我们开发和运行程序时，问题大小与 threesum.py 的运行时间之间的关系自然地引起了我们的注意。

作为一个具体的例子，我们从 threesum.py 开始，它计算一个包含*n*个数字的数组中总和为 0 的三元组的数量。尝试在文件 8ints.txt、1kints.txt、2kints.txt、4kints.txt、8kints.txt、16kints.txt、32kints.txt、64kints.txt 和 128kints.txt 上运行它，以了解程序的运行时间。问题大小*n*与 threesum.py 的运行时间之间的关系是什么？

* * *

## 假设

每个程序员都需要知道如何进行快速性能估算。幸运的是，我们通常可以通过使用经验观察和一小组数学工具来获得这样的知识。

### 加倍假设。

对于许多程序，我们可以很快为以下问题制定一个假设：将输入大小加倍对运行时间的影响是什么？为了清晰起见，我们将这个假设称为*加倍假设*。

### 经验分析。

很明显，我们可以通过将输入大小加倍并观察运行时间的影响来提前发展一个加倍假设。例如，doublingtest.py 为 threesum.py 生成一系列随机输入数组，每一步都将数组长度加倍，并写下`threesum.countTriples()`对于每个输入的运行时间与前一个输入（大小为前一个输入的一半）的比值。程序写入的`Stopwatch`测量立即导致一个假设：当输入大小加倍时，运行时间增加了 8 倍。

### 数学分析。

程序的总运行时间由两个主要因素决定：

+   每个语句的执行成本

+   每个语句的执行频率

前者是系统的属性，后者是算法的属性。如果我们对程序中的所有指令都了解这两者，我们可以将它们相乘并对程序中的所有指令求和，以获得运行时间。

主要挑战在于确定语句的执行频率。有些语句很容易分析；例如，在`threesum.countTriples()`中将`count`初始化为 0 的语句只执行一次。其他需要更高级推理的语句；例如，在`threesum.countTriples()`中的`if`语句精确地执行*n*(*n*-1)(*n*-2)/6 次（这正是从输入数组中选择三个不同数字的方法的数量）。

为了在数学分析中大大简化问题，我们以两种方式开发了更简单的近似表达式。首先，我们通过使用一种称为*波浪符号*的数学工具来处理数学表达式的主导项。我们写成 ~*f*(*n*) 来表示任何数量，当除以*f*(*n*)时，随着*n*的增长趋于 1。我们还写成*g*(*n*) ~ *f*(*n*)来表示*g*(*n*)/*f*(*n*)随着*n*的增长趋于 1。有了这个符号，我们可以忽略代表小值的表达式的复杂部分。例如，在 threesum.py 中的`countTriples()`中的`if`语句执行了~*n*³/6 次，因为*n*(*n*-1)(*n*-2)/6 = *n*³/6 - *n*²/2 + *n*/3，当除以*n*³/6 时，随着*n*的增长趋于 1。当主导项后的项相对不重要时，这种符号是有用的（例如，当*n* = 1,000 时，这个假设相当于说-*n*²/2 + *n*/3 ≈ -499,667 相对于*n*³/6 ≈ 166,666,667 是相对不重要的）。其次，我们关注执行频率最高的指令，有时被称为程序的*内循环*。在这个程序中，合理地假设内循环之外的指令所花费的时间相对不重要。

分析程序的运行时间的关键点在于：对于许多程序，运行时间满足关系

> | *T*(*n*) ~ *cf*(*n*) |
> | --- |

其中*c*是一个常数，*f*(*n*)是一个称为运行时间*增长顺序*的函数。对于典型程序，*f*(*n*)是一个如 log *n*、*n*、*n* log *n*、*n*²或*n*³的函数（通常，我们表达增长顺序函数时不带任何常数系数）。当*f*(*n*)是*n*的幂时，这种假设通常等同于说运行时间满足幂律。在 threesum.py 的情况下，这是我们的经验观察已经验证的假设：threesum.py 的运行时间的增长顺序是*n*³。常数*c*的值取决于执行指令的成本和频率分析的细节，但我们通常不需要计算出这个值。

增长顺序是一个简单但强大的运行时间模型。例如，知道增长顺序通常会立即导致加倍假设。在 threesum.py 的情况下，知道增长顺序是*n*³告诉我们，当我们将问题规模加倍时，预计运行时间将增加 8 倍，因为

> | *T*(2*n*) / *T*(*n*) ~ *c*(2*n*)³ / (*cn*³) = 8 |
> | --- |

这与经验分析得出的值相匹配，从而验证了模型和实验。

* * *

## 增长顺序分类

![常见增长函数](img/0869ec8ca415276cb01cb2bc4a11e49c.png)

我们只使用了一些结构原语（语句、条件、循环和函数调用）来构建 Python 程序，因此我们程序的增长顺序往往是问题规模的几个函数之一，总结在右侧的表中。

### 常数。

运行时间增长阶数为*常数*的程序执行固定数量的语句来完成任务；因此，其运行时间不取决于问题规模。我们在第一章中的前几个程序——比如 hello.py（来自第 1.1 节）和 leapyear.py（来自第 1.2 节）——属于这一类：它们每次只执行几个语句。

Python 对标准数值类型的所有操作都需要恒定时间。也就是说，将操作应用于大数值与将其应用于小数值消耗的时间相同。 （一个例外是涉及具有大量位数的整数的操作可能消耗超过常数时间；有关详细信息，请参阅本节末尾的问答。）Python 的`math`模块中的函数也需要恒定时间。

### 对数。

运行时间增长阶数为*对数*的程序几乎比常数时间程序慢。在问题规模上运行时间为对数的程序的经典示例是在排序数组中查找元素（见二分查找.py 第 4.2 节）。对数的底数与增长阶数无关（因为所有具有常数底数的对数都由一个常数因子相关），因此我们通常在提到增长阶数时使用 log *n*。

### 线性。

我们使用术语*线性*来描述程序的增长阶数，该程序在处理每个输入数据片段时花费恒定的时间，或者基于单个`for`循环。这样的程序的运行时间与问题规模成正比。计算标准输入数字平均值的程序 average.py（来自第 1.5 节）是典型的例子。

### 线性对数。

我们使用术语*线性对数*来描述对于规模为*n*的问题，其运行时间增长阶数为*n* log *n*的程序。同样，对数的底数不相关。例如，couponcollector.py（来自第 1.4 节）是线性对数的。典型示例是归并排序，如在 merge.py（来自第 4.2 节）中实现的。

### 二次方。

运行时间增长阶数为*n*²的典型程序有两个嵌套的`for`循环，用于涉及所有*n*个元素对的某些计算，被称为*二次方*增长。在 universe.py（来自第 3.4 节）中的力更新双循环是这一类程序的原型，以及在 insertion.py（见第 4.2 节）中定义的基本排序算法插入排序。

### 立方。

我们本节的示例 threesum.py 是*立方*的——其运行时间增长阶数为*n*³——因为它有三个嵌套的`for`循环，用于处理所有*n*个元素的三元组。

### 指数。

如第 2.3 节所讨论的，hanoi 塔.py 和 beckett.py 的运行时间与 2^(*n*)成正比，因为它们处理所有*n*个元素的所有子集。通常，我们使用术语*指数*来指代增长阶数为*b^n*的算法，其中*b* > 1 为任意常数，尽管不同的*b*值会导致截然不同的运行时间。指数算法非常慢——你不应该为大问题运行其中之一。

* * *

## Python 列表和数组

Python 内置的`list`数据类型表示可变对象序列。我们在整本书中一直在使用 Python 列表 —— 回想一下，我们将 Python 列表用作数组，因为它们支持四个核心数组操作：创建、索引访问、索引赋值和迭代。但是，Python 列表比数组更通用，因为您还可以向 Python 列表中插入项目和删除项目。尽管 Python 程序员通常不区分列表和数组，但许多其他程序员确实会区分。例如，在许多编程语言中，数组长度固定，不支持插入或删除。事实上，到目前为止，我们在本书中考虑的所有数组处理代码都可以使用固定长度数组完成。

下表列出了 Python 列表中最常用的操作。

> ![列表 API](img/aa9a6363a30a8caa5335226fe16810f7.png)

我们将此 API 推迟到本节，因为不注意成本而使用 Python 列表的程序员将会遇到麻烦。例如，考虑以下两个代码片段：

```
# quadratic time            # linear time
a = []                      a = []
for i in range(n):          for i in range(n):
    a.insert(0, 'slow')         a.insert(i, 'fast')

```

左侧的操作需要二次时间；右侧的操作需要线性时间。要理解为什么 Python 列表操作具有这样的性能特征，您需要了解更多关于 Python 列表的调整大小数组表示，我们将在下面讨论。

### 调整大小的数组。

调整大小的数组是一种数据结构，用于存储一个序列的项目（长度不一定固定），可以通过索引访问。为了在机器级别实现调整大小的数组，Python 使用一个固定长度的数组（作为一块连续的内存块分配）来存储项目引用。数组被分为两个逻辑部分：数组的第一部分包含序列中的项目；数组的第二部分未使用，保留用于后续插入。因此，我们可以在常数时间内从末尾附加或删除项目，使用保留的空间。我们使用术语*size*来指代数据结构中项目的数量，术语*capacity*指代底层数组的长度。

主要挑战在于确保数据结构具有足够的容量来容纳所有项目，但又不会过大以浪费过多内存。实现这两个目标事实上非常容易。

首先，如果��们想要将项目附加到调整大小的数组的末尾，我们会检查其容量。如果有空间，我们只需将新项目插入到末尾。如果没有，我们通过创建两倍长度的新数组并将项目从旧数组复制到新数组来*加倍*其容量。

> ![调整大小的数组数据结构表示 Python 列表](img/8149721b12cf28bea508dcc29ad91886.png)

类似地，如果我们想要从调整大小的数组的末尾删除项目，我们会检查其容量。如果它过大，我们通过创建一半长度的新数组并将项目从旧数组复制到新数组来*减半*其容量。一个适当的测试是检查调整大小的数组的大小是否小于其容量的四分之一。这样，在容量减半后，调整大小的数组大约半满，并且可以容纳大量插入，然后我们必须再次更改其容量。

加倍和减半策略保证调整大小的数组始终保持在 25%到 100%之间，因此空间与项目数量成线性关系。具体的策略并非神圣不可侵犯。例如，典型的 Python 实现在调整大小的数组已满时将容量扩大 9/8 倍（而不是 2 倍）。这样浪费的空间更少（但会触发更多的扩展和收缩操作）。

### 摊销分析。

我们可以证明加倍和减半的成本总是被其他 Python 列表操作的成本吸收（在一个常数因子内）。

从空 Python 列表开始，标记为列表 API 表中“常数时间”的*n*个操作序列需要与*n*���线性时间。换句话说，任何这种 Python 列表操作序列的总成本除以操作数都受到常数的限制。这种分析称为*摊销分析*。这种保证不像说每个操作都是常数时间那样强，但在许多应用中具有相同的含义（例如，当我们的主要兴趣是总运行时间时）。

对于我们在空调整大小数组中执行*n*个插入的特殊情况，这个想法很简单：每次插入都需要恒定时间添加项目；每次触发调整大小的插入（当当前大小是 2 的幂时）需要额外的时间与*n*成比例，将长度为*n*的旧数组的元素复制到长度为 2*n*的新数组中。因此，假设*n*是 2 的幂以简化，总成本与*n*成比例

> | (1 + 1 + 1 + ... + 1) + (1 + 2 + 4 + 8 + ... + *n*) ~ 3*n* |
> | --- |

第一项（总和为*n*）代表*n*个插入操作；第二项（总和为 2*n* - 1）代表 lg *n*调整大小操作。

在 Python 编程中理解调整大小的数组是很重要的。例如，它解释了为什么通过重复将项目附加到末尾来创建一个包含*n*个项目的 Python 列表需要与*n*成比例的时间（以及为什么通过重复将项目前置到前面来创建一个包含*n*个项目的列表需要与*n*²成比例的时间）。

* * *

## 字符串

Python 的字符串数据类型与 Python 列表有一些相似之处，但有一个非常重要的例外：*字符串是不可变的*。例如，你可能认为可以通过`s[0] = 'H'`来将值为`'hello'`的字符串`s`大写，但这将导致运行时错误：

```
TypeError: 'str' object does not support item assignment

```

如果你想要`'Hello'`，你需要创建一个全新的字符串。这种差异强调了不可变性的概念，并且对性能有重大影响，现在我们来详细研究。

### 内部表示。

![一个 Python 字符串](img/f1eca1ab19e025c05e6330cb82be7cba.png) 首先，Python 对字符串使用比对列表/数组更简单的内部表示，如右侧图表中详细说明的那样。具体来说，一个字符串对象包含两个信息：

+   字符串中字符存储在内存中的连续位置的引用

+   字符串的长度

![一个由单个字符字符串组成的数组](img/0f682cbd1df37b4d1fa01bca13356b83.png)

相比之下，考虑左侧的图表，这是一个由单个字符字符串组成的数组。我们将在本节稍后进行更详细的分析，但您可以看到字符串表示肯定更简单。它每个字符使用的空间要少得多，并且提供更快的访问速度。在许多应用中，这些特性非常重要，因为字符串可能非常长。因此，重要的是内存使用量不要比字符本身所需的多太多，并且可以通过索引快速访问每个字符，就像在数组中一样。

### 性能。

![字符串连接](img/3601a7d860fa519bd0c77ed5767435ac.png) 对于数组，索引访问和计算字符串长度都是常数时间操作。从第 3.1 节开头的 API 可以清楚地看出，大多数其他操作都随着输入字符串的长度而线性增长，因为它们引用了字符串的*副本*。特别是，*将字符连接到字符串需要线性时间*，*将两个字符串连接需要与结果长度成比例的时间*。右侧显示了一个示例。就性能而言，这是字符串和列表/数组之间最重要的区别：Python 没有可调整大小的字符串，因为字符串是不可变的。

### 示例。

不理解字符串连接的性能常常会导致性能错误。最常见的性能错误是逐个字符构建一个长字符串。例如，考虑以下代码片段，用于创建一个新字符串，其字符顺序与字符串`s`中的字符相反：

```
n = len(s)
reverse = ''
for i in range(n):
    reverse = s[i] + reverse

```

在`for`循环的第*i*次迭代中，字符串连接运算符产生长度为*i*+1 的字符串。因此，整体运行时间与 1 + 2 + ... + *n*成比例 ~ *n*² / 2。也就是说，代码片段随着字符串长度*n*的增加而花费*二次*时间。

* * *

## 内存

与运行时间一样，程序的内存使用直接与物理世界相连：你计算机的大量电路使得程序能够存储值并稍后检索它们。你需要存储的值越多，你就需要更多的电路。要注意成本，你需要了解内存使用情况。

Python 没有定义我们一直在使用的内置数据类型（`int`、`float`、`bool`、`str`和`list`）的大小；这些类型的对象的大小因系统而异。因此，你创建的数据类型的大小也会因系统而异，因为它们基���这些内置数据类型。函数调用`sys.getsizeof(x)`返回在你的系统上内置对象`x`消耗的字节数。本节中给出的数字是通过在一个典型系统上使用这个函数进行观察得到的。

### 整数。

要表示一个值在(-2⁶³到 2⁶³-1)范围内的`int`对象，Python 使用 16 字节的开销和 8 字节（即 64 位）的数值。对于超出此范围的整数，Python 会切换到不同的内部表示，这会消耗与整数中数字位数成比例的内存，就像字符串的情况一样（见下文）。

### 浮点数。

为了表示一个`float`对象，Python 使用 16 字节的开销和 8 字节的数值（即尾数、指数和符号），无论对象的值是多少。因此，一个 float 对象总是占用 24 字节。

### 布尔值。

原则上，Python 可以使用一个计算机内存位来表示一个布尔值。实际上，Python 将布尔值表示为整数。具体来说，Python 使用 24 字节来表示`bool`对象`True`，使用 24 字节来表示`bool`对象`False`。这比最小所需量高出 192 倍！然而，这种浪费在一定程度上得到缓解，因为 Python“缓存”这两个布尔对象。

### 缓存。

为了节省内存，Python 仅创建具有特定值的对象的一个副本。例如，Python 只创建一个值为 true 的`bool`对象，只创建一个值为 false 的`bool`对象。也就是说，每个布尔变量都持有对这两个对象中的一个的引用。这种缓存技术是可能的，因为`bool`数据类型是不可变的。在典型系统上，Python 还会缓存小的`int`值（-5 到 256 之间），因为程序员经常使用它们。Python 通常不会缓存`float`对象。

### 字符串。

为了表示一个`str`对象，Python 使用 40 字节的开销（包括字符串长度），加上每个字符的一个字节。因此，例如，Python 使用 40 + 3 = 43 字节表示字符串`'abc'`，使用 40 + 18 = 58 字节表示字符串`'abcdefghijklmnopqr'`。Python 通常只缓存字符串字面值和单字符字符串。![内存使用情况为[0.3, 0.6, 0.1]](../Images/9e88210747cb6b511bfad4975e154568.png)

### 数组（Python 列表）。

Python 用于表示数组时，每个对象引用使用 72 字节的开销（包括数组长度）加上每个对象引用 8 字节（数组中的每个元素一个）。因此，例如，数组[0.3, 0.6, 0.1]的 Python 表示使用 72 + 8*3 = 96 字节。这不包括数组引用的对象的内存，因此数组[0.3, 0.6, 0.1]的总内存消耗为 96 + 3*24 = 168 字节。一般来说，包含*n*个整数或浮点数的数组的内存消耗为 72 + 32*n*字节。这个总数可能是一个低估，因为 Python 用于实现数组的调整大小数组数据结构可能会消耗额外的*n*字节的保留空间。![二维数组的内存使用情况](img/f32232ddca85808a7d5ca2b726d62a82.png)

### 二维数组和对象数组。

二维数组是数组的数组，因此我们可以根据上一段中的信息计算具有*m*行和*n*列的二维数组的内存消耗。每行是一个消耗 72 + 32*n*字节的数组，因此总共是 72（开销）加上 8*m*（对行的引用）加上*m*(72 + 32*n*)（对*m*行的内存）字节，总共是 72 + 80*m* + 32*mn*字节。相同的逻辑适用于任何类型对象的数组：如果一个对象使用*x*字节，那么*m*个这样的对象的数组总共消耗 72 + *m*(*x*+8)字节。同样，这可能是一个轻微的低估，因为 Python 用于表示数组的调整大小数组数据结构。*注意*：Python 的`sys.getsizeof(x)`在这些计算中并没有太大帮助，因为它不计算对象本身的内存——对于长度为*m*的任何数组（或具有*m*行的任何二维数组），它返回 72 + 8*m*。![Charge 对象的内存使用情况](img/684b42a9d8a199de06851a9565cfdbcd.png)

### 对象。

Python 编程的一个关键问题是：表示用户定义对象需要多少内存？这个问题的答��可能会让您感到惊讶，但了解这一点很重要：*至少几百字节*。具体来说，Python 使用 72 字节的开销*加上*280 字节用于将实例变量绑定到对象的字典（我们将在第 4.4 节讨论字典）*加上*24 字节用于每个实例变量的引用，再加上实例变量本身的内存。例如，为了表示一个`Charge`对象，Python 至少使用 72 + 280 = 352 字节的开销，8 * 3 = 24 字节来存储三个实例变量的对象引用，24 字节来存储由`_rx`实例变量引用的`float`对象，24 字节来存储由`_ry`实例变量引用的`float`对象，以及 24 字节来存储由`_q`实例变量引用的`float`对象，总共（至少）448 字节。在您的系统上，总数可能会更高，因为一些实现会消耗更多的开销。

对于每个 Python 程序员来说，理解用户定义类型的每个对象可能会消耗大量内存是很重要的。因此，一个定义大量用户定义类型对象的 Python 程序可能会使用比您预期的更多的空间（和时间）。自几十年前引入该概念以来，许多面向对象的语言已经出现并消失，其中许多最终采用了*轻量级*对象来表示用户定义类型。Python 为此提供了两个高级功能——*命名元组*和*槽*——但我们在本书中不会利用这些内存优化。

* * *

#### 问答

**Q.** 文本指出，对非常大的整数进行操作可能会消耗超过常数时间。您能更精确地说明吗？

**A.** 并非如此。"非常大"的定义取决于系统。对于大多数实际目的，您可以认为应用于 32 位或 64 位整数的操作在常数时间内运行。现代密码学应用涉及具有数百或数千位数的巨大数字。

**Q.** 我如何找出在我的计算机上将两个浮点数相加或相乘需要多长时间？

**A.** 进行一些实验！程序 timeops.py 使用`Stopwatch`，如在第 3.2 节中定义的 stopwatch.py，来测试整数和浮点数的各种算术运算的执行时间。这种技术测量的是实际经过的时间，就像在挂钟上观察到的一样。如果您的系统没有运行许多其他应用程序，它可以产生准确的结果。Python 还包括用于测量小代码片段运行时间的`timeit`模块。

**Q.** 有没有办法测量处理器时间而不是挂钟时间？

**A.** 在某些系统上，函数调用`time.clock()`返回当前处理器时间作为浮点数，以秒为单位表示。如果可用，您应该用`time.clock()`替换`time.time()`来对 Python 程序进行基准测试。

**Q.** 函数如`math.sqrt()`、`math.log()`和`math.sin()`��要多少时间？

**A.** 进行一些实验！如在 stopwatch.py 中定义的 Stopwatch，使得很容易组合程序，比如 timeops.py 来自己回答这类问题。如果养成这样做的习惯，您将能够更有效地使用计算机。

**Q.** 为什么分配大小为*n*的数组（Python 列表）需要与*n*成正比的时间？

**A.** Python 将所有数组元素初始化为程序员指定的值。也就是说，在 Python 中，没有办法为数组分配内存而不为数组的每个元素分配对象引用。为大小为*n*的数组的每个元素分配对象引用需要与*n*成正比的时间。

**Q.** 我如何找出我的 Python 程序可用的内存量？

**A.** 由于 Python 在内存耗尽时会引发`MemoryError`，因此运行一些实验并不困难。例如，使用 bigarray.py。像这样运行它：

```
% python bigarray.py 100000000
finished

```

以显示您有 100 百万个整数的空间。但如果您键入

```
% python bigarray.py 1000000000

```

Python 将挂起、崩溃或引发运行时错误；您可以得出结论，您没有足够的空间来存储 10 亿个整数的数组。

**Q.** 当有人说算法的最坏情况运行时间是*O*(*n*²)时，这意味着什么？

**A.** 那是一种称为*大 O*表示法的记法示例。我们写*f*(*n*)是*O*(*g*(*n*))，如果存在常数*c*和*n*[0]，使得对于所有*n* > *n*[0]，*f*(*n*) ≤ *c* *g*(*n*)。换句话说，函数*f*(*n*)在常数因子和足够大的*n*值下被*g*(*n*)上界约束。例如，函数 30*n*² + 10*n* + 7 是*O*(*n*²)。我们说算法的最坏情况运行时间是*O*(*g*(*n*))，如果作为输入大小*n*的函数运行时间对于所有可能的输入都是*O*(*g*(*n*))。这种记法被理论计算机科学家广泛用于证明关于算法的定理，因此如果您学习算法和数据结构课程，您肯定会看到它。它提供了最坏情况性能保证。

**Q.** 那么我可以利用算法的最坏情况运行时间为*O*(*n*³)或*O*(*n*²)来预测性能吗？

**A.** 不，因为实际运行时间可能要少得多。例如，函数 30*n*² + 10*n* + 7 是*O*(*n*²)，但它也是*O*(*n*³)和*O*(*n*¹⁰)，因为大 O 符号只提供最坏情况下运行时间的上限。此外，即使有一些输入族，其运行时间与给定函数成正比，也许这些输入在实践中并不常见。因此，你不能使用大 O 符号来预测性能。我们使用的波浪符号和增长顺序分类比大 O 符号更精确，因为它们提供了函数增长的匹配上限和下限。许多程序员错误地使用大 O 符号来表示匹配的上限和下限。

**Q.** Python 通常使用多少内存来存储包含 *n* 个项目的元组？

**A.** 56 + 8*n* 字节，再加上对象本身所需的内存。这比数组少一点，因为 Python 可以使用数组而不是调整大小的数组来实现元组（在机器级别）。

**Q.** 为什么 Python 要使用这么多内存（280 字节）来存储一个将对象的实例变量映射到其值的字典？

**A.** 原则上，同一数据类型的不同对象可以有不同的实例变量。在这种情况下，Python 需要一种方式来管理每个对象的可能实例变量的任意数量。但大多数 Python 代码不需要这样做（而且，作为一种风格，我们在这本书中从未需要过）。

* * *

#### 练习

1.  修改 threesum.py 以接受一个名为 `x` 的命令行参数，并在标准输入中找到三个数字的组合，使它们的和最接近 `x`。

1.  编写一个程序`foursum.py`，从标准输入中获取一个整数 `n`，然后从标准输入中读取 `n` 个整数，并计算总和为零的 4 元组的数量。使用四重循环。你的程序的运行时间增长的顺序是多少？估计你的程序在一个小时内能处理的最大 `n` 是多少。然后，运行你的程序验证你的假设。

1.  证明 1 + 2 + ... + *n* = *n*(*n*+1)/2。

    *解答*：我们在第 2.3 节开始时通过归纳证明了这一点。以下是另一种证明的基础：

    ```
       1  +  2  + ... + n-1 +  n
    +  n  + n-1 + ... +  2  +  1
     ----------------------------
      n+1 + n+1 + ... + n+1 + n+1

    ```

1.  通过归纳证明，在 0 到 *n*-1 之间的不同三元组的数量是 *n*(*n*-1)(*n*-2)/6。

    *解答*：对于 *n* = 2，该公式是正确的。对于 *n* > 2，计算所有不包含 *n*-1 的三元组，根据归纳假设为(*n*-1)(*n*-2)(*n*-3)/6，以及包含 *n*-1 的所有三元组，为(*n*-1)(*n*-2)/2，得到总数

    > | (*n*-1)(*n*-2)(*n*-3)/6 + (*n*-1)(*n*-2)/2 = *n*(*n*-1)(*n*-2)/6 |
    > | --- |

1.  通过用积分近似显示，在 0 到 *n*-1 之间的不同三元组的数量约为 *n*³/6。

    ![积分](img/5ed3101072467ee6e7356d1e76ab2b89.png)

1.  运行以下代码片段后，`x` 的值（作为 *n* 的函数）是多少？

    ```
    x = 0
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                x += 1

    ```

    *解答*：*n*(*n*-1)(*n*-2)/6。

1.  使用波浪符号简化以下每个公式，并给出每个的增长顺序：

    +   *n*(*n* - 1)(*n* - 2)(*n* - 3) / 24

    +   (*n* - 2) (lg *n* - 2) (lg *n* + 2)

    +   *n*(*n* + 1) - *n*²

    +   *n*(*n* + 1)/2 + *n* lg *n*

    +   ln((*n* - 1)(*n* - 2) (*n* - 3))²

1.  以下代码片段是线性的、二次的还是立方的（作为 *n* 的函数）？

    ```
    for i in range(n):
        for j in range(n):
            if i == j:
                c[i][j] = 1.0
            else:
                c[i][j] = 0.0

    ```

1.  假设算法在大小为 1000、2000、3000 和 4000 的输入上的运行时间分别为 5 秒、20 秒、45 秒和 80 秒。估计解决大小为 5000 的问题需要多长时间。该算法是线性的、线性对数的、二次的、立方的还是指数的？

1.  你更喜欢哪种算法：二次的、线性对数的还是线性的？

    *解决方案*：尽管根据增长顺序做出快速决定很诱人，但这样做很容易被误导。你需要对问题规模和运行时间的主导系数的相对值有一些了解。例如，假设运行时间为*n*²秒，100 *n* log[2] *n*秒，和 10,000 *n*秒。对于*n*最多约为 1000 时，二次算法将是最快的，而线性算法永远不会比线性对数算法更快（*n*必须大于 2¹⁰⁰，远远太大了，不值得考虑）。

1.  运用科学方法来开发和验证关于以下代码片段的运行时间增长顺序的假设，作为输入参数`n`的函数。

    ```
    def f(n):
        if (n == 0):
            return 1
        return f(n-1) + f(n-1)

    ```

1.  运用科学方法来开发和验证关于以下两个代码片段的运行时间增长顺序的假��，作为`n`的函数。

    ```
    s = ''
    for i in range(n):
        if stdrandom.bernoulli(0.5):
            s += '0'
        else:
            s += '1'

    ```

    ```
    s = ''
    for i in range(n):
        oldS = s
        if stdrandom.bernoulli(0.5):
            s += '0'
        else:
            s += '1'

    ```

    *解决方案*：在许多系统上，第一个是线性的；第二个是二次的。你无法知道原因：在第一种情况下，Python 检测到*s*是唯一引用字符串的变量，因此它会将每个字符附加到字符串上，就像对列表一样（在摊销常数时间内），即使字符串是不可变的！一个更安全的替代方法是创建一个包含字符的列表，并通过调用`join()`方法将它们连接在一起。

    ```
    a = []
    for i in range(n):
        if stdrandom.bernoulli(0.5):
            a += ['0']
        else:
            a += ['1']
    s = ''.join(a)

    ```

1.  下面的四个 Python 函数中的每个函数返回一个长度为`n`且所有字符都是`x`的字符串。确定每个函数的运行时间的增长顺序。回想一下，在 Python 中连接两个字符串的时间与它们长度的和成正比。

    ```
    def f1(n):
        if (n == 0):
            return ''
        temp = f1(n // 2)
        if (n % 2 == 0):
            return temp + temp
        else:
            return temp + temp + 'x'

    ```

    ```
    def f2(n):
        s = ''
        for i in range(n):
            s += 'x'
        return s

    ```

    ```
    def f3(n):
        if (n == 0):
            return ''
        if (n == 1):
            return 'x'
        return f3(n//2) + f3(n - n//2)

    ```

    ```
    def f4(n):
        temp = stdarray.create1D(n, 'x')
        return ''.join(temp)

    ```

    ```
    def f5(n):
        return 'x' * n

    ```

1.  以下代码片段（改编自一本 Java 编程书籍）创建了从 0 到*n*-1 的整数的随机排列。确定其运行时间的增长顺序作为*n*的函数。将其增长顺序与第 1.4 节中的洗牌代码进行比较。

    ```
    a = stdarray.create1D(n, 0)
    taken = stdarray.create1D(n, False)
    count = 0
    while (count < n):
        r = stdrandom.uniformInt(n)
        if not taken[r]:
            a[r] = count
            taken[r] = True
            count += 1

    ```

1.  以下代码片段中的第一个`if`语句在三重嵌套循环中执行多少次？

    ```
    for i in range(n):
        for j in range(n):
            for k in range(n):
                if (i < j) and (j < k):
                    if a[i] + a[j] + a[k] == 0:
                        count += 1

    ```

    使用波浪符号表示简化你的答案。

1.  运用科学方法来开发和验证关于 coupon.py（来自第 2.1 节）中`collect()`方法运行时间增长顺序的假设，作为参数`n`的函数。*注意*：加倍对于区分线性和线性对数假设并不有效 — 你可以尝试将输入大小的平方。

1.  运用科学方法来开发和验证关于 markov.py（来自第 1.6 节）运行时间增长顺序的假设，作为`moves`和`n`参数的函数。

1.  编写一个名为`mooreslaw.py`的程序，该程序接受一个命令行参数*n*，并在处理器速度每*n*个月翻倍时，写入处理器速度在十年内的增长量。如果速度每*n* = 15 个月翻倍，处理器速度在接下来的十年内将增加多少？24 个月呢？

1.  使用文本中的内存模型，给出第三章中以下数据类型的每个对象的内存需求：

    +   `秒表`

    +   `乌龟`

    +   `向量`

    +   `主体`

    +   `宇宙`

1.  估计 visualizev.py（来自第 2.4 节）在垂直渗透检测下使用的空间量，作为网格大小*n*的函数。*额外学分*：回答当使用 percolation.py 中的递归渗透检测方法时相同的问题。

1.  估计你的计算机可以容纳的最大*n*乘以*n*的整数数组的大小，然后尝试分配这样的数组。

1.  估计 comparedocuments.py（来自第 3.3 节）使用的空间量，作为文档数量*n*和维度*d*的函数。

1.  编写一个版本的 primesieve.py（来自第 1.4 节），它使用整数数组而不是布尔数组，并在每个整数中使用 32 位，以提高其能处理的最大*n*值的因子为 32。

1.  以下表格给出了各个程序在不同*n*值下的运行时间。根据给定信息填写空白处的估计值。

    > | 程序 | 1,000 | 10,000 | 100,000 | 1,000,000 |
    > | --- | --- | --- | --- | --- |
    > | A | 0.001 秒 | 0.012 秒 | 0.16 秒 | ?秒 |
    > | B | 1 分钟 | 10 分钟 | 1.7 小时 | ?小时 |
    > | C | 1 秒 | 1.7 分钟 | 2.8 小时 | ?天 |

    给出每个程序运行时间增长顺序的假设。

* * *

#### 创意练习

1.  **三数之和分析**。计算*n*个随机 32 位整数中没有三元组总和为 0 的概率，并给出*n*等于 1000、2000 和 4000 时的近似估计。*额外加分*：给出预期这样的三元组数量的近似公式（作为*n*的函数），并运行实验验证你的估计。

1.  **最接近对**。设计一个二次算法，找到彼此最接近的整数对。（在下一节中，你将被要求找到一个线性对数算法。）

1.  **幂律**。证明函数*cn^b*的对数-对数图的斜率为*b*，*x*截距为 log *c*。对于 4 *n*³(log *n*)²，斜率和*x*截距是多少？

1.  **距离零最远的和**。设计一个找到和距离零最远的整数对的算法。你能发现一个线性算法吗？

1.  **"贝克"漏洞**。���个流行的 Web 服务器支持一个名为`no2slash()`的函数，其目的是折叠多个`/`字符。例如，字符串`/d1///d2////d3/test.html`变成`/d1/d2/d3/test.html`。原始算法是重复搜索`/`并复制字符串的其余部分：

    ```
    def no2slash(name):
        nameList = list(name)
        x = 1
        while x < len(nameList):
            if (nameList[x-1] == '/') and (nameList[x] == '/'):
                for y in range(x+1, len(nameList)):
                    nameList[y-1] = nameList[y]
                nameList = nameList[:-1]
            else:
                x += 1
        return ''.join(nameList)

    ```

    不幸的是，这段代码的运行时间与输入中的`/`字符数量成二次关系。通过发送带有大量`/`字符的多个同时请求，黑客可以淹没服务器并使其他进程饥饿，从而创建拒绝服务攻击。开发一个在线性时间内运行且不允许这种攻击的`no2slash()`版本。

1.  **年轻图**。假设你在内存中有一个*n*乘*n*的整数网格`a[][]`，使得对于所有的`i`和`j`，`a[i][j] < a[i+1][j]`且`a[i][j] < a[i][j+1]`，就像下面的表格一样。

    ```
     5 23 54 67 89
     6 69 73 74 90
    10 71 83 84 91
    60 73 84 86 92
    90 91 92 93 94

    ```

    设计一个在*n*中具有线性增长顺序的算法，用于确定给定整数*x*是否在给定的年轻图中。

    *解决方案*：从右上角开始。如果值为*x*，则返回`True`。否则，如果值大于*x*则向左移动，如果值小于*x*则向下移动。如果到达左下角，则*x*不在表中。该算法是线性的，因为你最多可以向左移动*n*次，向下移动*n*次。

1.  **子集和**。编写一个名为`anysum.py`的程序，从标准输入中获取一个整数*n*，然后从标准输入中读取*n*个整数，并计算总和为 0 的子集数量。给出程序运行时间的增长顺序。

1.  **数组旋转**。给定一个包含*n*个元素的数组，给出一个线性时间算法来将数组旋转*k*个位置。也就是说，如果数组包含*a*[0]、*a*[1]、...、*a*[n-1]，则旋转后的数组是*a*[k]、*a*[k+1]、...、*a*[n-1]、*a*[0]、...、*a*[k-1]。使用最多恒定量的额外空间（数组索引和数组值）。*提示*：反转三个子数组。

1.  **查找重复整数**。 (a) 给定一个从 1 到*n*的*n*个整数数组，其中一个值重复两次，一个缺失，给出一个在线性时间和常数额外空间内找到缺失整数的算法。 (b) 给定一个只读的*n*个整数数组，其中每个值从 1 到*n*-1 出现一次，一个出现两次，给出一个在线性时间和常数额外空间内找到重复值的算法。 (c) 给定一个只读的*n*个整数数组，值介于 1 和*n*-1 之间，给出一个在线性时间和常数额外空间内找到重复值的算法。

1.  **阶乘**。设计一个快速算法来计算大值*n*!。使用你的程序计算 1000000!中连续 9 的最长运行时间。为你的算法的运行时间增长顺序开发并验证一个假设。

1.  **最大和**。设计一个线性算法，在*n*个整数序列中找到最多*m*个元素的连续子序列，其和最大。实现你的算法，并确认其运行时间的增长顺序为线性。

1.  **模式匹配**。给定一个由黑色（1）和白色（0）像素组成的*n*×*n*数组，设计一个线性算法，找到完全由黑色像素组成的最大正方形子数组。例如，以下 8×8 数组包含一个完全由黑色像素组成的 3×3 子数组。

    ```
    1 0 1 1 1 0 0 0
    0 0 0 1 0 1 0 0
    0 0 1 1 1 0 0 0
    0 0 1 1 1 0 1 0
    0 0 1 1 1 1 1 1
    0 1 0 1 1 1 1 0
    0 1 0 1 1 0 1 0
    0 0 0 1 1 1 1 0

    ```

    实现你的算法，并确认其运行时间的增长顺序与像素数量成线性关系。*额外加分*：设计一个算法来找到最大的*矩形*黑色子数组。

1.  **最大平均值**。编写一个程序，在*n*个整数数组中找到最多*m*个元素的连续子数组，其平均值最高，通过尝试所有子数组。使用科学方法确认你的程序的运行时间增长顺序为*mn*²。接下来，编写一个程序，通过首先计算`prefix[i] = a[0] + ... + a[i]`，然后使用表达式`(prefix[j] - prefix[i]) / (j - i + 1)`计算从`a[i]`到`a[j]`的区间的平均值。使用科学方法确认这种方法将运行时间的增长顺序减少了一个*n*的因子。

1.  **次指数函数**。找到一个比任何多项式函数慢但比任何指数函数快的函数。*额外加分*：编写一个具有该增长顺序的运行时间的程序。

**调整数组**。对于以下每种策略，要么证明每个调整数组操作的摊销时间为常数，要么找到一系列*n*个操作（从空数据结构开始），其时间为二次方。

1.  当调整数组满时，将容量加倍；当数组半满时，将容量减半。

1.  当调整数组满时，将容量加倍；当数组三分之一满时，将容量减半。

1.  当调整数组满时，将容量增加 9/8 倍；当数组 80%满时，将容量减少 9/8 倍。
