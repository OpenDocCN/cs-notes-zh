- en: 3.2 Creating Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 创建数据类型
- en: 原文：[https://introcs.cs.princeton.edu/python/32class](https://introcs.cs.princeton.edu/python/32class)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/32class](https://introcs.cs.princeton.edu/python/32class)
- en: In the last section we explained how to *use* our own data types in Python.
    In this section we explain how to *implement* them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们解释了如何在Python中*使用*我们自己的数据类型。在本节中，我们将解释如何*实现*它们。
- en: In Python, we implement a data type using a *class*. Implementing a data type
    as a Python class is not very different from implementing a function module as
    a set of functions. The primary differences are that we associate values (in the
    form of instance variables) with methods and that each method call is associated
    with the object used to invoke it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们使用一个*类*来实现数据类型。将数据类型实现为Python类与将函数模块实现为一组函数并没有太大的不同。主要区别在于我们将值（以实例变量的形式）与方法关联起来，并且每个方法调用都与用于调用它的对象相关联。
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Basic Elements of a Data Type
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型的基本元素
- en: To illustrate the process of implementing a data type as a Python class, we
    now consider an implementation of the `Charge` data type of Section 3.1.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明将数据类型实现为Python类的过程，我们现在考虑第3.1节��`Charge`数据类型的实现。
- en: API.
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API。
- en: We repeat below the Charge API. We have already looked at APIs as specifications
    of how to use data types in client code; now look at them as specifications of
    how to implement data types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下面重复了Charge API。我们已经看过API作为如何在客户端代码中使用数据类型的规范；现在看它们作为如何实现数据类型的规范。
- en: '![Charge API](../Images/e557eacb2fb9b790687584395eab1e07.png)'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Charge API](../Images/e557eacb2fb9b790687584395eab1e07.png)'
- en: Class.
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类。
- en: In Python, we implement a data type as a *class*. We define the `Charge` class
    in a file named [charge.py](charge.py.html). To define a class, we use the keyword
    `class`, followed by the class name, followed by a colon, and then a list of method
    definitions. Our class defines a constructor, instance variables, and methods,
    which we will address in detail next.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们将数据类型实现为一个*类*。我们在名为[charge.py](charge.py.html)的文件中定义了`Charge`类。要定义一个类，我们使用关键字`class`，后跟类名，然后是一个冒号，然后是一系列方法定义。我们的类定义了一个构造函数、实例变量和方法，我们将在接下来详细讨论。
- en: Constructor.
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数。
- en: A constructor creates an object of the specified type and returns a reference
    to that object. For our example, the client code
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数创建指定类型的对象并返回对该对象的引用。对于我们的示例，客户端代码
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: returns a new `Charge` object, suitably initialized. Python provides a flexible
    and general mechanism for object creation, but we adopt a simple subset that well
    serves our style of programming. Specifically, in this booksite, each data type
    defines a special method `__init__()` whose purpose is to define and initialize
    the instance variables, as described below. The double underscores before and
    after the name are your clue that it is "special" — we will be encountering other
    special methods soon.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个新的`Charge`对象，适当初始化。Python提供了一个灵活和通用的对象创建机制，但我们采用了一个简单的子集，很好地服务于我们的编程风格。具体来说，在这本书站点中，每种数据类型都定义了一个特殊方法`__init__()`，其目的是定义和初始化实例变量，如下所述。名称前后的双下划线是你的线索，表明它是“特殊的”
    — 我们很快就会遇到其他特殊方法。
- en: When a client calls a constructor, Python's default construction process creates
    a new object of the specified type, calls the `__init__()` method to define and
    initialize the instance variables, and returns a reference to the new object.
    In this booksite, we refer to `__init__()` as the *constructor* for the data type,
    even though it is technically only the pertinent part of the object-creation process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端调用构造函数时，Python的默认构造过程会创建指定类型的新对象，调用`__init__()`方法来定义和初始化实例变量，并返回对新对象的引用。在这本书站点中，我们将`__init__()`称为数据类型的*构造函数*，即使从技术上讲，它只是对象创建过程的相关部分。
- en: '![Anatomy of a constructor](../Images/e3f97d9d4321be0e8420a3b0a8266834.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![构造函数的解剖](../Images/e3f97d9d4321be0e8420a3b0a8266834.png)'
- en: The code at right is the `__init__()` implementation for `Charge`. It is a method,
    so its first line is a signature consisting of the keyword `def`, its name (`__init__`),
    a list of parameter variables, and a colon. By convention, the first parameter
    variable is named `self`. *As part of Python's default object creation process,
    the value of the self parameter variable when `__init()__` is invoked is a reference
    to the newly created object.* The ordinary parameter variables from the client
    follow the special parameter variable `self`. The remaining lines make up the
    body of the constructor. Our convention throughout this book is for `__init()__`
    to consist of code that initializes the newly created object by defining and initializing
    the instance variables.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的代码是`Charge`的`__init__()`实现。它是一个方法，因此它的第一行是一个签名，由关键字`def`、它的名称(`__init__`)、一个参数变量列表和一个冒号组成。按照惯例，第一个参数变量被命名为`self`。*作为Python默认对象创建过程的一部分，当调用`__init()__`时，self参数变量的值是对新创建对象的引用。*来自客户端的普通参数变量跟随特殊参数变量`self`。其余行组成构造函数的主体。本书中的惯例是，`__init()__`由初始化新创建对象的代码组成，通过定义和初始化实例变量。
- en: Instance variables.
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例变量。
- en: A data type is a set of values and a set of operations defined on those values.
    In Python, *instance variables* implement the values. An instance variable belongs
    to a particular instance of a class — that is, to a particular object. In this
    booksite, our convention is to define and initialize each instance variable of
    the newly created object in the constructor and only in the constructor. The standard
    convention in Python programs is that instance variable names begin with an underscore.
    In our implementations, you can inspect the constructor to see the entire set
    of instance variables. For example, the `__init__()` implementation on the previous
    page tells us that `Charge` has three instance variables `_rx`, `_ry`, and `_q`.
    When an object is created, the value of the `self` parameter variable of the `__init__()`
    method is a reference to that object. Just as we can call a method for a charge
    `c` with the syntax `c.potentialAt()`, so we can refer to an instance variable
    for a charge `self` with the syntax `self._rx`. Therefore the three lines within
    the `__init__()` constructor for `Charge` define and initialize `_rx`, `_ry`,
    and `_q` for the new object. ![Creating and initializing an object](../Images/b828042db656f789820c825a399fbc46.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Details of object creation.
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The memory diagrams at the right detail the precise sequence of events when
    a client creates a new `Charge` object with the code
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python creates the object and calls the `__init__()` constructor, initializing
    the constructor's `self` parameter variable to reference the newly created object,
    its `x0` parameter variable to reference 0.51, its `y0` parameter variable to
    reference 0.63, and its `q0` parameter variable to reference 21.3.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor defines and initializes the `_rx`, `_ry`, and `_q` instance
    variables within the newly created object referenced by self.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the constructor finishes, Python automatically returns to the client the
    self reference to the newly created object.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client assigns that reference to `c1`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameter variables `x0`, `y0`, and `q0` go out of scope when `__init__()`
    is finished, but the objects they reference are still accessible via the new object's
    instance variables.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Methods.
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To define methods, we compose code that is precisely like the code that we
    learned in Chapter 2 to define functions, with the (significant) exception that
    methods can also access instance variables. For example, the code of the `potentialAt()`
    method for our `Charge` data type is shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Anatomy of a method](../Images/e7619165b0e2364fbc373bc7f16009c4.png)'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'The first line is the method''s signature: the keyword `def`, the name of the
    method, parameter variables names in parentheses, and a colon. The first parameter
    variable of every method is named `self`. When a client calls a method, Python
    automatically sets that `self` parameter variable to reference the object to be
    manipulated — the object that was used to invoke the method. For example, when
    a client calls our method with `c.potentialAt(x, y)`, the value of the `self`
    parameter variable of the `potentialAt()` method is set to `c`. The ordinary parameter
    variables from the client (`x` and `y`, in this case) follow the special parameter
    variable `self`. The remaining lines make up the body of the `potentialAt()` method.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Variables within methods.
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand method implementations, it is very important to know that a method
    typically uses three kinds of variables:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The `self` object's instance variables
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method's parameter variables
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local variables
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The differences between the three kinds of variables are a key to object-oriented
    programming and are summarized in this table:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Variables within methods](../Images/b4ccaf3413d7c4e494945afe0884be9e.png)'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: In our example, `potentialAt()` uses the `_rx`, `_ry`, and `_q` instance variables
    of the object referenced by `self`, the parameter variables `x` and `y`, and the
    local variables `COULOMB`, `dx`, `dy`, and `r` to compute and return a value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Methods are functions.
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法就是函数。
- en: A method is a special kind of function that is defined in a class and associated
    with an object. The key difference between functions and methods is that a method
    is associated with a specified object, with direct access to its instance variables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是一种在类中定义并与对象关联的特殊类型的函数。函数和方法之间的关键区别在于方法与指定的对象相关联，并直接访问其实例变量。
- en: Built-in functions.
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置函数。
- en: The third operation in the `Charge` API is a built-in function `str(c)`. Python's
    convention is to automatically translate this function call to a standard method
    call `c.__str()__`. Thus, to support this operation, we implement the special
    method `__str__()`, which uses the instance variables associated with the invoking
    object to string together the desired result.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Charge` API 中的第三个操作是内置函数 `str(c)`。Python 的约定是自动将此函数调用转换为标准方法调用 `c.__str()__`。因此，为了支持这个操作，我们实现了特殊方法
    `__str__()`，它使用与调用对象关联的实例变量将所需结果串在一起。'
- en: Privacy.
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐私。
- en: A client should access a data type only through the methods in its API. Sometimes
    it is convenient to define helper methods in the implementation that are not intended
    to be called directly by the client. The special method `__str__()` is a prototypical
    example. As we saw in Section 2.2 with private functions, the standard Python
    convention is to name such methods with a leading underscore. The leading underscore
    is a strong signal to the client not to call that private method directly. Similarly,
    naming instance variables with a leading underscore signals to the client not
    to access such private instance variables directly. Even though Python has no
    language support for enforcing these conventions, most Python programmers treat
    them as sacrosanct.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应该只通过 API 中的方法访问数据类型。有时，在实现中定义一些辅助方法是方便的，这些方法不打算由客户端直接调用。特殊方法 `__str__()`
    就是一个典型的例子。正如我们在第 2.2 节中看到的私有函数一样，标准的 Python 约定是以下划线开头命名这些方法。下划线开头是一个强烈的信号，告诉客户端不要直接调用该私有方法。类似地，以下划线开头命名实例变量也告诉客户端不要直接访问这些私有实例变量。尽管
    Python 没有语言支持来强制执行这些约定，但大多数 Python 程序员将其视为神圣不可侵犯。
- en: 'The implementation of the `Charge` data type in [charge.py](charge.py.html)
    illustrates all of the features that we have described, and also defines a test
    client. This diagram relates the code in [charge.py](charge.py.html) to its features:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[charge.py](charge.py.html) 中 `Charge` 数据类型的实现展示了我们描述的所有特性，并定义了一个测试客户端。这个图表将
    [charge.py](charge.py.html) 中的代码与其特性相关联：'
- en: '![Anatomy of a class definition](../Images/f071143df75368deb0978fc03be7b904.png)'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![类定义的解剖](../Images/f071143df75368deb0978fc03be7b904.png)'
- en: For the rest of this section, we apply these basic steps to create a number
    of interesting data types and clients.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将这些基本步骤应用于创建许多有趣的数据类型和客户端。
- en: '* * *'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Stopwatch
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秒表
- en: 'The program [stopwatch.py](stopwatch.py.html) defines a `Stopwatch` class which
    implements this API:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 [stopwatch.py](stopwatch.py.html) 定义了一个 `Stopwatch` 类，实现了这个 API：
- en: '![Stopwatch API](../Images/21dda2c9b1e4cfee75a801c2d5b95905.png)'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![秒表 API](../Images/21dda2c9b1e4cfee75a801c2d5b95905.png)'
- en: A `Stopwatch` object is a stripped-down version of an old-fashioned stopwatch.
    When you create one, it starts running, and you can ask it how long it has been
    running by invoking the method `elapsedTime()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch` 对象是一个简化版本的老式秒表。创建时开始计时，可以通过调用 `elapsedTime()` 方法询问它已经运行了多长时间。'
- en: '* * *'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Histogram
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直方图
- en: 'The program [histogram.py](histogram.py.html) defines a `Histogram` class for
    graphically representing the distribution of data using bars of different heights
    in a chart known as a *histogram*. This is its API:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 [histogram.py](histogram.py.html) 定义了一个 `Histogram` 类，用于以不同高度的条形图形式图形地表示数据的分布，这种图表称为*直方图*。这是它的
    API：
- en: '![Histogram API](../Images/8a61006038b5ccf205e120459d6335d6.png)'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![直方图 API](../Images/8a61006038b5ccf205e120459d6335d6.png)'
- en: A `Histogram` object maintains an array of the frequency of occurrence of integer
    values in a given interval. Its `draw()` method scales the drawing so that the
    tallest bar fits snugly in the canvas, and then calls `stdstats.plotBars()` to
    display a histogram of the values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Histogram` 对象维护一个给定区间内整数值出现频率的数组。它的 `draw()` 方法将绘图缩放，使最高的条形图紧密地适应画布，然后调用 `stdstats.plotBars()`
    来显示值的直方图。'
- en: '| `% python histogram.py 50 .5 100000` | ![](../Images/373ca78cc3593e13575017a43d2ffbb8.png)
    |'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python histogram.py 50 .5 100000` | ![](../Images/373ca78cc3593e13575017a43d2ffbb8.png)
    |'
- en: '* * *'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Turtle Graphics
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 海龟图形
- en: 'Imagine a turtle that lives in the unit square and draws lines as it moves.
    It can move a specified distance in a straight line, or it can rotate left (counterclockwise)
    a specified number of degrees. According to this API:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个生活在单位正方形中并在移动时绘制线条的海龟。它可以沿直线移动指定的距离，或者可以向左旋转（逆时针）指定的角度。根据这个 API：
- en: '![Turtle API](../Images/23a00824dc65b3ea15aa649b6951ec8f.png)'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![海龟 API](../Images/23a00824dc65b3ea15aa649b6951ec8f.png)'
- en: when we create a turtle, we place it at a specified point, facing a specified
    direction. Then, we create drawings by giving the turtle a sequence of `goForward()`
    and `turnLeft()` commands.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个海龟时，我们将它放在指定的点，面向指定的方向。然后，通过给海龟一系列的 `goForward()` 和 `turnLeft()` 命令来创建绘图。
- en: For example, to draw a triangle we create a turtle at (0, 0.5) facing at an
    angle of 60 degrees counterclockwise from the *x*-axis, then direct it to take
    a step forward, then rotate 120 degrees counterclockwise, then take another step
    forward, then rotate another 120 degrees counterclockwise, and then take a third
    step forward to complete the triangle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要绘制一个三角形，我们在 (0, 0.5) 处创建一个海龟，面向从 *x* 轴逆时针旋转 60 度的角度，然后指示它向���迈一步，然后逆时针旋转
    120 度，再向前迈一步，然后再逆时针旋转 120 度，最后再向前迈一步以完成三角形。
- en: 'The `Turtle` class defined in [turtle.py](turtle.py.html) is an implementation
    of this API that uses `stddraw`. It maintains three instance variables: the coordinates
    of the turtle''s position and the current direction it is facing, measured in
    degrees counterclockwise from the *x*-axis (*polar angle*). Implementing the two
    methods requires *updating* the values of these variables, so `Turtle` objects
    are mutable. The necessary updates are straightforward: `turnLeft(delta)` adds
    delta to the current angle, and `goForward(step)` adds the step size times the
    cosine of its argument to the current *x*-coordinate and the step size times the
    sine of its argument to the current *y*-coordinate. The test client in `Turtle`
    takes an integer `n` as a command-line argument and draws a regular polygon with
    `n` sides.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[turtle.py](turtle.py.html)中定义的`Turtle`类是使用`stddraw`实现的API，它维护三个实例变量：乌龟位置的坐标和当前面向的方向，以逆时针从*x*轴（*极角*）测量的角度。实现这两个方法需要*更新*这些变量的值，因此`Turtle`对象是可变的。必要的更新很简单：`turnLeft(delta)`将delta添加到当前角度，`goForward(step)`将步长乘以其参数的余弦值添加到当前*x*坐标，将步长乘以其参数的正弦值添加到当前*y*坐标。`Turtle`中的测试客户端将整数`n`作为命令行参数，并绘制具有`n`个边的正多边形。
- en: '| `% python turtle.py 3` | `% python turtle.py 7` | `% python turtle.py 1000`
    |'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python turtle.py 3` | `% python turtle.py 7` | `% python turtle.py 1000`
    |'
- en: '| ![](../Images/0b774af070960a9f598e633609dbe66f.png) | ![](../Images/ccac2f2a9ce741662cb3f356b79edab3.png)
    | ![](../Images/9754fb5ea28805d95bc0013f358d543a.png) |'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/0b774af070960a9f598e633609dbe66f.png) | ![](../Images/ccac2f2a9ce741662cb3f356b79edab3.png)
    | ![](../Images/9754fb5ea28805d95bc0013f358d543a.png) |'
- en: Koch curves.
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 科赫曲线。
- en: A *Koch curve* of order 0 is a straight line. To form a Koch curve of order
    *n*, draw a Koch curve of order *n* - 1, turn left 60 degrees, draw a second Koch
    curve of order *n* - 1, turn right 120 degrees (left -120 degrees), draw a third
    Koch curve of order *n* - 1, turn left 60 degrees, and draw a fourth Koch curve
    of order *n* - 1\. These recursive instructions lead immediately to the turtle
    client code shown in [koch.py](koch.py.html). With appropriate modifications,
    recursive schemes like this have proved useful in modeling self-similar patterns
    found in nature, such as snowflakes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 阶数为0的*科赫曲线*是一条直线。要形成阶数为*n*的科赫曲线，画一条阶数为*n* - 1的科���曲线，左转60度，画第二条阶数为*n* - 1的科赫曲线，右转120度（左转-120度），画第三条阶数为*n*
    - 1的科赫曲线，左转60度，画第四条阶数为*n* - 1的科赫曲线。这些递归指令立即导致了在[koch.py](koch.py.html)中显示的乌龟客户端代码。通过适当的修改，像这样的递归方案已被证明在模拟自然中发现的自相似模式，如雪花，中是有用的。
- en: '| `% python koch.py 0` | `% python koch.py 1` |'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python koch.py 0` | `% python koch.py 1` |'
- en: '| ![](../Images/c8c1bff51a274f2a3aeddcb94d077388.png) | ![](../Images/91f165800a98698f03f07aaf36aed909.png)
    |'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/c8c1bff51a274f2a3aeddcb94d077388.png) | ![](../Images/91f165800a98698f03f07aaf36aed909.png)
    |'
- en: '| `% python koch.py 2` | `% python koch.py 3` |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python koch.py 2` | `% python koch.py 3` |'
- en: '| ![](../Images/80d59065ab83dc87e494603d8b8b6758.png) | ![](../Images/114bfae41c253f0e8771515c01f945a5.png)
    |'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/80d59065ab83dc87e494603d8b8b6758.png) | ![](../Images/114bfae41c253f0e8771515c01f945a5.png)
    |'
- en: '| `% python koch.py 4` |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python koch.py 4` |'
- en: '| ![](../Images/87f09a341d85bb4c4e3ab2c442af6257.png) |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/87f09a341d85bb4c4e3ab2c442af6257.png) |'
- en: Spira mirabilis.
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 奇迹螺线。
- en: Imagine that the turtle's step size decays by a tiny constant factor (close
    to 1) each time it takes a step. What happens to our drawings? Remarkably, modifying
    the polygon-drawing test client in [turtle.py](turtle.py.html) to answer this
    question leads to an image known as a [logarithmic spiral](https://en.wikipedia.org/wiki/Logarithmic_spiral),
    a curve that is found in many contexts in nature. The program [spiral.py](spiral.py.html)
    is an implementation of this curve. The script takes three command-line arguments,
    which control the shape and nature of the spiral.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，乌龟的步长每次前进时都会以微小的恒定因子（接近1）衰减。我们的图形会发生什么变化？值得注意的是，修改[turtle.py](turtle.py.html)中的多边形绘制测试客户端以回答这个问题会导致一种被称为[对数螺线](https://en.wikipedia.org/wiki/Logarithmic_spiral)的图像，这是许多自然环境中都存在的曲线。程序[spiral.py](spiral.py.html)是这种曲线的实现。该脚本接受三个命令行参数，控制螺旋的形状和性质。
- en: '| `% python spiral.py 3 1 1.0` | `% python spiral.py 3 10 1.2` |'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python spiral.py 3 1 1.0` | `% python spiral.py 3 10 1.2` |'
- en: '| ![](../Images/7d5fac33a5ec355835062b8f28ac4f2b.png) | ![](../Images/a2fdbc309982ea63117591ec1d1a4ff0.png)
    |'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/7d5fac33a5ec355835062b8f28ac4f2b.png) | ![](../Images/a2fdbc309982ea63117591ec1d1a4ff0.png)
    |'
- en: '| `% python spiral.py 1440 10 1.00004` | `% python spiral.py 1440 10 1.0004`
    |'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python spiral.py 1440 10 1.00004` | `% python spiral.py 1440 10 1.0004`
    |'
- en: '| ![](../Images/5b2799bd860db25d19915edee1b182c4.png) | ![](../Images/1a9f235285c18977f6950b751b5065cc.png)
    |'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/5b2799bd860db25d19915edee1b182c4.png) | ![](../Images/1a9f235285c18977f6950b751b5065cc.png)
    |'
- en: 'The logarithmic spiral was first described by Rene Descartes in 1638\. Jacob
    Bernoulli was so amazed by its mathematical properties that he named it the *spira
    mirabilis* (miraculous spiral). Many people also consider it to be "miraculous"
    that this precise curve is clearly present in a broad variety of natural phenomena:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对数螺线最早由勒内·笛卡尔于1638年描述。雅各布·伯努利对其数学特性感到惊讶，因此将其命名为*奇迹螺线*（miraculous spiral）。许多人也认为这个精确的曲线在各种自然现象中清晰可见是"奇迹"：
- en: '| **Nautilus Shell** | **Spiral Galaxy** | **Storm Clouds** |'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **鹦鹉螺壳** | **螺旋星系** | **暴风云** |'
- en: '| ![](../Images/a896f6d0fdc985d0372c50cf43382263.png) | ![](../Images/e1b84f03ed8ac6632c42a2cdf164173b.png)
    | ![](../Images/f66de97204ed7279ec522ea9ab51e14d.png) |'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/a896f6d0fdc985d0372c50cf43382263.png) | ![](../Images/e1b84f03ed8ac6632c42a2cdf164173b.png)
    | ![](../Images/f66de97204ed7279ec522ea9ab51e14d.png) |'
- en: Brownian motion.
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布朗运动。
- en: Imagine a disoriented turtle (again following its standard alternating turn
    and step regimen) turns in a random direction before each step. The program [drunk.py](drunk.py.html)
    plots the path followed by such a turtle. In 1827, the botanist Robert Brown observed
    through a microscope that pollen grains immersed in water seemed to move about
    in just such a random fashion, which later became known as [Brownian motion](https://en.wikipedia.org/wiki/Brownian_motion)
    and led to Albert Einstein's insights into the atomic nature of matter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一只迷失方向的乌龟（再次按照其标准的交替转向和步进规则）在每一步之前随机转向。程序 [drunk.py](drunk.py.html) 绘制了这样一只乌龟所走过的路径。1827年，植物学家罗伯特·布朗通过显微镜观察到浸泡在水中的花粉颗粒似乎以这种随机方式移动，后来被称为
    [布朗运动](https://en.wikipedia.org/wiki/Brownian_motion)，并引发了阿尔伯特·爱因斯坦对物质原子性质的洞察。
- en: '| `% python drunk.py 10000 .01` |'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python drunk.py 10000 .01` |'
- en: '| ![](../Images/9beda515d3dfbdccea727e2a527c4200.png) |'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/9beda515d3dfbdccea727e2a527c4200.png) |'
- en: The program [drunks.py](drunks.py.html) plots many such turtles, all of whom
    wander around.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 [drunks.py](drunks.py.html) 绘制了许多这样的乌龟，它们都在四处漫步。
- en: '| `% python drunks.py 20 500 .005` | `% python drunks.py 20 1000 .005` |'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python drunks.py 20 500 .005` | `% python drunks.py 20 1000 .005` |'
- en: '| ![](../Images/7dbf6154e02e7393d446697c711ad313.png) | ![](../Images/effe9be40a3e3dca9cb242b0b916c907.png)
    |'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/7dbf6154e02e7393d446697c711ad313.png) | ![](../Images/effe9be40a3e3dca9cb242b0b916c907.png)
    |'
- en: '| `% python drunks.py 20 5000 .005` |'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python drunks.py 20 5000 .005` |'
- en: '| ![](../Images/5e8e1a1e2e6188d47e0d5aca941b5cc4.png) |'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/5e8e1a1e2e6188d47e0d5aca941b5cc4.png) |'
- en: Turtle graphics was originally developed by Seymour Papert at MIT in the 1960s
    as part of an educational programming language, [Logo](https://en.wikipedia.org/wiki/Logo_%28programming_language%29).
    But turtle graphics is no toy, as we have just seen in numerous scientific examples.
    Turtle graphics also has numerous commercial applications. For example, it is
    the basis for [PostScript](https://en.wikipedia.org/wiki/PostScript), a programming
    language for creating printed pages that is used for most newspapers, magazines,
    and books.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 乌龟图形最初是由麻省理工学院的西摩·帕帕特在20世纪60年代作为教育性编程语言 [Logo](https://en.wikipedia.org/wiki/Logo_%28programming_language%29)
    的一部分开发的。但是乌龟图形并不是玩具，正如我们刚刚在许多科学示例中看到的那样。乌龟图形还有许多商业应用。例如，它是 [PostScript](https://en.wikipedia.org/wiki/PostScript)
    的基础，这是一种用于创建大多数报纸、杂志和书籍的印刷页面的编程语言。
- en: '* * *'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Complex Numbers
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数
- en: 'A complex number is a number of the form *x* + *yi*, where *x* and *y* are
    real numbers and *i* is the square root of -1\. The number *x* is known as the
    *real* part of the complex number, and the number *y* is known as the *imaginary*
    part. This terminology stems from the idea that the square root of -1 has to be
    an imaginary number, because no real number can have this value. Complex numbers
    are a quintessential mathematical abstraction: whether or not one believes that
    it makes sense physically to take the square root of -1, complex numbers help
    us understand the natural world.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 复数是形式为 *x* + *yi* 的数，其中 *x* 和 *y* 是实数，*i* 是 -1 的平方根。数 *x* 被称为复数的 *实部*，数 *y*
    被称为复数的 *虚部*。这个术语源于平方根 -1 必须是一个虚数的想法，因为没有实数可以具有这个值。复数是一个典型的数学抽象：无论一个人是否认为从物理上讲得通取
    -1 的平方根，复数都帮助我们理解自然界。
- en: The Python language provides a `complex` (with a lowercase `c`) data type. In
    real applications you certainly should take advantage of `complex` unless you
    find yourself wanting more operations than it provides. However, since developing
    a data type for complex numbers is a prototypical exercise in object-oriented
    programming, we now consider our own `Complex` (with an uppercase `C`) data type.
    Doing so will allow us to consider a number of interesting issues surrounding
    data types for mathematical abstractions, in a nontrivial setting.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言提供了一个 `complex`（小写 `c`）数据类型。在实际应用中，除非你发现自己需要更多的操作，否则你肯定应该利用 `complex`。然而，由于为复数开发数据类型是面向对象编程的一个典型练习，我们现在考虑自己的
    `Complex`（大写 `C`）数据类型。这样做将使我们能够考虑围绕数学抽象的数据类型的一些有趣问题，在一个非平凡的环境中。
- en: 'The operations on complex numbers that are needed for basic computations are
    to add and multiply them by applying the commutative, associative, and distributive
    laws of algebra (along with the identity i² = -1); to compute the magnitude; and
    to extract the real and imaginary parts, according to the following equations:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的基本计算所需的操作是通过应用代数的交换律、结合律和分配律（以及恒等式 i² = -1）来对它们进行加法和乘法运算；计算幅度；并根据以下方程式提取实部和虚部：
- en: '*Addition*: (*x*+*yi*) + (*v*+*wi*) = (*x*+*v*) + (*y*+*w*)*i*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加法*：(*x*+*yi*) + (*v*+*wi*) = (*x*+*v*) + (*y*+*w*)*i*'
- en: '*Multiplication*: (*x* + *yi*) * (*v* + *wi*) = (*xv* - *yw*) + (*yv* + *xw*)*i*'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*乘法*：(*x* + *yi*) * (*v* + *wi*) = (*xv* - *yw*) + (*yv* + *xw*)*i*'
- en: '*Magnitude*: |*x* + *yi*| = (*x*² + *y*²)^(1/2)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*幅度*：|*x* + *yi*| = (*x*² + *y*²)^(1/2)'
- en: '*Real part*: Re(*x* + *yi*) = *x*'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实部*：Re(*x* + *yi*) = *x*'
- en: '*Imaginary part*: Im(*x* + *yi*) = *y*'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚部*：Im(*x* + *yi*) = *y*'
- en: As usual, we start with an API that specifies the data-type operations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们从规定数据类型操作的 API 开始。
- en: '![Complex API](../Images/fbd48f1e83abb91af2efa5eb0b9d00f9.png)'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![复数 API](../Images/fbd48f1e83abb91af2efa5eb0b9d00f9.png)'
- en: The `Complex` class defined in [complex.py](complex.py.html) implements that
    API.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [complex.py](complex.py.html) 中定义的 `Complex` 类实现了该 API。
- en: Special methods.
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊方法。
- en: When Python sees the expression `a + b` in client code, it replaces it with
    the method call `a.__add__(b)`. Similarly, Python replaces `a * b` with the method
    call `a.__mul__(b)`. Therefore, we need only to implement the special methods
    `__add__()` and `__mul__()` for addition and multiplication to operate as expected.
    The mechanism is the same one that we used to support Python's built-in `str()`
    function for `Charge`, by implementing the `__str__()` special method, except
    that the special methods for arithmetic operators take two arguments. The above
    API includes an extra column that maps the client operations to the special methods.
    We generally omit this column in our APIs because these names are standard, and
    irrelevant to clients. The list of Python special methods is extensive — we will
    discuss them further in Section 3.3.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python在客户端代码中看到表达式`a + b`时，它将其替换为方法调用`a.__add__(b)`。类似地，Python将`a * b`替换为方法调用`a.__mul__(b)`。因此，我们只需要为加法和乘法实现特殊方法`__add__()`和`__mul__()`，以使加法和乘法按预期运行。这个机制与我们用来支持Python内置的`str()`函数对`Charge`实现`__str__()`特殊方法的机制相同，只是算术运算符的特殊方法需要两个参数。上面的API包括一个额外的列，将客户端操作映射到特殊方法。我们通常在我们的API中省略这一列，因为这些名称是标准的，与客户端无关。Python特殊方法的列表很广泛——我们将在第3.3节进一步讨论它们。
- en: Accessing instance variables in objects of this type.
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问此类型对象中的实例变量。
- en: 'The implementations of both `__add__()` and `__mul__()` need to access values
    in two objects: the object passed as an argument and the object used to call the
    method (that is, the object referenced by `self`). When the client calls `a.__add__(b)`,
    the parameter variable `self` is set to reference the same object as argument
    `a` does, and the parameter variable `other` is set to reference the same object
    as argument `b` does. We can access the instance variables of a using `self._re`
    and `self._im`, as usual. To access the instance variables of `b`, we use the
    code `other._re` and `other._im`. Since our convention is to keep the instance
    variables private, we do not access directly instance variables in another class.
    Accessing instance variables within another object in the same class does not
    violate this privacy policy.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`__add__()`和`__mul__()`的实现需要访问两个对象中的值：作为参数传递的对象和用于调用方法的对象（即，被`self`引用的对象）。当客户端调用`a.__add__(b)`时，参数变量`self`被设置为引用与参数`a`相同的对象，参数变量`other`被设置为引用与参数`b`相同的对象。我们可以像往常一样使用`self._re`和`self._im`访问a的实例变量。要访问`b`的实例变量，我们使用代码`other._re`和`other._im`。由于我们的约定是保持实例变量私有，我们不直接访问另一个类中的实例变量。在同一类中访问另一个对象中的实例变量不违反此隐私政策。'
- en: Immutability.
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性。
- en: The two instance variables in `Complex` are set for each `Complex` object when
    it is created and do not change during the lifetime of an object. That is, `Complex`
    objects are immutable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Complex`中的两个实例变量在创建`Complex`对象时设置，并在对象的生命周期内不会更改。也就是说，`Complex`对象是不可变的。'
- en: Mandelbrot Set.
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mandelbrot集合。
- en: 'The *Mandelbrot set* is a specific set of complex numbers discovered by Benoit
    Mandelbrot that has many fascinating properties. It is a fractal pattern that
    is related to the Barnsley fern, the Sierpinski triangle, the Brownian bridge,
    the Koch curve, the drunken turtle, and other recursive (self-similar) patterns
    and programs that we have seen in this book. The set of points in the Mandelbrot
    set cannot be described by a single mathematical equation. Instead, it is defined
    by an algorithm and, therefore, a perfect candidate for a complex client: we study
    the set by composing a program to plot it.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mandelbrot集合*是由Benoit Mandelbrot发现的一组特定的复数，��有许多迷人的性质。它是一个与Barnsley蕨类、Sierpinski三角形、Brownian桥、Koch曲线、醉龟等我们在本书中看到的递归（自相似）模式和程序相关的分形图案。Mandelbrot集合中的点集不能用单个数学方程描述。相反，它由一个算法定义，因此是一个复杂客户端的完美候选者：我们通过编写一个程序来绘制它来研究这个集合。'
- en: <consider the="" sequence="" of="" complex="" numbers="">z[0], *z*[1], *z*[2],
    ... , *z*[t], ... , where *z*[*t*]+1 = (*z*[*t*])² + *z*[0]. For example, this
    table shows the first few entries in the sequence corresponding to *z*[0] = 1
    + *i*:</consider>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <考虑复数序列>z[0]，*z*[1]，*z*[2]，...，*z*[t]，...，其中*z*[*t*]+1 = (*z*[*t*])² + *z*[0]。例如，这个表格显示了对应于*z*[0]
    = 1 + *i*的序列的前几个条目：</consider>
- en: '![Mandelbrot sequence computation](../Images/8f67abf6fa62c9fa8882be5d467596a9.png)'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Mandelbrot序列计算](../Images/8f67abf6fa62c9fa8882be5d467596a9.png)'
- en: Now, if the sequence |*z[t]*| diverges to infinity, then *z*[0] is not in the
    Mandelbrot set; if the sequence is bounded, then *z*[0] is in the Mandelbrot set.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果序列|*z[t]*|发散到无穷大，那么*z*[0]不在Mandelbrot集合中；如果序列有界，那么*z*[0]在Mandelbrot集合中。
- en: '![Mandelbrot set](../Images/fc85adefb3e6c6589ee8e8c735845db5.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Mandelbrot集合](../Images/fc85adefb3e6c6589ee8e8c735845db5.png)'
- en: 'To visualize the Mandelbrot set, we sample *complex* points, just as we sample
    real-valued points to plot a real-valued function. Each complex number *x* + *yi*
    corresponds to a point (*x*, *y*) in the plane, so we can plot the results as
    follows: for a specified resolution *n*, we define a regularly spaced *n*-by-*n*
    pixel grid within a specified square and draw a black pixel if the corresponding
    point is in the Mandelbrot set and a white pixel if it is not.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化Mandelbrot集合，我们对*复数*点进行采样，就像我们对实数点进行采样以绘制实值函数一样。每个复数*x* + *yi*对应于平面上的一个点（*x*，*y*），因此我们可以按照以下方式绘制结果：对于指定分辨率*n*，我们在指定的正方形内定义一个*n*乘*n*像素网格，并在相应点在Mandelbrot集合中时绘制黑色像素，在不在时绘制白色像素。
- en: 'There is no simple test that enables us to conclude that a point is surely
    in the set. But there is a simple mathematical test that tells us for sure that
    a point is *not* in the set: if the magnitude of any number in the sequence ever
    exceeds 2 (such as 1 + 3*i*), then the sequence surely will diverge. The program
    [mandelbrot.py](mandelbrot.py.html) uses this test to plot a visual representation
    of the Mandelbrot set. Since our knowledge of the set is not quite black-and-white,
    we use grayscale in our visual representation. The basis of the computation is
    the function `mandel()`, which takes a complex argument `z0` and an integer argument
    `limit` and computes the Mandelbrot iteration sequence starting at `z0`, returning
    the number of iterations for which the magnitude stays less than (or equal to)
    2, up to the given limit. The complexity of the images that this simple program
    produces is remarkable, even when we zoom in on a tiny portion of the plane.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的测试可以让我们断定一个点肯定在集合中。但有一个简单的数学测试可以告诉我们肯定一个点*不*在集合中：如果序列中的任何数字的大小超过2（例如1 +
    3*i*），那么该序列肯定会发散。程序[mandelbrot.py](mandelbrot.py.html)使用这个测试来绘制Mandelbrot集的视觉表示。由于我们对该集合的了解并不十分黑白分明，因此在我们的视觉表示中使用灰度。计算的基础是函数`mandel()`，它接受一个复数参数`z0`和一个整数参数`limit`，并计算从`z0`开始的Mandelbrot迭代序列，返回在给定限制下保持大小小于（或等于）2的迭代次数。即使在我们放大平面的一个小部分时，这个简单程序产生的图像的复杂性也是显著的。
- en: '| `% python mandelbrot.py 512 -.5 0 2` | `% python mandelbrot.py 512 .1015
    -.633 .01` |'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python mandelbrot.py 512 -.5 0 2` | `% python mandelbrot.py 512 .1015
    -.633 .01` |'
- en: '| ![](../Images/d5c71fb87273a29de8070e03cec42a46.png) | ![](../Images/a52e537ca166ef3695246590d7521667.png)
    |'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/d5c71fb87273a29de8070e03cec42a46.png) | ![](../Images/a52e537ca166ef3695246590d7521667.png)
    |'
- en: Producing an image with [mandelbrot.py](mandelbrot.py.html) requires hundreds
    of millions of operations on complex values. Accordingly, we use Python's `complex`
    data type, which is certain to be more efficient than the `Complex` data type
    that we just considered.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[mandelbrot.py](mandelbrot.py.html)生成图像需要对复数值进行数亿次操作。因此，我们使用Python的`complex`数据类型，这肯定比我们刚考虑的`Complex`数据类型更有效率。
- en: '* * *'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Commercial Data Processing
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 商业数据处理
- en: 'Suppose that a stock broker needs to maintain customer accounts containing
    shares of various stocks. That is, the set of values the broker needs to process
    includes the customer''s name, number of different stocks held, number of shares
    and ticker symbol for each stock, and cash on hand. To process an account, the
    broker needs at least the operations defined in this API:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设股票经纪人需要维护包含各种股票股份的客户账户。也就是说，经纪人需要处理的值集合包括客户姓名、持有的不同股票数量、每支股票的股票数量和股票代码，以及手头现金。为了处理一个账户，经纪人至少需要在此API中定义的操作：
- en: '![StockAccount API](../Images/88d0d130fbd2b97790d6344c16fbc428.png)'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![StockAccount API](../Images/88d0d130fbd2b97790d6344c16fbc428.png)'
- en: The customer information has a long lifetime and needs to be saved in a file
    or database. To process an account, a client program needs to read information
    from the corresponding file; process the information as appropriate; and, if the
    information changes, write it back to the file, saving it for later. To enable
    this kind of processing, we need a file format and an internal representation,
    or a data structure, for the account information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 客户信息具有很长的生命周期，并且需要保存在文件或数据库中。为了处理一个账户，客户端程序需要从相应的文件中读取信息；适当处理信息；如果信息发生变化，则将其写回文件，保存以备后用。为了实现这种处理，我们需要一个文件格式和一个内部表示，或者账户信息的数据结构。
- en: File format.
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件格式。
- en: 'Modern systems often use text files, even for data, to minimize dependence
    on formats defined by any one program. For simplicity, we use a direct representation
    where we list the account holder''s name (a string), cash balance (a float), and
    number of stocks held (an integer), followed by a line for each stock giving the
    number of shares and the ticker symbol. For example the file [turing.txt](turing.txt)
    contains these data:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统通常使用文本文件，即使是用于数据，以减少对任何一个程序定义的格式的依赖。为简单起见，我们使用直接表示，其中列出了账户持有人的姓名（字符串）、现金余额（浮点数）和持有的股票数量（整数），然后是每支股票的一行，列出了股票数量和股票代码。例如，文件[turing.txt](turing.txt)包含了这些数据：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Data structure.
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据结构。
- en: 'To implement a `StockAccount`, we use the following instance variables:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个`StockAccount`，我们使用以下实例变量：
- en: A string for the account name
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串用于账户名
- en: A float for the cash on hand
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个浮点数用于手头现金
- en: An integer for the number of stocks
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数用于股票数量
- en: An array of strings for stock symbols
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串数组用于股票代码
- en: An array of integers for numbers of shares
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数数组用于股票数量
- en: The `StockAccount` class defined in [stockaccount.py](stockaccount.py.html)
    implements those design decisions. The arrays `_stocks[]` and `_shares[]` are
    known as *parallel arrays*. Given an index `i`, `_stocks[i]` gives a stock symbol
    and `_shares[i]` gives the number of shares of that stock in the account. The
    `valueOf()` method uses [stockquote.py](../31datatype/stockquote.py.html) (from
    Section 3.1) to get each stock's price from the web. The implementations of `buy()`
    and `sell()` require the use of basic mechanisms introduced in Section 4.4, so
    we defer them to an exercise in that section. The test client accepts a the name
    of a file (such as the aforementioned [turing.txt](turing.txt)) as a command-line
    argument, and writes an appropriate report.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在[stockaccount.py](stockaccount.py.html)中定义的`StockAccount`类实现了这些设计决策。数组`_stocks[]`和`_shares[]`被称为*并行数组*。给定索引`i`，`_stocks[i]`给出股票代码，`_shares[i]`给出账户中该股票的股票数量。`valueOf()`方法使用[stockquote.py](../31datatype/stockquote.py.html)（来自第3.1节）从网络获取每支股票的价格。`buy()`和`sell()`的实现需要在第4.4节介绍的基本机制，因此我们将它们推迟到该部分的练习中。测试客户端接受一个文件名（例如前述的[turing.txt](turing.txt)）作为命令行参数，并编写适当的报告。
- en: '* * *'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问答
- en: '**Q.** Can I define a class in a file whose name is unrelated to the class
    name? Can I define more than one class in a single .py file?'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 我可以在与类名无关的文件中定义一个类吗？我可以在一个.py文件中定义多个类吗？'
- en: '**A.** Yes and yes, but we do not do so in this chapter as a matter of style.
    In Chapter 4, we will encounter a few situations where these features are appropriate.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，但出于风格考虑，我们在本章中没有这样做。在第4章中，我们将遇到一些适合使用这些特性的情况。'
- en: '**Q.** If `__init__()` is technically not a constructor, what is?'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果`__init__()`在技术上不是构造函数，那是什么？'
- en: '**A.** Another special function, `__new__()`. To create a object, Python first
    calls `__new__()` and then `__init__()`. For the programs in this book, the default
    implementation of `__new__()` serves our purposes, so we do not discuss it.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 另一个特殊函数，`__new__()`。为了创建一个对象，Python首先调用`__new__()`，然后调用`__init__()`。对于本书中的程序，`__new__()`的默认实现符合我们的目的，因此我们不讨论它。'
- en: '**Q.** Must every class have a constructor?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 每个类都必须有一个构造函数吗？'
- en: '**A.** Yes, but if you do not define a constructor, Python provides a default
    (no-argument) constructor automatically. With our conventions, such a data type
    would be useless, as it would have no instance variables.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，但如果你不定义构造函数，Python会自动提供一个默认（无参数）构造函数。按照我们的约定，这样的数据类型将是无用的，因为它没有实例变量。'
- en: '**Q.** Why do I need to use `self` explicitly when referring to instance variables?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么在引用实例变量时需要显式使用`self`？'
- en: '**A.** Syntactically, Python needs some way to know whether you are assigning
    to a local variable or to an instance variable. In many other programming languages
    (such as C++ and Java), you declare explicitly the data type''s instance variables,
    so there is no ambiguity. The `self` variable also makes it easy for programmers
    to know whether code is referring to a local variable or an instance variable.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 在语法上，Python需要一种方式来知道你是在为局部变量还是实例变量赋值。在许多其他编程语言（如C++和Java）中，你明确声明数据类型的实例变量，因此没有歧义。`self`变量还使程序员很容易知道代码是在引用局部变量还是实例变量。'
- en: '**Q.** Suppose I do not include a `__str__()` method in my data type. What
    happens if I call `str()` or `stdio.writeln()` with an object of that type?'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 假设我在我的数据类型中不包括`__str__()`方法。如果我使用该类型的对象调用`str()`或`stdio.writeln()`会发生什么？'
- en: '**A.** Python provides a default implementation that returns a string containing
    the object''s type and its identity (memory address). This is unlikely to be of
    much use, so you usually want to define your own.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** Python提供了一个默认实现，返回一个包含对象类型和其标识（内存地址）的字符串。这通常不太有用，所以你通常会想要定义自己的实现。'
- en: '**Q.** Are there other kinds of variables besides parameter, local, and instance
    variables in a class?'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 除了参数、局部和实例变量之外，类中还有其他种类的变量吗？'
- en: '**A.** Yes. Recall from Chapter 1 that you can define *global variables* in
    global code, outside of the definition of any function, class, or method. The
    scope of global variables is the entire `.py` file. In modern programming, we
    focus on limiting scope and therefore rarely use global variables (except in tiny
    scripts not intended for reuse). Python also supports *class variables*, which
    are defined inside a class but outside any method. Each class variable is shared
    among all of the objects in a class; this contrasts with instance variables, where
    there is one per object. Class variables have some specialized uses, but we do
    not use them in this book.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的。回想一下第1章，你可以在全局代码中定义*全局变量*，在任何函数、类或方法的定义之外。全局变量的作用域是整个`.py`文件。在现代编程中，我们专注于限制作用域，因此很少使用全局变量（除了不打算重用的小型脚本）。Python还支持*类变量*，这些变量在类内部定义，但在任何方法之外。每个类变量在类中的所有对象之间共享；这与实例变量形成对比，实例变量每个对象一个。类变量有一些专门的用途，但我们在本书中不使用它们。'
- en: '**Q.** Is it just me, or are Python''s conventions for naming things complicated?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 只有我觉得Python的命名约定很复杂吗？'
- en: '**A.** Yes, but this is also true of many other programming languages. Here
    is a quick summary of the naming conventions we have encountered in the book:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，但这也适用于许多其他编程语言。以下是我们在本书中遇到的命名约定的快速总结：'
- en: A variable name starts with lowercase letter.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名以小写字母开头。
- en: A constant variable name consists of uppercase letters.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量变量名由大写字母组成。
- en: An instance variable name starts with an underscore and a lowercase letter.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量名以下划线和小写字母开头。
- en: A method name starts with a lowercase letter.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法名以小写字母开头。
- en: A special method name starts with a double underscore and a lowercase letter
    and ends with a double underscore.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特殊方法名以双下划线和小写字母开头，以双下划线结尾。
- en: A user-defined class name starts with an uppercase letter.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户定义的类名以大写字母开头。
- en: A built-in class name starts with a lowercase letter.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个内置类名以小写字母开头。
- en: A script or module is stored in a file whose name consists of lowercase letters
    and ends with `.py`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本或模块存储在以小写字母结尾的文件中，文件名以`.py`结尾。
- en: 'Most of those conventions are not part of the language, though many Python
    programmers treat them as if they are. You might wonder: If they are so important,
    why not make them part of the language? Good question. Still, some programmers
    are passionate about such conventions, and you are likely to someday encounter
    a teacher, supervisor, or colleague who insists that you follow a certain style,
    so you may as well go with the flow. Indeed, many Python programmers separate
    multi-word variable names with underscores instead of capital letters, preferring
    `is_prime` and `hurst_exponent` to `isPrime` and `hurstExponent`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些约定并不是语言的一部分，尽管许多Python程序员将其视为语言的一部分。你可能会想：如果它们如此重要，为什么不将其纳入语言中呢？好问题。然而，一些程序员对这些约定非常热衷，你很可能会在某一天遇到一个坚持让你遵循某种风格的老师、主管或同事，所以最好跟着大流。事实上，许多Python程序员使用下划线而不是大写字母来分隔多个单词的变量名，更喜欢`is_prime`和`hurst_exponent`而不是`isPrime`和`hurstExponent`。
- en: '**Q.** How can I specify a literal for the `complex` data type?'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 我如何为`complex`数据类型指定文字？'
- en: '**A.** Appending the character `j` to a numeric literal produces an imaginary
    number (whose real part is zero). You can add this character to a numeric literal
    to produce a complex number, as in `3 + 7j`. The choice of `j` instead of `i`
    is common in some engineering disciplines. Note that `j` is not a complex literal
    — instead, you must use `1j`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 将字符`j`附加到数值文字产生一个虚数（其实部为零）。你可以将这个字符添加到数值文字中以产生一个复数，如`3 + 7j`。在某些工程学科中，选择`j`而不是`i`是常见的。请注意，`j`不是一个复数文字
    —— 相反，你必须使用`1j`。'
- en: '**Q.** The [mandelbrot.py](mandelbrot.py.html) program creates a huge number
    of `complex` objects. Doesn''t all that object-creation overhead slow things down?'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** [mandelbrot.py](mandelbrot.py.html)程序创建了大量的`complex`对象。所有这些对象创建的开销会减慢速度吗？'
- en: '**A.** Yes, but not so much that we cannot generate our plots. Our goal is
    to make our programs readable and easy to compose and maintain. Limiting scope
    via the complex number abstraction helps us achieve that goal. If you need to
    speed up [mandelbrot.py](mandelbrot.py.html) significantly for some reason, you
    might consider bypassing the complex number abstraction and using a lower-level
    language where numbers are not objects. Generally, Python is not optimized for
    performance. We will revisit this issue in Chapter 4.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 是的，但不至于使我们无法生成我们的图表。我们的目标是使我们的程序易于阅读、易于组合和易于维护。通过复数抽象限制范围有助于我们实现这一目标。如果出于某种原因需要显著加快[mandelbrot.py](mandelbrot.py.html)的速度，你可以考虑绕过复数抽象，使用一个不是对象的低级语言。一般来说，Python并不针对性能进行优化。我们将在第4章重新讨论这个问题。'
- en: '**Q.** Why is it okay for the `__add__(self, other)` method in [complex.py](complex.py.html)
    to refer to the instance variables of the parameter variable `other`? Aren''t
    these instance variables supposed to be private?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 为什么在[complex.py](complex.py.html)中的`__add__(self, other)`方法可以引用参数变量`other`的实例变量？这些实例变量不应该是私有的吗？'
- en: '**A.** Python programmers view privacy as relative to a particular class, not
    to a particular object. So, a method can refer to the instance variables of any
    object in the same class. Python has no "superprivate" naming conventions in which
    you can refer only to the instance variables of the invoking object. Accessing
    the instance variables of other can be a bit risky, however, because a careless
    client might pass an argument that is not of type `Complex`, in which case we
    would be (unknowingly) accessing an instance variable in another class! With a
    mutable type, we might even (unknowingly) modify or create instance variables
    in another class!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** Python程序员认为隐私是相对于特定类而不是特定对象的。因此，一个方法可以引用同一类中任何对象的实例变量。Python没有“超级私有”命名约定，只能引用调用对象的实例变量。然而，访问其他对象的实例变量可能有点风险，因为一个粗心的客户端可能传递一个不是`Complex`类型的参数，这样我们就会（不知情地）访问另一个类中的实例变量！对于可变类型，我们甚至可能（不知情地）修改或创建另一个类中的实例变量！'
- en: '**Q.** If methods are really functions, can I call a method using function-call
    syntax?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** 如果方法真的是函数，我可以使用函数调用语法调用一个方法吗？'
- en: '**A.** Yes, you can call a function defined in a class as either a method or
    an ordinary function. For example, if `c` is an object of type `Charge`, then
    the function call `Charge.potentialAt(c, x, y)` is equivalent to the method call
    `c.potentialAt(x, y)`. In object-oriented programming, we prefer the method-call
    syntax to highlight the role of the featured object and to avoid hardwiring the
    name of the class into the function call.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 是的，你可以将类中定义的函数称为方法或普通函数调用。例如，如果`c`是`Charge`类型的对象，则函数调用`Charge.potentialAt(c,
    x, y)`等同于方法调用`c.potentialAt(x, y)`。在面向对象编程中，我们更喜欢方法调用语法，以突出所述对象的角色，并避免将类名硬编码到函数调用中。'
- en: '* * *'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: '![Rectangle examples](../Images/472dda7f69359b46e3d33c13962a535e.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![矩形示例](../Images/472dda7f69359b46e3d33c13962a535e.png)'
- en: 'Consider the data-type implementation for (axis-aligned) rectangles shown below,
    which represents each rectangle with the coordinates of its center point and its
    width and height. Compose an API for this data type, and fill in the code for
    `perimeter()`, `intersects()`, `contains()`, and `draw()`. *Note*: Treat coincident
    lines as intersecting, so that, for example, `a.intersects(a)` is True and `a.contains(a)`
    is True.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑下面显示的（轴对齐）矩形的数据类型实现，它用矩形的中心点坐标、宽度和高度表示每个矩形。组合一个这种数据类型的API，并填写`perimeter()`、`intersects()`、`contains()`和`draw()`的代码。*注意*：将重合的线视为相交，因此，例如`a.intersects(a)`为True，`a.contains(a)`为True。
- en: '[PRE3]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compose a test client for `Rectangle` that takes three command-line arguments
    `n`, `lo`, and `hi`; generates `n` random rectangles whose width and height are
    uniformly distributed between `lo` and `hi` in the unit square; draws those rectangles
    to standard drawing; and writes their average area and average perimeter to standard
    output.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Rectangle`编写一个测试客户端，接受三个命令行参数`n`、`lo`和`hi`；在单位正方形中生成宽度和高度均匀分布在`lo`和`hi`之间的`n`个随机矩形；将这些矩形绘制到标准绘图中；并将它们的平均面积和平均周长写入标准输出。
- en: Add code to your test client from the previous exercise code to compute the
    average number of pairs of rectangles that intersect and are contained in one
    another.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码添加到你之前练习中的测试客户端代码中，计算相交并相互包含的矩形对的平均数量。
- en: Develop an implementation of your `Rectangle` API from the previous exercises
    that represents rectangles with the coordinates of their lower left and upper
    right corners. Do not change the API.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个实现你之前练习中的`Rectangle` API的实现，表示矩形的坐标为它们的左下角和右上角的坐标。不要更改API。
- en: What is wrong with the following code?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码有什么问题？
- en: '[PRE4]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Solution*. The assignment statements in the constructor create *local* variables
    `_rx`, `_ry`, and `_q`, which are assigned values from the parameter variables
    but are never used. They disappear when the constructor is finished executing.
    Instead, the constructor should create *instance* variables by prefixing each
    variable with `self` followed by the dot operator, like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*。构造函数中的赋值语句创建了本地变量`_rx`、`_ry`和`_q`，它们从参数变量中分配值，但从未被使用。它们在构造函数执行完毕时消失。相反，构造函数应该通过在每个变量前加上`self`后跟点运算符来创建实例变量，如下所示：'
- en: '[PRE5]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The underscore is not strictly required in Python, but we follow this standard
    Python convention throughout this book to indicate that our intent is for instance
    variables to be private.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，下划线并不是严格要求的，但我们在本书中遵循这个标准Python约定，以表明我们的意图是将实例变量设为私有的。
- en: Create a data type `Location` that represents a location on Earth using latitudes
    and longitudes. Include a method `distanceTo()` that computes distances using
    the great-circle distance (see the *Great circle* exercise in Section 1.2).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示地球上位置的数据类型`Location`，使用纬度和经度。包括一个`distanceTo()`方法，使用大圆距离计算距离（参见第1.2节中的*大圆*练习）。
- en: 'Python provides a data type `Fraction`, defined in the standard module `fractions.py`,
    that implements rational numbers. Implement your own version of that data type.
    Specifically, develop an implementation of the following API for a data type for
    rational numbers:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python提供了一个数据类型`Fraction`，定义在标准模块`fractions.py`中，实现有理数。实现自己版本的该数据类型。具体地，为有理数数据类型开发以下API的实现：
- en: '![Rational API](../Images/428dd58c59f55beaa5b03030a5bc6578.png)'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Rational的API](../Images/428dd58c59f55beaa5b03030a5bc6578.png)'
- en: Use `euclid.gcd()` defined in [euclid.py](../23recursion/euclid.py.html) (from
    Section 2.3) to ensure that the numerator and denominator never have any common
    factors. Include a test client that exercises all of your methods.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用[euclid.py](../23recursion/euclid.py.html)中定义的`euclid.gcd()`（来自第2.3节）确保分子和分母永远没有任何公共因子。包括一个测试客户端，测试所有您的方法。
- en: An *interval* is defined to be the set of all points on a line greater than
    or equal to `left` and less than or equal to `right`. In particular, an interval
    with `right` less than `left` is empty. Compose a data type `Interval` that implements
    the API shown below. Include a test client that is a filter and takes a float
    `x` from the command line and writes to standard output (1) all of the intervals
    from standard input (each defined by a pair of floats) that contain `x` and (2)
    all pairs of intervals from standard input that intersect one another.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*区间*被定义为一条线上大于等于`left`且小于等于`right`的所有点的集合。特别地，`right`小于`left`的区间为空。组合一个实现以下API的数据类型`Interval`。包括一个测试客户端，是一个过滤器，从命令行获取一个浮点数`x`，并将包含`x`的所有输入的区间（每个由一对浮点数定义）写入标准输出，并将相互交叉的所有区间对写入标准输出。'
- en: '![Interval API](../Images/0e9e2ae2bb145818ffb5034624fe794c.png)'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Interval的API](../Images/0e9e2ae2bb145818ffb5034624fe794c.png)'
- en: Develop an implementation of your `Rectangle` API (from a previous exercise
    in this section) that takes advantage of `Interval` (from the previous exercise
    in this section) to simplify and clarify the code.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个实现您的`Rectangle` API（在本节的先前练习中）的实现，利用`Interval`（在本节的先前练习中）来简化和澄清代码。
- en: Compose a data type `Point` that implements the following API. Include a client
    of your own design.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个数据类型`Point`，实现以下API。包括一个自己设计的客户端。
- en: '![Point API](../Images/bf038ca0164d514c98a06c2862e3ca87.png)'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Point的API](../Images/bf038ca0164d514c98a06c2862e3ca87.png)'
- en: Add methods to `Stopwatch`, as defined in [stopwatch.py](stopwatch.py.html)
    that allow clients to stop and restart the stopwatch.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加到`Stopwatch`的方法，如[stopwatch.py](stopwatch.py.html)中定义的，允许客户端停止和重新启动秒表。
- en: Use a `Stopwatch` to compare the cost of computing harmonic numbers with a `for`
    loop (as shown in Section 1.3) as opposed to using the recursive method given
    in Section 2.3.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stopwatch`比较使用`for`循环计算谐波数（如第1.3节所示）的成本，与使用第2.3节中给出的递归方法相比。
- en: Modify the test client in [turtle.py](turtle.py.html) to produce stars with
    `n` points for odd `n`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[turtle.py](turtle.py.html)中的测试客户端，以便为奇数`n`生成星星。
- en: Compose a version of [mandelbrot.py](mandelbrot.py.html) that uses `Complex`
    instead of Python's `complex`. Then use `Stopwatch` (as defined in [stopwatch.py](stopwatch.py.html))
    to compute the ratio of the running times of the two programs.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个版本的[mandelbrot.py](mandelbrot.py.html)，使用`Complex`代替Python的`complex`。然后使用`Stopwatch`（如[stopwatch.py](stopwatch.py.html)中定义的）来计算两个程序的运行时间比率。
- en: Modify the `__str__()` method in class `Complex`, as defined in [complex.py](complex.py.html),
    so that it writes complex numbers in the traditional format. For example, it should
    write the value 3 - *i* as `3 - i` instead of `3.0 + -1.0i`, the value 3 as `3`
    instead of `3.0 + 0.0i`, and the value 3*i* as `3i` instead of `0.0 + 3.0i`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[class `Complex`中的`__str__()`方法](complex.py.html) ，使其以传统格式写出复数。例如，它应该将值3 -
    *i*写为`3 - i`，而不是`3.0 + -1.0i`，将值3写为`3`，而不是`3.0 + 0.0i`，将值3*i*写为`3i`，而不是`0.0 +
    3.0i`。
- en: Compose a `Complex` client that takes three floats *a*, *b*, and *c* as command-line
    arguments and writes the complex roots of *ax*² + *bx* + *c*.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合一个`Complex`客户端，从命令行获取三个浮点数*a*、*b*和*c*，并写出*ax*² + *bx* + *c*的复数根。
- en: 'Write a `Complex` client `Roots` that takes two floats *a* and *b* and an integer
    *n* from the command line and writes the *n*th roots of *a* + *bi*. *Note*: skip
    this exercise if you are not familiar with the operation of taking roots of complex
    numbers.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`Complex`客户端`Roots`，从命令行获取两个浮点数*a*和*b*以及一个整数*n*，并写出*a* + *bi*的第*n*个根。*注意*：如果您不熟悉复数取根的操作，请跳过此练习。
- en: 'Implement the following additions to the `Complex` API:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现对`Complex` API的以下添加：
- en: '![API for Complex (continued)](../Images/c3c3583e9106e0601f8b70424a941c09.png)'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Complex的API（续）](../Images/c3c3583e9106e0601f8b70424a941c09.png)'
- en: Include a test client that exercises all of your methods.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包括一个测试客户端，测试所有您的方法。
- en: Find a `complex` number for which `mandel()` (from [mandelbrot.py](mandelbrot.py.html))
    returns a number greater than 100, and then zoom in on that number.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个`complex`数，使得`mandel()`（来自[mandelbrot.py](mandelbrot.py.html)）返回大于100的数，然后放大该数。
- en: '* * *'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Creative Exercises
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Mutable charges**. Modify the `Charge` class as defined in [charge.py](charge.py.html)
    so that the charge value `q0` can change, by adding a method `increaseCharge()`
    that takes a float argument and adds the given value to `q0`. Then, compose a
    client that initializes an array with:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可变电荷**。修改[charge.py](charge.py.html)中定义的`Charge`类，使得电荷值`q0`可以改变，通过添加一个接受浮点参数并将给定值加到`q0`的方法`increaseCharge()`。然后，编写一个客户端，初始化一个数组：'
- en: '[PRE6]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'and then displays the result of slowly decreasing the charge value of `a[1]`
    by wrapping the code that computes the picture in a loop like the following:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后显示通过将计算图片的代码包装在类似以下循环中，逐渐减少`a[1]`的电荷值的结果：
- en: '[PRE7]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Complex timing**. Compose a `Stopwatch` client (see [stopwatch.py](stopwatch.py.html))
    that compares the cost of using `complex` to the cost of composing code that directly
    manipulates two float values, for the task of doing the calculations in [mandelbrot.py](mandelbrot.py.html).
    Specifically, create a version of [mandelbrot.py](mandelbrot.py.html) that just
    does the calculations (remove the code that refers to `Picture`), then create
    a version of that program that does not use `complex`, and then compute the ratio
    of the running times.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复杂计时**。编写一个`Stopwatch`客户端（参见[stopwatch.py](stopwatch.py.html)），比较使用`complex`和直接操作两个浮点值的代码的成本，用于执行[mandelbrot.py](mandelbrot.py.html)中的计算任务。具体来说，创建一个仅执行计算的[mandelbrot.py](mandelbrot.py.html)版本（删除引用`Picture`的代码），然后创建一个不使用`complex`的程序版本，然后计算运行时间的比率。'
- en: '**Quaternions**. In 1843, Sir William Hamilton discovered an extension to complex
    numbers called quaternions. A quaternion is a vector *a* = (*a*[0], *a*[1], *a*[2],
    *a*[3]) with the following operations:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**四元数**。1843年，威廉·哈密尔顿爵士发现了一种称为四元数的复数扩展。四元数是一个向量*a* = (*a*[0], *a*[1], *a*[2],
    *a*[3])，具有以下操作：'
- en: '*Magnitude*: |*a*| = (*a*[0]² + *a*[1]² + *a*[2]² + *a*[3]²)^(1/2).'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*幅度*：|*a*| = (*a*[0]² + *a*[1]² + *a*[2]² + *a*[3]²)^(1/2)。'
- en: '*Conjugate*: the conjugate of *a* is (*a*[0], -*a*[1], -*a*[2], -*a*[3]).'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共轭*：*a*的共轭是(*a*[0], -*a*[1], -*a*[2], -*a*[3])。'
- en: '*Inverse*: *a*^(-1) = (*a*[0] /|*a*|, -*a*[1] /|*a*|, -*a*[2] /|*a*|, -*a*[3]
    /|*a*|).'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逆*：*a*^(-1) = (*a*[0] /|*a*|, -*a*[1] /|*a*|, -*a*[2] /|*a*|, -*a*[3] /|*a*|)。'
- en: '*Sum*: *a* + *b* = (*a*[0] + *b*[0], *a*[1] + *b*[1], *a*[2] + *b*[2], *a*[3]
    + *b*[3]).'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*和*：*a* + *b* = (*a*[0] + *b*[0], *a*[1] + *b*[1], *a*[2] + *b*[2], *a*[3]
    + *b*[3])。'
- en: '*Product*: *a* * *b* = (*a*[0] *b*[0] - *a*[1] *b*[1] - *a*[2] *b*[2] - *a*[3]
    *b*[3], *a*[0] *b*[1] - *a*[1] *b*[0] + *a*[2] *b*[3] - *a*[3] *b*[2], *a*[0]
    *b*[2] - *a*[1] *b*[3] + *a*[2] *b*[0] + *a*[3] *b*[1], *a*[0] *b*[3] + *a*[1]
    *b*[2] - *a*[2] *b*[1] + *a*[3] *b*[0]).'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*积*：*a* * *b* = (*a*[0] *b*[0] - *a*[1] *b*[1] - *a*[2] *b*[2] - *a*[3] *b*[3],
    *a*[0] *b*[1] - *a*[1] *b*[0] + *a*[2] *b*[3] - *a*[3] *b*[2], *a*[0] *b*[2] -
    *a*[1] *b*[3] + *a*[2] *b*[0] + *a*[3] *b*[1], *a*[0] *b*[3] + *a*[1] *b*[2] -
    *a*[2] *b*[1] + *a*[3] *b*[0])。'
- en: '*Quotient*: *a* / *b* = *ab*^(-1).'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*商*：*a* / *b* = *ab*^(-1)。'
- en: Create a data type for quaternions and a test client that exercises all of your
    code. Quaternions extend the concept of rotation in three dimensions to four dimensions.
    They are used in computer graphics, control theory, signal processing, and orbital
    mechanics.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个四元数数据类型和一个测试客户端，测试所有你的代码。四元数将三维空间中的旋转概念扩展到四维空间。它们被用于计算机图形学、控制理论、信号处理和轨道力学。
- en: '**Dragon curves**. Compose a recursive client of `Turtle` (as defined in [turtle.py](turtle.py.html))
    named `dragon.py` that draws dragon curves (see the exercises in Sections 1.2
    and 1.5). These curves, originally discovered by three NASA physicists, were popularized
    in the 1960s by Martin Gardner and later used by Michael Crichton in the book
    and movie *Jurassic Park*. This exercise can be solved with remarkably compact
    code, based on a pair of mutually interacting recursive functions derived directly
    from the definition in the exercise in Section 1.2\. One of them, `dragon()`,
    should draw the curve as you expect; the other, `nogard()`, should draw the curve
    in *reverse* order.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**龙曲线**。编写一个递归客户端`dragon.py`，使用`Turtle`（在[turtle.py](turtle.py.html)中定义）绘制龙曲线（参见第1.2和1.5节的练习）。这些曲线最初由三位NASA物理学家发现，后来在20世纪60年代由马丁·加德纳广泛传播，并在迈克尔·克莱顿的书籍和电影《侏罗纪公园》中使用。这个练习可以用非常紧凑的代码解决，基于一对直接从第1.2节练习中的定义派生的相互作用递归函数。其中一个函数`dragon()`应该按预期绘制曲线；另一个函数`nogard()`应该以*相反*顺序绘制曲线。'
- en: '| ![](../Images/e744aedaea9a3c01c083e52e16b85a0d.png) | ![](../Images/384e4e6c3b986f4a526863dfe818973d.png)
    | ![](../Images/a0f3db472a3c240ba4bd87494983b013.png) | ![](../Images/48e7c6d3c2c127a67c69f26c56b8b835.png)
    | ![](../Images/401b59ef24127efe0630660765449a07.png) |'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/e744aedaea9a3c01c083e52e16b85a0d.png) | ![](../Images/384e4e6c3b986f4a526863dfe818973d.png)
    | ![](../Images/a0f3db472a3c240ba4bd87494983b013.png) | ![](../Images/48e7c6d3c2c127a67c69f26c56b8b835.png)
    | ![](../Images/401b59ef24127efe0630660765449a07.png) |'
- en: '| ![](../Images/28ac00cc0e991bb5db94a1239315f089.png) | ![](../Images/5c0aad30ed7dfdaa19b2da60bfea3f73.png)
    | ![](../Images/2c3d0beb888259f4b30aed129b210f2a.png) | ![](../Images/c1649c0adc1a9cd0d476f6a2bd8821f6.png)
    | ![](../Images/228f67dd632ac6fd85a703e7a282aaaa.png) |'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/28ac00cc0e991bb5db94a1239315f089.png) | ![](../Images/5c0aad30ed7dfdaa19b2da60bfea3f73.png)
    | ![](../Images/2c3d0beb888259f4b30aed129b210f2a.png) | ![](../Images/c1649c0adc1a9cd0d476f6a2bd8821f6.png)
    | ![](../Images/228f67dd632ac6fd85a703e7a282aaaa.png) |'
- en: '**Hilbert curves**. A *space-filling* curve is a continuous curve in the unit
    square that passes through every point. Compose a recursive client of `Turtle`
    (as defined in [turtle.py](turtle.py.html)) that produces these recursive patterns,
    which approach a space-filling curve that was defined by the mathematician David
    Hilbert at the end of the 19th century. See the previous exercise. You need a
    pair of methods: `hilbert()`, which traverses a Hilbert curve, and `treblih()`,
    which traverses a Hilbert curve in reverse order.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**希尔伯特曲线**。*填充空间*曲线是一个连续曲线，在单位正方形中通过每个点。组成`Turtle`的递归客户端（如[turtle.py](turtle.py.html)中定义的）来生成这些递归模式，这些模式接近19世纪末数学家大卫·希尔伯特定义的填充空间曲线。参见前一个练习。您需要一对方法：`hilbert()`，遍历希尔伯特曲线，和`treblih()`，以相反顺序遍历希尔伯特曲线。'
- en: '| ![Hilbert curve of order 1](../Images/0d4af346b940ab809ec706cbc418cec4.png)
    | ![Hilbert curve of order 2](../Images/1b5403ff4f2f538592628737ae077747.png)
    | ![Hilbert curve of order 3](../Images/06cf83a801cb0001688515fb6ad0b65f.png)
    | ![Hilbert curve of order 4](../Images/808f1aa01acde7742c31cefee958b542.png)
    | ![Hilbert curve of order 5](../Images/a6f77e57e081fbf446ec81b232a2274e.png)
    |'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![一阶希尔伯特曲线](../Images/0d4af346b940ab809ec706cbc418cec4.png) | ![二阶希尔伯特曲线](../Images/1b5403ff4f2f538592628737ae077747.png)
    | ![三阶希尔伯特曲线](../Images/06cf83a801cb0001688515fb6ad0b65f.png) | ![四阶希尔伯特曲线](../Images/808f1aa01acde7742c31cefee958b542.png)
    | ![五阶希尔伯特曲线](../Images/a6f77e57e081fbf446ec81b232a2274e.png) |'
- en: '**Gosper island**. Compose a recursive client of `Turtle` (as defined in [turtle.py](turtle.py.html))
    that produces these recursive patterns.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Gosper岛**。组成一个`Turtle`的递归客户端（如[turtle.py](turtle.py.html)中定义的），生成这些递归模式。'
- en: '| ![](../Images/98a779a6750a6225f245c358706ab27c.png) | ![](../Images/a2323810fdd6f7341ef170ef737b4afa.png)
    | ![](../Images/bbbe116b0948b67a26f7dcbe5daec276.png) | ![](../Images/d30780da0c4cd0a8f328b6e5839e807e.png)
    | ![](../Images/6618deb313f4c454ce23abf46d2a52b3.png) |'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/98a779a6750a6225f245c358706ab27c.png) | ![](../Images/a2323810fdd6f7341ef170ef737b4afa.png)
    | ![](../Images/bbbe116b0948b67a26f7dcbe5daec276.png) | ![](../Images/d30780da0c4cd0a8f328b6e5839e807e.png)
    | ![](../Images/6618deb313f4c454ce23abf46d2a52b3.png) |'
- en: '**Data analysis**. Compose a data type for use in running experiments where
    the control variable is an integer in the range [0, *n*) and the dependent variable
    is a float. For example, studying the running time of a program that takes an
    integer argument would involve such experiments. A Tukey plot is a way to visualize
    the statistics of such data (see the *Tukey plot* exercise in Section 2.2). Implement
    the following API:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据分析**。为运行实验而组成一种数据类型，其中控制变量是范围为[0, *n*)的整数，而因变量是浮点数。例如，研究接受整数参数的程序的运行时间将涉及这样的实验。Tukey图是一种可视化此类数据统计的方法（请参阅第2.2节中的*Tukey图*练习）。实现以下API：'
- en: '![Data API](../Images/2322d78b86807df822e7536445ed60b4.png)'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![数据API](../Images/2322d78b86807df822e7536445ed60b4.png)'
- en: You can use the functions in `stdstats` to do the statistical calculations and
    draw the plots. Use `stddraw` so clients can use different colors for `plot()`
    and `tukeyPlot()` (for example, light gray for all the points and black for the
    Tukey plot). Compose a test client that plots the results (percolation probability)
    of running experiments with [percolation.py](../24percolation/percolation.py.html)
    (from Section 2.4) as the grid size increases.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用`stdstats`中的函数进行统计计算和绘制图表。使用`stddraw`，以便客户端可以为`plot()`和`tukeyPlot()`使用不同的颜色（例如，所有点使用浅灰色，Tukey图使用黑色）。编写一个测试客户端，绘制运行实验的结果（渗透概率），其中[percolation.py](../24percolation/percolation.py.html)（来自第2.4节）的网格大小逐渐增加。
- en: '**Elements**. Compose a data type `Element` for entries in the periodic table
    of elements. Include data type values for element, atomic number, symbol, and
    atomic weight and accessor methods for each of these values. Then, create a data
    type `PeriodicTable` that reads values from a file to create an array of `Element`
    objects and responds to queries on standard input so that a user can type a molecular
    equation like `H2O` and the program responds by printing the molecular weight.
    Develop APIs and implementations for each data type.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**元素**。为元素周期表中的��目组成一个数据类型`Element`。包括元素、原子序数、符号和原子量的数据类型值，以及每个值的访问器方法。然后，创建一个数据类型`PeriodicTable`，从文件中读取值以创建`Element`对象数组，并响应标准输入上的查询，以便用户可以输入分子方程式如`H2O`，程序通过打印分子量来回应。为每种数据类型开发API和实现。'
- en: The file [elements.csv](elements.csv) contains the data that the program should
    read. Include fields for element, atomic number, symbol, and atomic weight. (Ignore
    fields for boiling point, melting point, density (kg/m3), heat vapour (`kJ/mol`),
    heat fusion (kJ/mol), thermal conductivity (W/m/K), and specific heat capacity
    (J/kg/K) since it's not known for all elements). The file is in CSV format (fields
    separated by commas).
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件[elements.csv](elements.csv)包含程序应该读取的数据。包括元素、原子序数、符号和原子量的字段。（忽略沸点、熔点、密度（kg/m3）、汽化热（`kJ/mol`）、熔化热（kJ/mol）、热导率（W/m/K）和比热容（J/kg/K）的字段，因为并非所有元素都知道这些值）。该文件采用CSV格式（字段由逗号分隔）。
- en: '**Stock prices**. The file [djia.csv](djia.csv) contains all closing stock
    prices in the history of the Dow Jones Industrial Average, in the comma-separated
    value format. Compose a data type `Entry` that can hold one entry in the table,
    with values for date, opening price, daily high, daily low, closing price, and
    so forth. Then, compose a data type `Table` that reads the file to build an array
    of `Entry` objects and supports methods for computing averages over various periods
    of time. Finally, create interesting `Table` clients to produce plots of the data.
    Be creative: this path is well-trodden.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**股票价格**。文件[djia.csv](djia.csv)包含道琼斯工业平均指数历史上所有收盘股价，采用逗号分隔值格式。组成一个数据类型`Entry`，可以保存表中的一个条目，其中包括日期、开盘价、当日最高价、当日最低价、收盘价等值。然后，组成一个数据类型`Table`，读取文件以构建`Entry`对象数组，并支持计算不同时间段内的平均值的方法。最后，创建有趣的`Table`客户端来生成数据的图表。发挥创造力：这条路已经被走过很多次。'
- en: '**Chaos with Newton''s method**. The polynomial *f*(*z*) = *z*⁴ - 1 has four
    roots: at 1, -1, *i*, and -*i*. We can find the roots using Newton''s method in
    the complex plane: *z*[*k*+1] = *z*[*k*] - *f*(*z*[*k*])/*f*''(*z*[*k*]). Here,
    *f*(*z*) = *z*⁴ - 1 and *f*''(*z*) = 4*z*³. The method converges to one of the
    four roots, depending on the starting point *z*[0]. Compose a client of `Complex`
    (as defined in [complex.py](complex.py.html)) named `Newton` that takes a command-line
    argument *n* and colors pixels in an *n*-by-*n* `Picture` white, red, green, or
    blue by mapping the pixels complex points in a regularly spaced grid in the square
    of size 2 centered at the origin and coloring each pixel according to which of
    the four roots the corresponding point converges (black if no convergence after
    100 iterations).'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**牛顿法的混沌**。多项式*f*(*z*) = *z*⁴ - 1有四个根：1，-1，*i*和-*i*。我们可以在复平面上使用牛顿法找到这些根：*z*[*k*+1]
    = *z*[*k*] - *f*(*z*[*k*])/*f*''(*z*[*k*])。这里，*f*(*z*) = *z*⁴ - 1，*f*''(*z*) =
    4*z*³。该方法收敛到四个根中的一个，取决于起始点*z*[0]。编写一个名为`Newton`的`Complex`客户端（如[complex.py](complex.py.html)中定义的），它接受一个命令行参数*n*，通过将像素映射到以原点为中心、大小为2的正方形中的复平面上的复点，并根据相应点收敛到哪个四个根（如果100次迭代后没有收敛则为黑色）将*n*乘以*n*的`Picture`像素涂成白色、红色、绿色或蓝色。'
- en: '![Newton''s method](../Images/ec3feffd5e482693d5930ed0c48a7533.png)'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![牛顿法](../Images/ec3feffd5e482693d5930ed0c48a7533.png)'
- en: '**Equipotential surfaces**. An *equipotential surface* is the set of all points
    that have the same electric potential V. Given a group of point charges, it is
    useful to visualize the electric potential by plotting equipotential surfaces
    (also known as a *contour plot*). Compose a program `equipotential.py` that draws
    a line every 5V by computing the potential at each pixel and checking whether
    the potential at the corresponding point is within 1 pixel of a multiple of 5V.
    *Note*: A very easy approximate solution to this exercise is obtained from [potential.py](../31datatype/potential.py.html)
    (from Section 3.1) by scrambling the color values assigned to each pixel, rather
    than having them be proportional to the grayscale value. For example, the accompanying
    figures are created by inserting the code above it before creating the `Color`.
    Explain why it works, and experiment with your own version.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等势面**。*等势面*是所有具有相同电势V的点的集合。给定一组点电荷，通过绘制等势面（也称为*等势线图*）来可视化电势是很有用的。编写一个名为`equipotential.py`的程序，通过计算每个像素点的电势并检查相应点的电势是否在5V的倍数的1像素范围内来绘制每5V一条线。*注意*：通过将分配给每个像素的颜色值混合，而不是让它们与灰度值成比例，可以很容易地近似解决这个练习，具体方法请参考[这里](../31datatype/potential.py.html)（来自第3.1节）。例如，通过在创建`Color`之前插入上面的代码，可以创建附带的图像。解释为什么它有效，并尝试使用自己的版本进行实验。'
- en: '| ![Electric equipotential](../Images/0b2f602b44ff1e750769b3fa8e8b6df2.png)
    | ![Electric equipotential](../Images/2e32f544cc3e952520ef3f5626531f12.png) |'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![电势等势面](../Images/0b2f602b44ff1e750769b3fa8e8b6df2.png) | ![电势等势面](../Images/2e32f544cc3e952520ef3f5626531f12.png)
    |'
- en: '**Color Mandelbrot plot**. Create a file of 256 integer triples that represent
    interesting `Color` values, and then use those colors instead of grayscale values
    to plot each pixel in [mandelbrot.py](mandelbrot.py.html). Read the values to
    create an array of 256 `Color` values, then index into that array with the return
    value of `mandel()`. By experimenting with various color choices at various places
    in the set, you can produce astonishing images. [mandel.txt](mandel.txt) is an
    example.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**彩色曼德博图**。创建一个包含256个整数三元组的文件，表示有趣的`Color`值，然后使用这些颜色而不是灰度值来绘制[mandelbrot.py](mandelbrot.py.html)中的每个像素。读取值以创建一个包含256个`Color`值的数组，然后使用`mandel()`的返回值索引到该数组。通过在集合的各个位置尝试不同的颜色选择，可以产生令人惊叹的图像。[mandel.txt](mandel.txt)是一个示例。'
- en: '| `% python mandelbrot.py -1.5 -1.0 2.0 2.0` | `% python mandelbrot.py 0.10259
    -0.641 0.0086 0.0086` |'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python mandelbrot.py -1.5 -1.0 2.0 2.0` | `% python mandelbrot.py 0.10259
    -0.641 0.0086 0.0086` |'
- en: '| ![Mandelbrot set](../Images/e7918925eac7307d377a50e13ebecd29.png) | ![Mandelbrot
    set](../Images/48678556c5d0971990a132ea73af293b.png) |'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![曼德博集](../Images/e7918925eac7307d377a50e13ebecd29.png) | ![曼德博集](../Images/48678556c5d0971990a132ea73af293b.png)
    |'
- en: '**Julia sets**. The *Julia set* for a given complex number *c* is a set of
    points related to the Mandelbrot function. Instead of fixing *z* and varying *c*,
    we fix *c* and vary *z*. Those points *z* for which the modified Mandelbrot function
    stays bounded are in the Julia set; those for which the sequence diverges to infinity
    are not in the set. All points *z* of interest lie in the 4-by-4 box centered
    at the origin. The Julia set for *c* is connected if and only if *c* is in the
    Mandelbrot set! Compose a program `colorjulia.py` that takes two command line
    arguments *a* and *b*, and plots a color version of the Julia set for *c* = *a*
    + *bi*, using the color-table method described in the previous exercise.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**茱莉亚集**。对于给定的复数*c*，*茱莉亚集*是与曼德博函数相关的一组点。我们不��固定*z*而变化*c*，而是固定*c*而变化*z*。那些使修改后的曼德博函数保持有界的点属于茱莉亚集；那些使序列发散到无穷大的点不属于该集合。所有感兴趣的点*z*都位于以原点为中心的4乘4的方框内。对于*c*的茱莉亚集是连通的，当且仅当*c*在曼德博集中时！编写一个名为`colorjulia.py`的程序，它接受两个命令行参数*a*和*b*，并使用前面练习中描述的颜色表方法为*c*
    = *a* + *bi*绘制一个彩色版本的茱莉亚集。'
- en: '| `python colorjulia.py -1.25 0.00` | `python colorjulia.py-0.75 0.10` |'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| `python colorjulia.py -1.25 0.00` | `python colorjulia.py-0.75 0.10` |'
- en: '| ![Julia set](../Images/ce7a90970e8b6a5cc872a0efa1d10bf2.png) | ![Julia set](../Images/0b9e0d3e17b67c2e33d17fdfaa24a0be.png)
    |'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![茱莉亚集](../Images/ce7a90970e8b6a5cc872a0efa1d10bf2.png) | ![茱莉亚集](../Images/0b9e0d3e17b67c2e33d17fdfaa24a0be.png)
    |'
- en: '**Biggest winner and biggest loser**. Compose a client of `StockAccount` (as
    defined in [stockaccount.py](stockaccount.py.html)) that builds an array of `StockAccount`
    objects, computes the total value of each account, and writes a report for the
    account with the largest value and the account with the smallest value. Assume
    that the information in the accounts are kept in a single file that contains the
    information for each of the accounts, one after the other, in the format given
    described earlier in this page.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大赢家和最大输家**。编写一个`StockAccount`的客户端（如在[stockaccount.py](stockaccount.py.html)中定义），该客户端构建一个`StockAccount`对象数组，计算每个账户的总价值，并为价值最大和最小的账户编写报告。假设账户信息保存在一个文件中，该文件依次包含每个账户的信息，格式如本页前面描述的那样。'
