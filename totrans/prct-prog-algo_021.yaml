- en: 4.2   Sorting and Searching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2   排序和搜索
- en: 原文：[https://introcs.cs.princeton.edu/java/42sort](https://introcs.cs.princeton.edu/java/42sort)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/42sort](https://introcs.cs.princeton.edu/java/42sort)
- en: The sorting problem is to rearrange an array of items in ascending order. In
    this section, we will consider in detail two classical algorithms for sorting
    and searching—binary search and mergesort—along with several applications where
    their efficiency plays a critical role.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 排序问题是将一个数组中的项按升序重新排列。在本节中，我们将详细讨论两种经典的排序和搜索算法——二分搜索和归并排序——以及它们的效率在多个关键应用中发挥的作用。
- en: '![Twenty questions](../Images/948eb22e3e1438d4996a99d0fc146a32.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![二十个问题](../Images/948eb22e3e1438d4996a99d0fc146a32.png)'
- en: Binary search.
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分搜索。
- en: In the game of "twenty questions", your task is to guess the value of a secret
    number that is one of the *n* integers between 0 and *n*−1\. For simplicity, we
    will assume that *n* is a power of 2 and that the questions are of the form "is
    the number greater than or equal to *x*?"
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在“二十个问题”的游戏中，你的任务是猜测一个秘密数字，该数字是0到*n*−1之间的一个整数。为简单起见，我们假设*n*是2的幂，并且问题的形式是“数字是否大于或等于*x*？”
- en: An effective strategy is to maintain an interval that contains the secret number,
    guess the number in the middle of the interval, and then use the answer to halve
    the interval size. [Questions.java](Questions.java.html) implements this strategy.
    It is an example of the general problem-solving method known as *binary search*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的策略是维护一个包含秘密数字的区间，猜测区间中间的数字，然后使用答案将区间大小减半。[Questions.java](Questions.java.html)实现了这种策略。这是一个被称为*二分搜索*的一般问题解决方法的示例。
- en: '*Analysis of running time.* Since the size of the interval decreases by a factor
    of 2 at each iteration (and the base case is reached when *n* = 1), the running
    time of binary search is lg *n*.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时间分析*。由于每次迭代间隔的大小减少了2倍（当*n* = 1时达到基本情况），二分搜索的运行时间是lg *n*。'
- en: '*Linear–logarithm chasm.* The alternative to using binary search is to guess
    0, then 1, then 2, then 3, and so forth, until hitting the secret number. We refer
    to such an algorithm as a *brute-force* algorithm: it seems to get the job done,
    but without much regard to the cost (which might prevent it from actually getting
    the job done for large problems). In the worst case, the running time can be as
    much as *n*.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线性对数鸿沟*。使用二分搜索的替代方法是猜测0，然后1，然后2，然后3，依此类推，直到找到秘密数字。我们将这样的算法称为*蛮力*算法：它似乎可以完成任务，但并不太关心成本（这可能会阻止它实际完成大问题的任务）。在最坏情况下，运行时间可能高达*n*。'
- en: '*Binary representation.* If you look back to [Binary.java](../13flow/Binary.java.html),
    you will recognize that binary search is nearly the same computation as converting
    a number to binary! Each guess determines one bit of the answer. For example,
    if the number is 77, the sequence of answers no yes yes no no yes no immediately
    yields 1001101, the binary representation of 77\.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二进制表示*。如果回顾一下[Binary.java](../13flow/Binary.java.html)，您会发现二分搜索几乎与将数字转换为二进制的计算相同！每次猜测确定答案的一个位。例如，如果数字是77，则立即得到答案序列no
    yes yes no no yes no，这是77的二进制表示。'
- en: '![Bisection search](../Images/85f81e045faa537355f64c3a6034cf97.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![二分搜索](../Images/85f81e045faa537355f64c3a6034cf97.png)'
- en: '*Inverting an increasing function f(x).* Given a value *y*, our task is to
    find a value *x* such that *f*(*x*) = *y*. We start with an interval (*lo*, *hi*)
    known to contain *x* and use the following recursive strategy:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*反转递增函数f(x)*。给定一个值*y*，我们的任务是找到一个值*x*，使得*f*(*x*) = *y*。我们从一个已知包含*x*的区间(*lo*,
    *hi*)开始，并使用以下递归策略：'
- en: Compute *mid* = *lo* + (*hi* − *lo*) / 2
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算*mid* = *lo* + (*hi* − *lo*) / 2
- en: 'Base case: If (*hi* − *lo*) is less than δ, then return *mid* as an estimate
    of *x*'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况：如果(*hi* − *lo*)小于δ，则将*mid*作为*x*的估计返回
- en: 'Recursive step: otherwise, test whether *f*(*mid*) > *y*. If so, look for *x*
    in (*lo*, *mid*); if not look for *x* in (*mid*, *hi*).'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归步骤：否则，测试*f*(*mid*) > *y*。如果是，就在(*lo*, *mid*)中寻找*x*；如果不是，则在(*mid*, *hi*)中寻找*x*。
- en: The `inverseCDF()` method in [Gaussian.java](../22library/Gaussian.java.html)
    implements this strategy for the Gaussian cumulative density function Φ. In this
    context, binary search is often called *bisection search*.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Gaussian.java](../22library/Gaussian.java.html)中的`inverseCDF()`方法实现了这种策略，用于高斯累积密度函数Φ。在这种情况下，二分搜索通常被称为*二分搜索*。'
- en: '![Binary search in a sorted array](../Images/06533ff45ca9b401b60ba904e35f271e.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![有序数组中的二分搜索](../Images/06533ff45ca9b401b60ba904e35f271e.png)'
- en: '*Binary search in a sorted array.* One of the most important uses of binary
    search is to find an item in a sorted array. To do so, look at the array element
    in the middle. If it contains the item you are seeking, you are done; otherwise,
    you eliminate either the subarray before or after the middle element from consideration
    and repeat. [BinarySearch.java](BinarySearch.java.html) is an implementation of
    this algorithm.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有序数组中的二分搜索*。二分搜索最重要的用途之一是在有序数组中查找一个项。要做到这一点，查看中间的数组元素。如果包含您正在寻找的项，则完成；否则，从考虑中消除中间元素之前或之后的子数组，并重复。[BinarySearch.java](BinarySearch.java.html)是这种算法的一个实现。'
- en: Insertion sort.
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入排序。
- en: 'Insertion sort is a brute-force sorting algorithm that is based on a simple
    method that people often use to arrange hands of playing cards: Consider the cards
    one at a time and insert each into its proper place among those already considered
    (keeping them sorted). The following code mimics this process in a Java method
    that sorts strings in an array:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序是一种基于人们经常用来整理扑克牌的简单方法的蛮力排序算法：逐个考虑卡片并将每张卡片插入到已考虑的卡片中的适当位置（保持它们排序）。以下代码在一个Java方法中模拟了这个过程，用于对数组中的字符串进行排序：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At the beginning of each iteration of the outer `for` loop, the first `i` elements
    in the array are in sorted order; the inner for loop moves `a[i]` into its proper
    position in the array by exchanging it with each large value to its left, moving
    from right to left, until it reaches its proper position. Here is an example when
    `i` is `6`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部`for`循环的每次迭代开始时，数组中的前`i`个元素是按顺序排列的；内部循环通过将`a[i]`与其左侧的每个较大值交换，从右向左移动，直到达到其正确位置，将其移动到数组中的正确位置。这是`i`为`6`时的一个例子：
- en: '![Insertion sort iteration](../Images/c10f35f7a2db838bccc4a8953b9d58fa.png)'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![插入排序迭代](../Images/c10f35f7a2db838bccc4a8953b9d58fa.png)'
- en: This process es executed first with `i` equal to `1`, then `2`, then `3`, and
    so forth, as illustrated in the following trace.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程首先执行`i`等于`1`，然后`2`，然后`3`，依此类推，如下面的跟踪所示。
- en: '![Insertion sort trace](../Images/bdcdd266d798c0a8e96d6bcc9430f391.png)'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![插入排序跟踪](../Images/bdcdd266d798c0a8e96d6bcc9430f391.png)'
- en: '*Analysis of running time.* The inner loop of the insertion sort code is within
    a double nested `for` loop, which suggests that the running time is quadratic,
    but we cannot immediately draw this conclusion because of the `break`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时间分析*。插入排序代码的内部循环位于双重嵌套的`for`循环中，这表明运行时间是二次的，但由于`break`的存在，我们不能立即得出这个结论。'
- en: '*Best case.* When the input array is already in sorted order, the total number
    of compares in ~ *n* and the running time is linear.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳情况*。当输入数组已经按排序顺序排列时，总比较次数约为*n*，运行时间为线性。'
- en: '*Worst case.* When the input is reverse sorted, the number of compares is ~
    1/2 *n*² and the running time is quadratic.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最坏情况*。当输入是逆序排序时，比较次数约为~ 1/2 *n*²，运行时间为二次。'
- en: '*Average case.* When the input is *randomly* ordered, the expected number of
    compares is ~ 1/4 *n*² and the running time is quadratic.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平均情况*。当输入是*随机*排序时，预期的比较次数约为~ 1/4 *n*²，运行时间为二次。'
- en: '*Sorting other types of data.* We want to be able to sort all types of data,
    not just strings. For sorting objects in an array, we need only assume that we
    can compare two elements to see whether the first is bigger than, smaller than,
    or equal to the second. Java provides the [Comparable](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)
    interface for this purpose. [Insertion.java](Insertion.java.html) implements insertion
    sort so that it sorts arrays of `Comparable` objects.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对其他类型数据进行排序*。我们希望能够对所有类型的数据进行排序，而不仅仅是字符串。对于对数组中的对象���行排序，我们只需要假设我们可以比较两个元素，以查看第一个元素是大于、小于还是等于第二个元素。Java为此提供了[Comparable](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)接口。[Insertion.java](Insertion.java.html)实现了插入排序，以便对`Comparable`对象的数组进行排序。'
- en: '*Empirical analysis.* [InsertionTest.java](InsertionTest.java.html) tests our
    hypothesis that insertion sort is quadratic for randomly-ordered arrays.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*经验分析*。[InsertionTest.java](InsertionTest.java.html)测试了我们关于插入排序对于随机排序数组是二次的假设。'
- en: Mergesort.
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归并排序。
- en: 'To develop a faster sorting method, we use a *divide-and-conquer* approach
    to algorithm design that every programmer needs to understand. To *mergesort*
    an array, we divide it into two halves, sort the two halves independently, and
    then merge the results to sort the full array. To sort `a[lo, hi)`, we use the
    following recursive strategy:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发更快的排序方法，我们使用*分而治之*的算法设计方法，每个程序员都需要理解。为了*归并排序*一个数组，我们将其分成两半，独立地对这两半进行排序，然后合并结果以对整个数组进行排序。为了对`a[lo,
    hi)`进行排序，我们使用以下递归策略：
- en: '*Base case*: If the subarray length is 0 or 1, it is already sorted.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本情况*：如果子数组长度为0或1，则已经排序。'
- en: '*Reduction step*: Otherwise, compute `mid = lo + (hi - lo) / 2`, recursively
    sort the two subarrays `a[lo, mid)` and `a[mid, hi)`, and merge them to produce
    a sorted result.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*归约步骤*：否则，计算`mid = lo + (hi - lo) / 2`，递归地对两个子数组`a[lo, mid)`和`a[mid, hi)`进行排序，并将它们合并以产生排序结果。'
- en: '![Mergesort](../Images/c0e1b9ddffd05330c91af469ef3655d7.png)'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![归并排序](../Images/c0e1b9ddffd05330c91af469ef3655d7.png)'
- en: '[Merge.java](Merge.java.html) is an implementation of this strategy. Here is
    a trace of the contents of the array during a merge.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[Merge.java](Merge.java.html)是这种策略的实现。这里是在合并过程中数组内容的跟踪。'
- en: '![Trace of merging in mergesort](../Images/44c45bec5bd1dd0c41450bffaf3ebde8.png)'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![归并排序中合并的跟踪](../Images/44c45bec5bd1dd0c41450bffaf3ebde8.png)'
- en: '*Analysis of running time.* In the worst case, mergesort makes between ~ 1/2
    *n* lg *n* and ~ *n* lg *n* compares and the running time is linearithmic. See
    the book for for details.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时间分析*。在最坏情况下，归并排序进行了约~ 1/2 *n* lg *n*到~ *n* lg *n*次比较，运行时间是线性对数的。有关详细信息，请参阅本书。'
- en: '*Quadratic–linearithmic chasm.* The difference between *n*² and *n* lg *n*
    makes a huge difference in practical applications.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二次-线性对数裂缝*。*n*²和*n* lg *n*之间的差异在实际应用中产生了巨大的影响。'
- en: '*Divide-and-conquer algorithms.* The same basic approach is effective for many
    important problems, as you will learn if you take a course on algorithm design.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分而治之算法*。对于许多重要问题，相同的基本方法都是有效的，如果您学习算法设计课程，您将了解到这一点。'
- en: '*Reduction to sorting.* A problem *A* *reduces* to a problem *B* if we can
    use a solution to *B* to solve *A*. For example, consider the problem of determining
    whether the elements in an array are all different. This problem reduces to sorting
    because we can sort the array, the make a linear pass through the sorted array
    to check whether any entry is equal to the next (if not, the elements are all
    different.)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*归约到排序*。问题*A* *归约*到问题*B*，如果我们可以使用问题*B*的解决方案来解决问题*A*。例如，考虑确定数组中的元素是否都不同的问题。这个问题归约到排序，因为我们可以对数组进行排序，然后通过排序后的数组进行线性遍历，检查任何条目是否等于下一个条目（如果不是，则元素都不同）。'
- en: Frequency counts.
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 频率计数。
- en: '[FrequencyCount.java](FrequencyCount.java.html) reads a sequence of strings
    from standard input and then prints a table of the distinct values found and the
    number of times each was found, in decreasing order of the frequencies. We accomplish
    this by two sorts.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[FrequencyCount.java](FrequencyCount.java.html)从标准输入读取一系列字符串，然后按照频率降序打印找到的不同值的表以及每个值被找到的次数。我们通过两次排序来实现这一点。'
- en: '*Computing the frequencies.* Our first step is to sort the strings on standard
    input. In this case, we are not so much interested in the fact that the strings
    are put into sorted order, but in the fact that sorting brings equal strings together.
    If the input is'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*计算频率。* 我们的第一步是对标准输入中的字符串进行排序。在这种情况下，我们不太关心字符串被排序，而是关心排序将相同的字符串放在一起。如果输入是'
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: then the result of the sort is
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后排序的结果是
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: with equal strings like the three occurrences of `to` brought together in the
    array. Now, with equal strings all together in the array, we can make a single
    pass through the array to compute all the frequencies. The [Counter.java](Counter.java.html)
    data type that we considered in Section 3.3 is the perfect tool for the job.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像数组中的三个`to`出现次数相同的字符串一样放在一起。现在，将所有相同的字符串放在数组中，我们可以通过数组进行一次遍历来计算所有的频率。我们在第3.3节中考虑过的[Counter.java](Counter.java.html)数据类型是这项工作的完美工具。
- en: '*Sorting the frequencies.* Next, we sort the `Counter` objects. We can do so
    in client code without any special arrangements because `Counter` implements the
    `Comparable` interface.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排序频率。* 接下来，我们对`Counter`对象进行排序。我们可以在客户端代码中这样做，无需任何特殊安排，因为`Counter`实现了`Comparable`接口。'
- en: '*Zipf''s law.* The application highlighted in [FrequencyCount.java](FrequencyCount.java.html)
    is elementary linguistic analysis: which words appear most frequently in a text?
    A phenomenon known as [Zipf''s law](http://en.wikipedia.org/wiki/Zipf''s_law)
    says that the frequency of the *i*th most frequent word in a text of *m* distinct
    words is proportional to 1/*i*.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*齐夫定律。* [FrequencyCount.java](FrequencyCount.java.html)中突出显示的应用是基本的语言分析：文本中哪些单词出现频率最高？一种称为[齐夫定律](http://en.wikipedia.org/wiki/Zipf''s_law)的现象表明，文本中第*i*个最常见单词的频率与*m*个不同单词的文本成反比。'
- en: Exercises
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Write a filter [Dedup.java](Dedup.java.html) that reads strings from standard
    input and prints them on standard output with all duplicates removed (in sorted
    order).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个过滤器[Dedup.java](Dedup.java.html)，从标准输入读取字符串，并打印删除所有重复项的字符串（按排序顺序）到标准输出。
- en: Creative Exercises
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '*This list of exercises is intended to give you experience in developing fast
    solutions to typical problems. Think about using binary search, mergesort, or
    devising your own divide-and-conquer algorithm. Implement and test your algorithm.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些练习旨在让您体验开发快速解决方案常见问题的经验。考虑使用二分查找、归并排序��设计自己的分治算法。实现并测试您的算法。*'
- en: '**Integer sort.** Write a *linear-time* filter [IntegerSort.java](IntegerSort.java.html)
    that reads from standard input a sequence of integers that are between 0 and 99
    and prints to standard output the same integers in sorted order. For example,
    presented with the input sequence'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**整数排序。** 编写一个*线性时间*过滤器[IntegerSort.java](IntegerSort.java.html)，从标准输入读取介于0和99之间的整数序列，并按排序顺序将相同的整数打印到标准输出。例如，给定输入序列'
- en: '[PRE3]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: your program should print the output sequence
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的程序应该打印输出序列
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Three sum.** Given an array of *n* integers, design an algorithm to determine
    whether any three of them sum to 0. The order of growth of the running time of
    your program should be *n*² log *n*. *Extra credit*: Develop a program that solves
    the problem in quadratic time.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**三数之和。** 给定一个包含*n*个整数的数组，设计一个算法来确定其中任意三个数是否和为0。程序的运行时间增长率应为*n*² log *n*。*额外加分*：开发一个能在二次时间内解决问题的程序。'
- en: '*Solution*: [ThreeSumDeluxe.java](ThreeSumDeluxe.java.html).'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：[ThreeSumDeluxe.java](ThreeSumDeluxe.java.html)。'
- en: '**Quicksort.** Write a recursive program [Quick.java](Quick.java.html) that
    sorts an array of `Comparable` objects by by using, as a subroutine, the partitioning
    algorithm described in the previous exercise: First, pick a random element v as
    the partitioning element. Next, partition the array into a left subarray containing
    all elements less than v, followed by a middle subarray containing all elements
    equal to v, followed by a right subarray containing all elements greater than
    v. Finally, recursively sort the left and right subarrays.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**快速排序。** 编写一个递归程序[Quick.java](Quick.java.html)，通过使用前面练习中描述的分区算法作为子程序，对包含`Comparable`对象的数组进行排序：首先，选择一个随机元素v作为分区元素。接下来，将数组分成一个包含所有小于v的元素的左子数组，一个包含所有等于v的元素的中间子数组，一个包含所有大于v的元素的右子数组。最后，递归地对左右子数组进行排序。'
- en: '**Reverse domain.** Write a program to read in a list of domain names from
    standard input, and print the reverse domain names in sorted order. For example,
    the reverse domain of `cs.princeton.edu` is `edu.princeton.cs`. This computation
    is useful for web log analysis. To do so, create a data type [Domain.java](Domain.java.html)
    that implements the `Comparable` interface, using reverse domain name order.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反向域。** 编写一个程序从标准输入中读取域名列表，并按排序顺序打印反向域名。例如，`cs.princeton.edu`的反向域是`edu.princeton.cs`。这种计算对于网络日志分析很有用。为此，创建一个实现`Comparable`接口的数据类型[Domain.java](Domain.java.html)，使用反向域名顺序。'
- en: '**Local minimum in an array.** Given an array `a[]` of `n` real numbers, design
    a logarithmic-time algorithm to find a *local minimum* (an index i such that both
    `a[i-1] < a[i]` and `a[i] < a[i+1]`).'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数组中的局部最小值。** 给定一个包含`n`个实数的数组`a[]`，设计一个对数时间算法来找到一个*局部最小值*（一个索引i，使得`a[i-1]
    < a[i]`且`a[i] < a[i+1]`）。'
- en: '*Solution*: Query middle value a[n/2], and two neighbors a[n/2 - 1] and a[n/2
    + 1]. If a[n/2] is local minimum, stop; otherwise search in half with smaller
    neighbor.'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：查询中间值a[n/2]，以及两个邻居a[n/2 - 1]和a[n/2 + 1]。如果a[n/2]是局部最小值，则停止；否则���较小邻居的一半中搜索。'
- en: Web Exercises
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习
- en: '**Union of intervals.** Given N intervals on the real line, determine the length
    of their union in O(N log N) time. For example the union of the four intervals
    [1, 3], [2, 4.5], [6, 9], and [7, 8] is 6.5.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**区间的并集。** 给定实数线上的N个区间，在O(N log N)的时间内确定它们的并集长度。例如，四个区间[1, 3]，[2, 4.5]，[6,
    9]和[7, 8]的并集为6.5。'
- en: '**Coffee can problem.** (David Gries). Suppose you have a coffee can which
    contains an unknown number of black beans and an unknown number of white beans.
    Repeat the following process until exactly one bean remains: Select two beans
    from the can at random. If they are both the same color, throw them both out,
    but insert another black bean. If they are different colors, throw the black one
    away, but return the white one. Prove that this process terminates with exactly
    one bean left. What can you deduce about the color of the last bean as a function
    of the initial number of black and white beans? *Hint*: find a useful invariant
    maintained by the process.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**咖啡罐问题。** （大卫·格里斯）。假设你有一个咖啡罐，里面装有未知数量的黑豆和未知数量的白豆。重复以下过程，直到只剩下一颗豆：随机从罐中选取两颗豆。如果它们颜色相同，将它们都丢掉，但插入另一颗黑豆。如果它们颜色不同，扔掉黑色的那颗，但返回白色的那颗。证明这个过程以恰好一颗豆结束。根据初始黑白豆数量，你能推断出最后一颗豆的颜色吗？*提示*：找到一个过程中保持不变的有用不变量。'
- en: '**Spam campaign.** To initiate an illegal spam campaign, you have a list of
    email addresses from various domains (the part of the email address that follows
    the @ symbol). To better forge the return addresses, you want to send the email
    from another user at the same domain. For example, you might want to forge an
    email from nobody@princeton.edu to somebody@princeton.edu. How would you process
    the email list to make this an efficient task?'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垃圾邮件活动。** 为了发起非法的垃圾邮件活动，你有一个来自各种域的电子邮件地址列表（电子邮件地址中@符号后面的部分）。为了更好地伪造返回地址，你想从同一域的另一个用户发送电子邮件。例如，你可能想伪造一个从nobody@princeton.edu发送到somebody@princeton.edu的电子邮件。你如何处理电子邮件列表以使这成为一个高效的任务？'
- en: '**Order statistics.** Given an array of N elements, not necessarily in ascending
    order, devised an algorithm to find the kth largest one. It should run in O(N)
    time on random inputs.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顺序统计。** 给定一个包含N个元素的数组，不一定按升序排列，设计一个算法来找到第k个最大的元素。它应该在随机输入上以O(N)时间运行。'
- en: '**Kendall''s tau distance.** Given two permutations, Kendall''s tau distance
    is the number of pairs out of position. "Bubblesort metric." Give an O(N log N)
    algorithm to compute the Kendall tau distance between two permutations of size
    N. Useful in top-k lists, social choice and voting theory, comparing genes using
    expression profiles, and [ranking search engine results](http://www10.org/cdrom/papers/577/).'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**肯德尔tau距离。** 给定两个排列，肯德尔tau距离是位置不正确的对数。"冒泡排序度量"。给出一个O(N log N)算法，计算大小为N的两个排列之间的肯德尔tau距离。在前k个列表、社会选择和投票理论、使用表达谱比较基因以及[排名搜索引擎结果](http://www10.org/cdrom/papers/577/)方面很有用。'
- en: '**Antipodal points.** Given N points on a circle, centered at the origin, design
    an algorithm that determines whether there are two points that are *antipodal*,
    i.e., the line connecting the two points goes through the origin. Your algorithm
    should run in time proportional to N log N.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对脚点。** 给定圆上N个点，以原点为中心，设计一个算法来确定是否存在两个*对脚*点，即连接这两个点的直线经过原点。你的算法应该在时间上与N log
    N成正比。'
- en: '**Antipodal points.** Repeat the previous question, but assume the points are
    given in clockwise order. Your algorithm should run in time proportional to N.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对脚点。** 重复上一个问题，但假设点是按顺时针顺序给出的。你的算法应该在时间上与N成正比。'
- en: '**Identity.** Given an array `a[]` of *N* distinct integers (positive or negative)
    in ascending order. Devise an algorithm to find an index `i` such that `a[i] =
    i` if such an index exists. Hint: binary search.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**身份。** 给定一个按升序排列的包含*N*个不同整数（正数或负数）的数组`a[]`。设计一个算法，找到一个索引`i`，使得`a[i] = i`如果这样的索引存在。提示：二分查找。'
- en: '**L1 norm.** There are N circuit elements in the plane. You need to run a special
    wire (parallel to the x-axis) across the circuit. Each circuit element must be
    connected to the special wire. Where should you put the special wire? *Hint*:
    median minimizes L1 norm.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**L1范数。** 平面上有N个电路元件。你需要沿电路运行一根特殊的线（与x轴平行）。每个电路元件必须连接到特殊的线。你应该把特殊的线放在哪里？*提示*：中位数最小化L1范数。'
- en: '**Finding common elements.** Given two arrays of N 64-bit integers, design
    an algorithm to print out all elements that appear in both lists. The output should
    be in sorted order. Your algorithm should run in N log N. *Hint*: mergesort, mergesort,
    merge. *Remark*: not possible to do better than N log N in comparison based model.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找共同元素。** 给定两个包含N个64位整数的数组，设计一个算法来打印出两个列表中出现的所有元素。输出应按排序顺序排列。你的算法应该在N log
    N时间内运行。*提示*：归并排序，归并排序，合并。*备注*：在比较基础模型中，不可能做得比N log N更好。'
- en: '**Finding common elements.** Repeat the above exercise but assume the first
    array has M integers and the second has N integers where M is much less than N.
    Give an algorithm that runs in N log M time. *Hint*: sort and binary search.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找共同元素。** 重复上述练习，但假设第一个数组有M个整数，第二个数组有N个整数，其��M远小于N。给出一个在N log M时间内运行的算法。*提示*：排序和二分查找。'
- en: '**Anagrams.** Design a O(N log N) algorithm to read in a list of words and
    print out all anagrams. For example, the strings "comedian" and "demoniac" are
    anagrams of each other. Assume there are N words and each word contains at most
    20 letters. Designing a O(N^2) algorithms should not be too difficult, but getting
    it down to O(N log N) requires some cleverness.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字谜。** 设计一个O(N log N)算法来读取一个单词列表并打印出所有字谜。例如，字符串"comedian"和"demoniac"是彼此的字谜。假设有N个单词，每个单词最多包含20个字母。设计一个O(N^2)算法应该不太困难，但将其降至O(N
    log N)需要一些巧妙的方法。'
- en: '**Pattern recognition.** Given a list of N points in the plane, find all subset
    of 3 or more [points that are collinear](http://www.cs.princeton.edu/courses/archive/spring03/cs226/assignments/lines.html).'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模式识别。** 给定平面上的N个点列表，找到所有包含3个或更多[共线点](http://www.cs.princeton.edu/courses/archive/spring03/cs226/assignments/lines.html)的子集。'
- en: '**Pattern recognition.** Given a list of N points in the plane in general position
    (no three are collinear), find a new point p that is not collinear with any pair
    of the N original points.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模式识别。** 给定平面上N个点的列表，这些点一般位置（没有三个共线），找到一个新点p，它与N个原始点的任意一对都不共线。'
- en: '**Search in a sorted, rotated list.** Given a sorted list of N integers that
    has been rotated an unknown number of positions, e.g., 15 36 1 7 12 13 14, design
    an O(log N) algorithm to determine if a given integer is in the list.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在排序、旋转列表中搜索。** 给定一个已经旋转了未知次数的 N 个整数的排序列表，例如，15 36 1 7 12 13 14，设计一个 O(log
    N) 的算法来确定给定整数是否在列表中。'
- en: '**Counting inversions.** Each user ranks N songs in order of preference. Given
    a preference list, find the user with the *closest* preferences. Measure "closest"
    according to the number of inversions. Devise an N log N algorithm for the problem.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算逆序数。** 每个用户按偏好顺序对 N 首歌曲进行排名。给定一个偏好列表，找到偏好最接近的用户。根据逆序数计算“最接近”。为该问题设计一个 N
    log N 算法。'
- en: '**Throwing cats from an N-story building.** Suppose that you have an N story
    building and a bunch of cats. Suppose also that a cat dies if it is thrown off
    floor F or higher, and lives otherwise. Devise a strategy to determine the floor
    F, while killing O(log N) cats.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从 N 层楼扔猫。** 假设您有一个 N 层楼房和一群猫。假设一只猫被扔到 F 楼或更高处时会死亡，否则会存活。制定一种策略来确定楼层 F，同时杀死
    O(log N) 只猫。'
- en: '**Throwing cats from a building.** Repeat the previous exercise, but devise
    a strategy that kills O(log F) cats. *Hint*: repeated doubling and binary search.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从建筑物中扔猫。** 重复上一个练习，但制定一种杀死 O(log F) 只猫的策略。*提示*：重复加倍和二分查找。'
- en: '**Throwing two cats from an N-story building.** Repeat the previous question,
    but now assume you only have two cats. Now your goal is to minimize the number
    of throws. Devise a strategy to determine F that involves throwing cats O(√N)
    times (before killing them both). This application might occur in practice if
    search hits (cat surviving fall) are much cheaper than misses (cat dying).'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从 N 层楼房中扔两只猫。** 重复上一个问题，但现在假设您只有两只猫。现在您的目标是最小化扔猫的次数。制定一种策略，在扔猫 O(√N) 次后确定
    F（在杀死它们之前）。如果搜索命中（猫在摔下后存活）比未命中（猫死亡）便宜得多，则可能会发生这种情况。'
- en: '**Throwing two cats from a building.** Repeat the previous question, but only
    throw O(√F) cats. *Reference*: ???.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从建筑物中扔两只猫。** 重复上一个问题，但只扔 O(√F) 只猫。*参考*：???。'
- en: '**Nearly sorted.** Given an array of N elements, each which is at most k positions
    from its target position, devise an algorithm that sorts in O(N log k) time.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**几乎排序。** 给定一个包含 N 个元素的数组，每个元素最多离其目标位置 k 个位置，设计一个在 O(N log k) 时间内排序的算法。'
- en: '*Solution 1:* divide the file into N/k pieces of size k, and sort each piece
    in O(k log k) time, say using mergesort. Note that this preserves the property
    that no element is more than k elements out of position. Now, merge each blocks
    of k elements with the block to its left.'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案 1：* 将文件分成大小为 k 的 N/k 个片段，并在 O(k log k) 时间内对每个片段进行排序，例如使用归并排序。请注意，这保留了没有元素超出位置
    k 个元素的属性。现在，将每个 k 元素块与其左侧的块合并。'
- en: '*Solution 2:* insert the first k elements into a binary heap. Insert the next
    element from the array into the heap, and delete the minimum element from the
    heap. Repeat.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案 2：* 将前 k 个元素插入二叉堆中。将数组中的下一个元素插入堆中，并删除堆中的最小元素。重复此过程。'
- en: '**Merging k sorted lists.** Suppose you have k sorted lists with a total of
    N elements. Give an O(N log k) algorithm to produce a sorted list of all N elements.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并 k 个排序列表。** 假设您有 k 个排序列表，共有 N 个元素。给出一个 O(N log k) 的算法，以生成所有 N 个元素的排序列表。'
- en: '**Longest common reverse complemented substring.** Given two DNA strings, find
    the longest substring that appears in one, and whose reverse Watson-Crick complement
    appears in the other. Two strings s and t are reverse complements if t is the
    reverse of s except with the following substitutions AT, CG. For example ATTTCGG
    and CCGAAAT are reverse complements of each other. *Hint*: suffix sort.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长公共反向互补子串。** 给定两个 DNA 字符串，找到出现在一个字符串中的最长子串，其反向沃森-克里克互补出现在另一个字符串中。如果两个字符串
    s 和 t 是反向互补的，那么 t 是 s 的反向，除了以下替换 AT，CG。例如 ATTTCGG 和 CCGAAAT 是彼此的反向互补。*提示*：后缀排序。'
- en: '**Circular string linearization.** Plasmids contain DNA in a circular molecule
    instead of a linear one. To facilitate search in a database of DNA strings, we
    need a place to break it up to form a linear string. A natural choice is the place
    that leaves the lexicographically smallest string. Devise an algorithm to compute
    this canonical representation of the circular string *Hint*: suffix sort.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**循环字符串线性化。** 质粒包含 DNA 在一个圆形分子中而不是线性分子中。为了在 DNA 字符串数据库中进行搜索，我们需要一个断开它以形成线性字符串的地方。一个自然的选择是留下字典序最小的地方。设计一个算法来计算圆形字符串的规范表示*提示*：后缀排序。'
- en: '**Find all matches.** Given a text string, find *all* matches of the query
    string. *Hint*: combine suffix sorting and binary search.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找所有匹配项。** 给定一个文本字符串，找到查询字符串的*所有*匹配项。*提示*：结合后缀排序和二分查找。'
- en: '**Longest repeated substring with less memory.** Instead of using an array
    of substrings where suffixes[i] refers to the ith sorted suffix, maintain an array
    of integers so that index[i] refers to the offset of the ith sorted suffix. To
    compare the substrings represented by a = index[i] and b = index[j], compare the
    character `s.charAt(a)` against `s.charAt(b)`, `s.charAt(a+1)` against `s.charAt(b+1)`,
    and so forth. How much memory do you save? Is your program faster?'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具有更少内存的最长重复子串。** 不使用后缀数组，其中 suffixes[i] 指的是第 i 个排序后缀，而是维护一个整数数组，使得 index[i]
    指的是第 i 个排序后缀的偏移量。要比较由 a = index[i] 和 b = index[j] 表示的子串，比较字符 `s.charAt(a)` 与 `s.charAt(b)`，`s.charAt(a+1)`
    与 `s.charAt(b+1)`，依此类推。您节省了多少内存？您的程序更快吗？'
- en: '**Idle time.** Suppose that a parallel machine processes n jobs. Job j is processed
    from s[j] to t[j]. Given the list of start and finish times, find the largest
    interval where the machine is idle. Find the largest interval where the machine
    is non-idle.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**空闲时间。** 假设一个并行机器处理 n 个作业。作业 j 从 s[j] 处理到 t[j]。给定开始和结束时间列表，找到机器空闲的最长时间间隔。找到机器非空闲的最长时间间隔。'
- en: '**Local minimum of a matrix.** Given an N-by-N array `a` of N² distinct integers,
    design an O(N) algorithm to find a *local minimum*: an pair of indices i and j
    such that a[i][j] < a[i+1][j], a[i][j] < a[i][j+1], a[i][j] < a[i-1][j], and a[i][j]
    < a[i][j-1].'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**矩阵的局部最小值。** 给定一个N×N的N²个不同整数的数组`a`，设计一个O(N)算法来找到一个*局部最小值*：一个索引对i和j，使得a[i][j]
    < a[i+1][j]，a[i][j] < a[i][j+1]，a[i][j] < a[i-1][j]，以及a[i][j] < a[i][j-1]。'
- en: '**Monotone 2d array.** Give an n-by-n array of elements such that each row
    is in ascending order and each column is in ascending order, devise an O(n) algorithm
    to determine if a given element x in the array. You may assume all elements in
    the n-by-n array are distinct.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单调二维数组。** 给定一个n×n的元素数组，使得每行按升序排列，每列也按升序排列，设计一个O(n)算法来确定数组中给定元素x。你可以假设n×n数组中的所有元素都是不同的。'
- en: '**2D maxima.** Given a set of n points in the plane, point (xi, yi) dominates
    (xj, yj) if xi > xj and yi > yj. A maxima is a point that is not dominated by
    any other point in the set. Devise an O(n log n) algorithm to find all maxima.
    Application: on x-axis is space efficiency, on y-axis is time efficiency. Maxima
    are useful algorithms. Hint: sort in ascending order according to x-coordinate;
    scan from right to left, recording the highest y-value seen so far, and mark these
    as maxima.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二维极大值。** 给定平面上的一组n个点，点(xi, yi)支配点(xj, yj)如果xi > xj且yi > yj。极大值是一个不被集合中任何其他点支配的点。设计一个O(n
    log n)算法来找到所有极大值。应用：x轴是空间效率，y轴是时间效率。极大值是有用的算法。提示：按照x坐标升序排序；从右到左扫描，记录迄今为止看到的最高y值，并将其标记为极大值。'
- en: '**Compound words.** Read in a list of words from standard input, and print
    out all two-word *compound* words. If `after`, `thought`, and `afterthought` are
    in the list, then `afterthought` is a compound word. Note: the components in the
    compound word need not have the same length.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复合词。** 从标准输入读取一个单词列表，并打印出所有的双词*复合词*。如果列表中包含`after`、`thought`和`afterthought`，那么`afterthought`就是一个复合词。注意：复合词中的组成部分不一定长度相同。'
- en: '**Smith''s rule.** The following problem arises in supply chain management.
    You have a bunch of jobs to schedule on a single machine. (Give example.) Job
    j requires p[j] units of processing time. Job j has a positive weight w[j] which
    represents its relative importance - think of it as the inventory cost of storing
    the raw materials for job j for 1 unit of time. If job j finishes being processed
    at time t, then it costs t * w[j] dollars. The goal is to sequence the jobs so
    as to minimize the sum of the weighted completion times of each job. Write a program
    `SmithsRule.java` that reads in a command line parameter N and a list of N jobs
    specified by their processing time p[j] and their weight w[j], and output an optimal
    sequence in which to process their jobs. *Hint:* Use *Smith''s rule*: schedule
    the jobs in order of their ratio of processing time to weight. This greedy rule
    turns out to be optimal.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**史密斯规则。** 在供应链管理中出现了以下问题。你有一堆工作要在一台机器上安排。（给出示例。）工作j需要p[j]单位的处理时间。工作j有一个表示其相对重要性的正权重w[j]
    - 将其视为存储工作j的原材料成本的单位时间。如果工作j在时间t完成处理，那么它的成本为t * w[j]美元。目标是安排工作的顺序，以使每个工作的加权完成时间之和最小化。编写一个名为`SmithsRule.java`的程序，它读取一个命令行参数N和一个由它们的处理时间p[j]和权重w[j]指定的N个工作列表，并输出一个最佳的处理工作顺序。*提示：*
    使用*史密斯规则*：按照处理时间与权重的比率顺序安排工作。这种贪婪规则被证明是最优的。'
- en: '**Sum of four primes.** The Goldbach conjecture says that all positive even
    integers greater than 2 can be expressed as the sum of two primes. Given an input
    parameter N (odd or even), express N as the sum of four primes (not necessarily
    distinct) or report that it is impossible to do so. To make your algorithm fast
    for large N, do the following steps:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**四个质数之和。** 哥德巴赫猜想说，所有大于2的正偶数都可以表示为两个质数的和。给定一个输入参数N（奇数或偶数），将N表示为四个质数之和（不一定不同），或报告不可能这样做。为了使你的算法对于大的N快速，执行以下步骤：'
- en: Compute all primes less than N using the Sieve of Eratosthenes.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用厄拉托色尼筛法计算小于N的所有质数。
- en: Tabulate a list of sums of two primes.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制表一个两个质数之和的列表。
- en: Sort the list.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对列表进行排序。
- en: Check if there are two numbers in the list that sum to N. If so, print out the
    corresponding four primes.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查列表中是否有两个数字相加等于N。如果是，打印出相应的四个质数。
- en: '**Typing monkeys and power laws.** (Michael Mitzenmacher) Suppose that a [typing
    monkey](http://www.internetmathematics.org/volumes/1/2/pp226_251.pdf) creates
    random words by appending each of 26 possible letter with probability p to the
    current word, and finishes the word with probability 1 - 26p. Write a program
    to estimate the frequency spectrum of the words produced.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打字猴和幂律。** （迈克尔·米岑马赫）假设一个[打字猴](http://www.internetmathematics.org/volumes/1/2/pp226_251.pdf)通过将每个26个可能的字母以概率p附加到当前单词来创建随机单词，并以概率1
    - 26p完成单词。编写一个程序来估计生成的单词的频谱。'
- en: '**Typing monkeys and power laws.** Repeat the previous exercise, but assume
    that the letters a-z occur proportional to the following probabilities, which
    are typical of English text.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打字猴和幂律。** 重复上一个练习，但假设字母a-z出现的概率与以下概率成比例，这是英文文本的典型情况。'
- en: '| CHAR | FREQ |   | CHAR | FREQ |   | CHAR | FREQ |   | CHAR | FREQ |   | CHAR
    | FREQ |'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| CHAR | FREQ |   | CHAR | FREQ |   | CHAR | FREQ |   | CHAR | FREQ |   | CHAR
    | FREQ |'
- en: '| A | 8.04 |  | G | 1.96 |  | L | 4.14 |  | Q | 0.11 |  | V | 0.99 |'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| A | 8.04 |  | G | 1.96 |  | L | 4.14 |  | Q | 0.11 |  | V | 0.99 |'
- en: '| B | 1.54 |  | H | 5.49 |  | M | 2.53 |  | R | 6.12 |  | W | 1.92 |'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| B | 1.54 |  | H | 5.49 |  | M | 2.53 |  | R | 6.12 |  | W | 1.92 |'
- en: '| C | 3.06 |  | I | 7.26 |  | N | 7.09 |  | S | 6.54 |  | X | 0.19 |'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| C | 3.06 |  | I | 7.26 |  | N | 7.09 |  | S | 6.54 |  | X | 0.19 |'
- en: '| D | 3.99 |  | J | 0.16 |  | O | 7.60 |  | T | 9.25 |  | Y | 1.73 |'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| D | 3.99 |  | J | 0.16 |  | O | 7.60 |  | T | 9.25 |  | Y | 1.73 |'
- en: '| E | 12.51 |  | K | 0.67 |  | P | 2.00 |  | U | 2.71 |  | Z | 0.09 |'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| E | 12.51 |  | K | 0.67 |  | P | 2.00 |  | U | 2.71 |  | Z | 0.09 |'
- en: '| F | 2.30 |  |'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| F | 2.30 |  |'
- en: '**Binary search.** Justify why the following modified version of `binarySearch()`
    works. Prove that if the key is in the array, it correctly returns the smallest
    index `i` such that a[i] = key; if the key is not in the array, it returns -i
    where i is the smallest index such that a[i] > key.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二分查找。** 证明以下修改版本的`binarySearch()`为什么有效。证明如果关键字在数组中，则它正确返回最小索引`i`，使得a[i] =
    key；如果关键字不在数组中，则返回-i，其中i是使得a[i] > key的最小索引。'
- en: '[PRE5]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Answer.* The while loop invariant says top >= bot + 2\. This implies bot <
    mid < top. Hence length of interval strictly decreases in each iteration. While
    loop also maintains the invariant: `a[bot] < key <= a[top]`, with the contention
    that `a[-1]` is -infinity and `a[N]` is +infinity.'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案。* while循环不变式表示top >= bot + 2。这意味着bot < mid < top。因此，每次迭代中间隔的长度严格减小。while循环还保持不变式：`a[bot]
    < key <= a[top]`，其中`a[-1]`为负无穷，`a[N]`为正无穷。'
- en: '**Range search.** Given a database of all tolls collected in NJ road system
    in 2006, devise a scheme to answer queries of the form: extract sum of all tolls
    collected in a given time interval. Use a `Toll` data type that implements the
    `Comparable` interface, where the key is the time that the toll was collected.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**范围搜索。** 给定2006年新泽西道路系统中收集的所有通行费的数据库，设计一种方案来回答以下查询形式：提取给定时间间隔内收集的所有通行费的总和。使用一个实现`Comparable`接口的`Toll`数据类型，其中关键是收取通行费的时间。'
- en: '*Hint:* sort by time, compute a cumulative sum of the first i tolls, then use
    binary search to find the desired interval.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：按时间排序，计算前i个通行费的累积和，然后���用二分查找找到所需的间隔。'
- en: '**Longest repeated substrings.** Modify [LRS.java](LRS.java.html) to find *all*
    longest repeated substrings.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长重复子串。** 修改[LRS.java](LRS.java.html)以找到*所有*最长重复子串。'
- en: '**Non-recursive binary search.** Write a non-recursive version of binary search.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非递归二分查找。** 编写二分查找的非递归版本。'
- en: '[PRE6]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Two sum to x.** Given a sorted list of N integers and a target integer x,
    determine in O(N) time whether there are any two that sum to exactly x.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**两数之和为x。** 给定一个排序的N个整数列表和一个目标整数x，在O(N)时间内确定是否有两个数的和恰好为x。'
- en: '*Hint*: maintain an index lo = 0 and hi = N-1 and compute a[lo] + a[hi]. If
    the sum equals x, you are done; if the sum is less than x, decrement hi; if the
    sum is greater than x, increment lo. Be careful if one (or more) of the integers
    are 0.'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：维护索引lo = 0和hi = N-1，并计算a[lo] + a[hi]。如果总和等于x，则完成；如果总和小于x，则减少hi；如果总和大于x，则增加lo。如果一个（或多个）整数为0，请小心。'
- en: '**Zero of a monotonic function.** Let f be a monotonically increasing function
    with f(0) < 0 and f(N) > 0\. Find the smallest integer i such that f(i) > 0. Devise
    an algorithm that makes O(log N) calls to f().'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单调函数的零点。** 让f是一个单调递增函数，其中f(0) < 0且f(N) > 0。找到最小的整数i，使得f(i) > 0。设计一个算法，使其对f()进行O(log
    N)次调用。'
- en: '*Hint*: assuming we know N, marinating an interval [lo, hi] such that f[lo]
    < 0 and f[hi] > 0 and apply binary search. If we don''t know N, repeatedly compute
    f(1), f(2), f(4), f(8), f(16), and so on until you find a value of N such that
    f(N) > 0.'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：假设我们知道N，维护一个区间[lo, hi]，使得f[lo] < 0且f[hi] > 0，并应用二分查找。如果我们不知道N，重复计算f(1)，f(2)，f(4)，f(8)，f(16)等，直到找到一个值N，使得f(N)
    > 0。'
- en: '**Bitonic max.** Let `a[]` be an array that starts out increasing, reaches
    a maximum, and then decreases. Design an O(log N) algorithm to find the index
    of the maximum value.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双峰最大值。** 让`a[]`是一个开始递增，达到最大值，然后减少的数组。设计一个O(log N)算法来找到最大值的索引。'
- en: '**Bitonic search.** An array is *bitonic* if it is comprised of an increasing
    sequence of integers followed immediately by a decreasing sequence of integers.
    Given a bitonic array `a` of N distinct integers, describe how to determine whether
    a given integer is in the array in O(log N) steps. Hint: find the maximum, then
    binary search in each piece.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双峰查找。** 如果一个数组由一个递增的整数序列紧接着一个递减的整数序列组成，则它是*双峰*的。给定一个由N个不同整数组成的双峰数组`a`，描述如何在O(log
    N)步内确定给定整数是否在数组中。提示：找到最大值，然后在每个部分中进行二分查找。'
- en: '**Median in two sorted arrays.** Given two sorted arrays of size N[1] and N[2],
    find the median of all elements in O(log N) time where N = N[1] + N[2]. *Hint*:
    design a more general algorithm that finds the kth largest element for any k.
    Compute the median element in the large of the two lists and; throw away at least
    1/4 of the elements and recur.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**两个排序数组的中位数。** 给定大小为N[1]和N[2]的两个排序数组，以O(log N)时间找到所有元素的中位数，其中N = N[1] + N[2]。*提示*：设计一个更通用的算法，找到任何k的最大元素。计算两个列表中较大的那个列表的中位数元素；丢弃至少1/4的元素并递归。'
- en: '**Element distinctness.** Give an array of N long integers, devise an O(N log
    N) algorithm to determine if any two are equal. *Hint*: sorting brings equal values
    together.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**元素唯一性。** 给定一个包含N个长整数的数组，设计一个O(N log N)算法来确定是否有任何两个相等。*提示*：排序将相等的值放在一起。'
- en: '**Duplicate count.** Give a sorted array of N elements, possibly with duplicates,
    find the index of the first and last occurrence of k in O(log N) time. Give a
    sorted array of N elements, possibly with duplicates, find the number of occurrences
    of element k in O(log N) time. *Hint*: modify binary search.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重复计数。** 给定一个包含N个元素的排序数组，可能包含重复项，在O(log N)时间内找到k的第一次和最后一次出现的索引。给定一个包含N个元素的排序数组，可能包含重复项，在O(log
    N)时间内找到元素k的出现次数。*提示*：修改二分查找。'
- en: '**Common element.** Write a static method that takes as argument three arrays
    of strings, determines whether there is any string common to all three arrays,
    and if so, returns one such string. The running time of your method should be
    linearithmic in the total number of strings.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**公共元素。** 编写一个静态方法，该方法以三个字符串数组作为参数，确定是否有任何字符串同时存在于这三个数组中，并如果有，则返回其中一个字符串。您的方法的运行时间应该是总字符串数量的对数线性。'
- en: '*Hint*: sort each of the three lists, then describe how to do a "3-way" merge.'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：对三个列表进行排序，然后描述如何进行“三路”合并。'
- en: '**Longest repeated substring.** Write a program [LRS.java](LRS.java.html) to
    to find the longest repeated substring in a string. Find the longest repeated
    substring in your favorite book.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长重复子串。** 编写一个程序[LRS.java](LRS.java.html)来找到字符串中最长的重复子串。找出你最喜欢的书中最长的重复子串。'
- en: Add code to [LRS.java](LRS.java.html) to make it print indices in the original
    string where the longest repeated substring occurs.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[LRS.java](LRS.java.html)中添加代码，使其打印出最长重复子字符串出现的原始字符串中的索引。
- en: '**Longest common substring.** Write a static method that finds the longest
    common substring of two given strings `s` and `t`.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长公共子串。** 编写一个静态方法，找到给定字符串`s`和`t`的最长公共子串。'
- en: '*Hint*: Suffix sort each string. Then merge the two sorted suffixes together.'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：对每个字符串进行后缀排序。然后将两个排序后的后缀合并在一起。'
- en: '**Longest repeated, non-overlapping string.** Modify [LRS.java](LRS.java.html)
    to find the longest repeated substring that *does not overlap*.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最长重复、不重叠的字符串。** 修改[LRS.java](LRS.java.html)以找到最长的重复子字符串，*不重叠*。'
- en: '**Rhyming words.** Write a program [Rhymer.java](Rhymer.java.html) that tabulates
    a list that you can use to find words that rhyme. Use the following approach:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**押韵的单词。** 编写一个程序[Rhymer.java](Rhymer.java.html)，制表一个列表，您可以使用该列表找到押韵的单词。使用以下方法：'
- en: Read in a dictionary of words into an array of strings.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个单词字典读入字符串数组中。
- en: Reverse the letters in each word (`confound` becomes `dnuofnoc`, for example).
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转每个单词的字母（例如，`confound`变为`dnuofnoc`）。
- en: Sort the resulting array.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对结果数组进行排序。
- en: Reverse the letters in each word back to their original order.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个单词中的字母反转回其原始顺序。
- en: For example, `confound` is adjacent to words such as `astound` and `surround`
    in the resulting list.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，`confound`在结果列表中与`astound`和`surround`等单词相邻。
- en: '**Scientific example of sorting.** Google display search results in descending
    order of "importance", a spreadsheet displays columns sorted by a particular field,
    Matlab sorts the real eigenvalues of a symmetric matrix in descending order. Sorting
    also arises as a critical subroutine in many applications that appear to have
    nothing to do with sorting at all including: data compression (see the Burrows-Wheeler
    programming assignment), computer graphics (convex hull, closest pair), computational
    biology (longest common substring discussed below), supply chain management (schedule
    jobs to minimize weighted sum of completion times), combinatorial optimization
    (Kruskal''s algorithm), social choice and voting (Kendall''s tau distance), Historically,
    sorting was most important for commercial applications, but sorting also plays
    a major role in the scientific computing infrastructure. [NASA](http://www.nas.nasa.gov/Research/Reports/Techreports/1990/rnr-90-017-abstract.html)
    and the fluids mechanics community use sorting to study problems in rarefied flow;
    these collision detection problems are especially challenging since they involve
    ten of billions of particles and can only be solved on supercomputers in parallel.
    Similar sorting techniques are used in some fast N-body simulation codes. Another
    important scientific application of sorting is for load balancing the processors
    of a parallel supercomputers. Scientists rely on clever sorting algorithm to perform
    load-balancing on such systems.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**排序的科学示例。** 谷歌显示搜索结果按“重要性”降序排列，电子表格显示按特定字段排序的列，Matlab按对称矩阵的实特征值降序排序。排序也出现在许多看似与排序无关的应用程序中作为关键子程序，包括：数据压缩（参见Burrows-Wheeler编程作业）、计算机图形学（凸包、最近对）、计算生物学（下文讨论的最长公共子串）、供应链管理（安排工作以最小化加权完成时间之和）、组合优化（Kruskal算法）、社会选择和投票（Kendall''s
    tau距离）。在历史上，排序对商业应用程序最为重要，但排序也在科学计算基础设施中扮演重要角色。[NASA](http://www.nas.nasa.gov/Research/Reports/Techreports/1990/rnr-90-017-abstract.html)和流体力学社区使用排序来研究稀疏流动中的问题；这些碰撞检测问题尤其具有挑战性，因为它们涉及数十亿粒子，并且只能在超级计算机上并行解决。一些快速N体模拟代码中也使用类似的排序技术。排序的另一个重要科学应用是平衡并行超级计算机的处理器。科学家依赖巧妙的排序算法在这些系统上执行负载平衡。'
