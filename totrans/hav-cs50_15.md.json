["```\nfrom logic import *\n\n# Create new classes, each having a name, or a symbol, representing each proposition. rain = Symbol(\"rain\")  # It is raining. hagrid = Symbol(\"hagrid\")  # Harry visited Hagrid dumbledore = Symbol(\"dumbledore\")  # Harry visited Dumbledore \n# Save sentences into the KB knowledge = And(  # Starting from the \"And\" logical connective, becasue each proposition represents knowledge that we know to be true. \n    Implication(Not(rain), hagrid),  # ¬(It is raining) → (Harry visited Hagrid) \n    Or(hagrid, dumbledore),  # (Harry visited Hagrid) ∨ (Harry visited Dumbledore). \n    Not(And(hagrid, dumbledore)),  # ¬(Harry visited Hagrid ∧ Harry visited Dumbledore) i.e. Harry did not visit both Hagrid and Dumbledore. \n    dumbledore  # Harry visited Dumbledore. Note that while previous propositions contained multiple symbols with connectors, this is a proposition consisting of one symbol. This means that we take as a fact that, in this KB, Harry visited Dumbledore.\n    ) \n```", "```\ndef check_all(knowledge, query, symbols, model):\n\n    # If model has an assignment for each symbol\n    # (The logic below might be a little confusing: we start with a list of symbols. The function is recursive, and every time it calls itself it pops one symbol from the symbols list and generates models from it. Thus, when the symbols list is empty, we know that we finished generating models with every possible truth assignment of symbols.)\n    if not symbols:\n\n        # If knowledge base is true in model, then query must also be true\n        if knowledge.evaluate(model):\n            return query.evaluate(model)\n        return True\n    else:\n\n        # Choose one of the remaining unused symbols\n        remaining = symbols.copy()\n        p = remaining.pop()\n\n        # Create a model where the symbol is true\n        model_true = model.copy()\n        model_true[p] = True\n\n        # Create a model where the symbol is false\n        model_false = model.copy()\n        model_false[p] = False\n\n        # Ensure entailment holds in both models\n        return(check_all(knowledge, query, remaining, model_true) and check_all(knowledge, query, remaining, model_false)) \n```", "```\n# Add the clues to the KB knowledge = And(\n\n    # Start with the game conditions: one item in each of the three categories has to be true.\n    Or(mustard, plum, scarlet),\n    Or(ballroom, kitchen, library),\n    Or(knife, revolver, wrench),\n\n    # Add the information from the three initial cards we saw\n    Not(mustard),\n    Not(kitchen),\n    Not(revolver),\n\n    # Add the guess someone made that it is Scarlet, who used a wrench in the library\n    Or(Not(scarlet), Not(library), Not(wrench)),\n\n    # Add the cards that we were exposed to\n    Not(plum),\n    Not(ballroom)\n) \n```"]