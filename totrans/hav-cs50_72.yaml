- en: Lecture 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/web/notes/7/](https://cs50.harvard.edu/web/notes/7/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Introduction](#introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testing](#testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Assert](#assert)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Test-Driven Development](#test-driven-development)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unit Testing](#unit-testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Django Testing](#django-testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Client Testing](#client-testing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Selenium](#selenium)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CI/CD](#cicd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GitHub Actions](#github-actions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Docker](#docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve discussed how to build simple web pages using HTML and CSS, and
    how to use Git and GitHub in order to keep track of changes to our code and collaborate
    with others. We also familiarized ourselves with the Python programming language,
    started using Django to create web applications, and learned how to use Django
    models to store information in our sites. We then introduced JavaScript and learned
    how to use it to make web pages more interactive, and talked about using animation
    and React to further improve our User Interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, we’ll learn about best practices when if comes to working on and launching
    larger projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important part of the software development process is the act of **Testing**
    the code we’ve written to make sure everything runs as we expect it to. In this
    lecture, we’ll discuss several ways that we can improve the way we test our code.
  prefs: []
  type: TYPE_NORMAL
- en: Assert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest ways we can run tests in Python is by using the `assert`
    command. This command is followed by some expression that should be `True`. If
    the expression is `True`, nothing will happen, and if it is `False`, an exception
    will be thrown. Let’s look at how we could incorporate command to test the `square`
    function we wrote when first learning Python. When the function is written correctly,
    nothing happens as the `assert` is `True`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And then when it is written incorrectly, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Test-Driven Development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you begin building larger projects, you may want to consider using **test-driven
    development**, a development style where every time you fix a bug, you add a test
    that checks for that bug to a growing set of tests that are run every time you
    make changes. This will help you to make sure that additional features you add
    to a project don’t interfere with your existing features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a slightly more complex function, and think about how writing
    tests can help us to find errors. We’ll now write a function called `is_prime`
    that returns `True` if and only if its input is prime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s take a look at a function we’ve written to test our `prime` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can go into our python interpreter and test out some values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the output above that 5 and 10 were correctly identified as
    prime and not prime, but 25 was incorrectly identified as prime, so there must
    be something wrong with our function. Before we look into what is wrong with our
    function though, let’s look at a way to automate our testing. One way we can do
    this is by creating a **shell script**, or some script that can be run inside
    our terminal. These files require a `.sh` extension, so our file will be called
    `tests0.sh`. Each of the lines below consists of
  prefs: []
  type: TYPE_NORMAL
- en: A `python3` to specify the Python version we’re running
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `-c` to indicate that we wish to run a command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A command to run in string format
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run these commands by running `./tests0.sh` in our terminal, giving
    us this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Unit Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though we were able to run tests automatically using the above method,
    we still might want to avoid having to write out each of those tests. Thankfully,
    we can use the Python `unittest` library to make this process a little bit easier.
    Let’s take a look at what a testing program might look like for our `is_prime`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that each of the functions within our `Tests` class followed a pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the functions begin with `test_`. This is necessary for the functions
    to be run automatically with the call to `unittest.main()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each test takes in the `self` argument. This is standard when writing methods
    within Python classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line of each function contains a **docstring** surrounded by three
    quotation marks. These are not just for the code’s readability. When the tests
    are run, the comment will be displayed as a discription of the test if it fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line of each of the functions contained an assertion in the form `self.assertSOMETHING`.
    There are many different assertions you can make including `assertTrue`, `assertFalse`,
    `assertEqual`, and `assertGreater`. You can find these ones and more by checking
    out the [documentation](https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s check out the results of these tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After running the tests, `unittest` provides us with some useful information
    about what it found. In the first line, it gives us a series of `.`s for successes
    and `F`s for failures in the order our tests were written.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, for each of the tests that failed, we are then given the name of the
    function that failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'the descriptive comment we provided earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And a traceback for the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we are given a run through of how many tests were run, how much
    time they took, and how many failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s take a look at fixing the bug in our function. It turns out that
    we need to test one additional number in our `for` loop. For example, when `n`
    is `25`, the square root is `5`, but when that is one argument in the `range`
    function, the `for` loop terminates at the number `4`. Therefore, we can simply
    change the header of our `for` loop to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we run the tests again using our unit tests, we get the following
    output, indicating that our change fixed the bug.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These automated tests will become even more useful as you work to optimize this
    function. For example, you might want to use the fact that you don’t need to check
    all integers as factors, just smaller primes (if a number is not divisible by
    3, it is also not divisible by 6, 9, 12, …), or you may want to use more advanced
    probabilistic primality tests such as the [Fermat](https://en.wikipedia.org/wiki/Fermat_primality_test)
    and [Miller-Rabin](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)
    primality tests. Whenever you make changes to improve this function, you’ll want
    the ability to easily run your unit tests again to make sure your function is
    still correct.
  prefs: []
  type: TYPE_NORMAL
- en: Django Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s look at how we can apply the ideas of automated testing when creating
    Django applications. While working with this, we’ll be using the `flights` project
    we created when we first learned about Django models. We’re first going to add
    a method to our `Flight` model that verifies that a flight is valid by checking
    for two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The origin is not the same as the destination
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The duration is greater than 0 minutes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, our model could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make sure our application works as expected, whenever we create
    a new application, we are automatically given a `tests.py` file. When we first
    open this file, we see that Django’s [TestCase](https://docs.djangoproject.com/en/4.0/topics/testing/overview/)
    library is automatically imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: One advantage to using the `TestCase` library is that when we run our tests,
    an entirely new database will be created for testing purposes only. This is helpful
    because we avoid the risk of accidentally modifying or deleting existing entries
    in our databse and we don’t have to worry about removing dummy entries that we
    created only for testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using this library, we’ll first want to import all of our models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we’ll create a new class that extends the `TestCase` class we just
    imported. Within this class, we’ll define a `setUp` function that will be run
    at the start of the testing process. In this function, we’ll probably want to
    create. Here’s what our class will look like to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have some entries in our testing database, let’s add some functions
    to this class to perform some tests. First, let’s make sure our `departures` and
    `arrivals` fields work correctly by attempting to count the number of departures
    (which we know should be 3) and arrivals (which should be 1) from airport `AAA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also test the `is_valid_flight` function we added to our `Flight` model.
    We’ll begin by asserting that the function does return true when the flight is
    valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s make sure that flights with invalid destinations and durations
    return false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to run our tests, we’ll run `python manage.py test`. The output for this
    is almost identical to the output we saw while using the Python `unittest` library,
    although it also logs that it is creating and destroying a testing database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the above output that there are times when `is_valid_flight`
    returned `True` when it should have returned `False`. We can see, upon further
    inspection of our function, that we made the mistake of using `or` instead of
    `and`, meaning that only one of the flight requirements must be filled for the
    flight to be valid. If we change the function to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run the tests again with better results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Client Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating web applications, we will probably want to check not just whether
    or not specific functions work, but also whether or not individual web pages load
    as intended. We can do this by creating a `Client` object in our Django testing
    class, and then making requests using that object. To do this, we’ll first have
    to add `Client` to our imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let’s now add a test that makes sure that we get an HTTP response
    code of 200 and that all three of our flights are added to the context of a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can similarly check to make sure we get a valid response code for a valid
    flight page, and an invalid response code for a flight page that doesn’t exist.
    (Notice that we use the `Max` function to find the maximum `id`, which we have
    access to by including `from django.db.models import Max` at the top of our file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s add some testing to make sure the passengers and non-passengers
    lists are being generated as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run all of our tests together, and see that at the moment we have
    no errors!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Selenium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve been able to test out the server-side code we’ve written using
    Python and Django, but as we’re building up our applications we’ll want the ability
    to create tests for our client-side code as well. For example, let’s think back
    to our `counter.html` page and work on writing some tests for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by writing a slightly different counter page where we include a
    button to decrease the count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now if we wish to test this code, we could just open up our web browser, click
    the two buttons, and observe what happens. This, however, would become very tedious
    as you write larger and larger single page applications, which is why several
    frameworks have been created that help with in-browser testing, one of which is
    called [Selenium](https://www.selenium.dev/).
  prefs: []
  type: TYPE_NORMAL
- en: Using Selenium, we’ll be able to define a testing file in Python where we can
    simulate a user opening a web browser, navigating to our page, and interacting
    with it. Our main tool when doing this is known as a **Web Driver**, which will
    open up a web browser on your computer. Let’s take a look at how we could start
    using this library to begin interacting with pages. Note that below we use both
    `selenium` and `ChromeDriver`. Selenium can be installed for python by running
    `pip install selenium`, and `ChromeDriver` can be installed by running `pip install
    chromedriver-py`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The above code is all of the basic setup we need, so now we can get into some
    more interesting uses by employing the Python interpreter. One note about the
    first few lines is that in order to target a specific page, we need that page’s
    **Uniform Resource Identifier (URI)** which is a unique string that represents
    that resource.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s take a look at how we can use this simulation to create automated
    tests of our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run `python tests.py`, our simulations will be carried out in the
    browser, and then the results of the tests will be printed to the console. Here’s
    an example of what this might look like when we have a bug in the code a test
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![failed selenium test](../Images/d585dec8593971ca29cf0696c5c578ff.png)'
  prefs: []
  type: TYPE_IMG
- en: CI/CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CI/CD**, which stands for **Continuous Integration and Continuous Delivery**,
    is a set of software development best practices that dictate how code is written
    by a team of people, and how that code is later delivered to users of the application.
    As the name implies, this method consists of two main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuous Integration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequent merges to the main branch
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated unit testing with each merge
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Continuous Delivery:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short release schedules, meaning new versions of an application are released
    frequently.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CI/CD has become more and more popular among software development teams for
    a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: When different team members are working on different features, many compatibility
    issues can arise when multiple features are combined at the same time. Continuous
    integration allows teams to tackle small conflicts as they come.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because unit tests are run with each Merge, when a test fails it is easier to
    isolate the part of the code that is causing the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequently releasing new versions of an application allows developers to isolate
    problems if they arise after launch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing small, incremental changes allows users to slowly get used to new
    app features rather than being overwhelmed with an entirely different version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not waiting to release new features allows companies to stay ahead in a competitive
    market.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One popular tool used to help with continuous integration is known as [GitHub
    Actions](https://github.com/features/actions). GitHub Actions will allow us to
    create workflows where we can specify certain actions to be performed every time
    someone pushes to a git repository. For example, we might want to check with every
    push that a style guide is adhered to, or that a set of unit tests is passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set up a GitHub action, we’ll use a configuration language called
    **YAML**. YAML structures its data around key-value pairs (like a JSON object
    or Python Dictionary). Here’s an example of a simple YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at an example of how we would configure a YAML file (which
    takes the form `name.yml` or `name.yaml`) that works with GitHub Actions. To do
    this, I’ll create a `.github` directory in my repository, and then a `workflows`
    directory inside of that, and finally a `ci.yml` file within that. In that file,
    we’ll write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is our first time using GitHub Actions, let’s go through what each
    part of this file is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we give the workflow a `name`, which in our case is Testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, with the `on` key, we specify when the workflow should run. In our case,
    we wish to perform the tests every time someone pushes to the repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the file is contained within a `jobs` key, which indicates which
    jobs should be run at every push.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, the only job is `test_project`. Every job must define two componenets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `runs-on` key specifies which of GitHub’s virtual machines we would like
    our code to be run on.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `steps` key provides the actions that should occur when this job is run
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `uses` key we specify which GitHub action we wish to use. `actions/checkout@v2`
    is an action written by GitHub that we can use.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` key here allows us to proide a description of the action we’re taking
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `run` key, we type the commands we wish to run on GitHub’s server.
    In our case we wish to install Django and then run the testing file.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s open up our repository in GitHub and take a look at some of the
    tabs near the top of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**: This is the tab that we’ve been using most frequently, as it allows
    us to view the files and folders within our directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issues**: Here we can open and close issues, which are requests for bug fixes
    or new features. We can think of this as a to-do list for our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pull Requests**: Requests from people who wish to merge some code from one
    branch into another one. This is a useful tool, as it allows people to perform
    **code reviews** where they comment and provide suggestions before code is integrated
    into the master branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Actions**: This is the tab we’ll use when working on continuous integration,
    as it provides logs of the actions that have taken place after each push.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, let’s imagine that we pushed our changes *before* we fixed the bug we
    had in the `is_valid_flight` function in `models.py` within our `airport` project.
    We can now navigate to the **GitHub Actions** tab, click on our most recent push,
    click on the action that failed, and view the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![action](../Images/abd420062892a0c33c8af5ffc54b781d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, after fixing the bug, we could bush again and find a better outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![action success](../Images/e55ecd17b60624084d9b819987b28cfa.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problems can arise in the world of software development when the configuration
    on your computer is different than the one your application is being run on. You
    may have a different version of Python or some additional packages installed that
    allow the application to run smoothly on your computer, while it would crash on
    your server. To avoid these problems, we need a way to make sure everyone working
    on a project is using the same environment. One way to do this is to use a tool
    called **Docker**, which is a containerization software, meaning it creates an
    isolated environment within your computer that can be standardized among many
    collaborators and the server on which your site is run. While Docker is a bit
    like a **Virtual Machine**, they are in fact different technologies. A virtual
    machine (like the one used on GitHub Actions or when you launch an [AWS](./) server)
    is effectively an entire virtual computer with its own operating system, meaning
    it ends up taking a lot of space wherever it is running. Dockers, on the other
    hand, work by setting up a container within an existing computer, therefore taking
    up less space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an idea of what a Docker container is, let’s take a look at
    how we can configure one on our computers. Our first step in doing this will be
    to create a **Docker File** which we’ll name `Dockerfile`. Inside this file, we’ll
    provide instructions for how to create a **Docker Image** which describes the
    libraries and binaries we wish to include in our container. Here’s an example
    of what our `Dockerfile` might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ll take an in-depth look at what the above file actually does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM python3`: this shows that we are basing this image off of a standard
    image in which Python 3 is installed. This is fairly common when writing a Docker
    File, as it allows you to avoid the work of re-defining the same basic setup with
    each new image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY . /usr/src/app`: This shows that we wish to copy everything from our
    current directory (`.`) and store it in the `/usr/src/app` directory in our new
    container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR /usr/src/app`: This sets up where we will run commands within the
    container. (A bit like `cd` on the terminal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN pip install -r requirements.txt`: In this line, assuming you’ve included
    all of your requirements to a file called `requirements.txt`, they will all be
    installed within the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD ["python3", "manage.py", "runserver", "0.0.0.0:8000"]`: Finally, we specify
    the command that should be run when we start up the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far in this class, we’ve only been using SQLite as that’s the default database
    management system for Django. In live applications with real users though, SQLite
    is almost never used, as it is not as easily scaled as other systems. Thankfully,
    if we wish to run a separate server for our database, we can simply add another
    Docker container, and run them together using a feature called **Docker Compose**.
    This will allow two different servers to run in separate containers, but also
    be able to communicate with one another. To specify this, we’ll use a YAML file
    called `docker-compose.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above file we:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify that we’re using version 3 of Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Outline two services:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db` sets up our database container based on an image already written by Postgres.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web` sets up our server’s container by instructing Docker to:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Dockerfile within the current directory.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the specified path within the container.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link port 8000 within the container to port 8000 on our computer.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we’re ready to start up our services with the command `docker-compose up`.
    This will launch both of our servers inside of new Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we may want to run commands within our Docker container to add
    database entries or run tests. To do this, we’ll first run `docker ps` to show
    all of the docker containers that are running. Then, well find the `CONTAINER
    ID` of the container we wish to enter and run `docker exec -it CONTAINER_ID bash
    -l`. This will move you inside the `usr/src/app` directory we set up within our
    container. We can run any commands we wish inside that container and then exit
    by running `CTRL-D`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all for this lecture! Next time, we’ll working on scaling up our projects
    and making sure they are secure.
  prefs: []
  type: TYPE_NORMAL
