- en: 3.2   Creating Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2   创建数据类型
- en: 原文：[https://introcs.cs.princeton.edu/java/32class](https://introcs.cs.princeton.edu/java/32class)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/32class](https://introcs.cs.princeton.edu/java/32class)
- en: In this section, we introduce the Java mechanism that enables us to create user-defined
    data types. We consider a range of examples, from charged particles and complex
    numbers to turtle graphics and stock accounts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了使我们能够创建用户定义数据类型的Java机制。我们考虑了一系列示例，从带电粒子和复数到乌龟图形和股票账户。
- en: Basic elements of a data type.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型的基本元素。
- en: '![Coulomb''s law](../Images/a6cb7c619d9a2e9e22f03c5f7217dbe0.png) To illustrate
    the process, we define in [Charge.java](Charge.java.html) a data type for charged
    particles. [Coulomb’s law](https://en.wikipedia.org/wiki/Coulomb%27s_law) tells
    us that the electric potential at a point \((x, y)\) due to a given charged particle
    is \(V = kq /r\), where \(q\) is the charge value, \(r\) is the distance from
    the point \((x, y)\) to the charge, and \(k = 8.99 \times 10^9\) is the electrostatic
    constant.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![库仑定律](../Images/a6cb7c619d9a2e9e22f03c5f7217dbe0.png) 为了说明这个过程，我们在[Charge.java](Charge.java.html)中定义了一个用于带电粒子的数据类型。[库仑定律](https://en.wikipedia.org/wiki/Coulomb%27s_law)告诉我们，由于给定带电粒子，点\((x,
    y)\)处的电势是\(V = kq /r\)，其中\(q\)是电荷值，\(r\)是点\((x, y)\)到电荷的距离，\(k = 8.99 \times 10^9\)是静电常数。'
- en: '*API.* The application programming interface is the contract with all clients
    and, therefore, the starting point for any implementation.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*API。* 应用程序编程接口是与所有客户端的合同，因此是任何实现的起点。'
- en: '![Charge API](../Images/2f6c4130070ed35aa425e751b62022e7.png)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Charge API](../Images/2f6c4130070ed35aa425e751b62022e7.png)'
- en: '*Class.* In Java, you implement a data type in a `class`. As usual, we put
    the code for a data type in a file with the same name as the class, followed by
    the `.java` extension.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类。* 在Java中，您在`class`中实现数据类型。通常情况下，我们将数据类型的代码放在与类相同名称的文件中，后面跟着`.java`扩展名。'
- en: '*Access modifiers.* We designate every instance variable and method within
    a class as either `public` (this entity is accessible by clients) or `private`
    (this entity is not accessible by clients). The `final` modifier indicates that
    the value of the variable will not change once it is initialized—its access is
    read-only.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问修饰符。* 我们将类中的每个实例变量和方法指定为`public`（此实体可被客户端访问）或`private`（此实体不可被客户端访问）。`final`修饰符表示一旦初始化，变量的值将不会改变——其访问是只读的。'
- en: '*Instance variables.* We declare *instance variables* to represent the data-type
    values in the same way as we declare local variables, except that these declarations
    appear as the first statements in the class, not inside `main()` or any other
    method. For `Charge`, we use three `double` variables—two to describe the charge’s
    position and one to describe the amount of charge.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实例变量。* 我们声明*实例变量*来表示数据类型的值，方式与声明局部变量相同，只是这些声明出现在类的第一条语句中，而不是在`main()`或任何其他方法中。对于`Charge`，我们使用三个`double`变量——两个用于描述电荷的位置，一个用于描述电荷量。'
- en: '![Instance variables](../Images/f5d3c02cdb37e24603fa5f01ba92be09.png)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![实例变量](../Images/f5d3c02cdb37e24603fa5f01ba92be09.png)'
- en: '*Constructors.* A constructor is a special method that creates an object and
    provides a reference to that object. Java automatically invokes a constructor
    when a client program uses the keyword `new`. Each time that a client invokes
    a constructor, Java automatically'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构造函数。* 构造函数是创建对象并提供对该对象的引用的特殊方法。当客户端程序使用关键字`new`时，Java会自动调用构造函数。每当客户端调用构造函数时，Java会自动'
- en: Allocates memory for the object
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为对象分配内存
- en: Invokes the constructor code to initialize the instance variables
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用构造函数代码来初始化实例变量。
- en: Returns a reference to the newly created object
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回对新创建对象的引用
- en: 'The constructor in `Charge` is typical: it initializes the instance variables
    with the values provided by the client as arguments.'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Charge`中的构造函数很典型：它使用客户端提供的值作为参数来初始化实例变量。'
- en: '![Constructor](../Images/f8b6f39bebf3114dec183569653b0adc.png)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![构造函数](../Images/f8b6f39bebf3114dec183569653b0adc.png)'
- en: '*Instance methods.* To implement instance methods, we write code that is precisely
    like code for implementing static methods. The one critical distinction is that
    instance methods can perform operations on instance variables.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实例方法。* 要实现实例方法，我们编写的代码与实现静态方法的代码完全相同。唯一的关键区别是实例方法可以对实例变量执行操作。'
- en: '![Instance method](../Images/75465977689b9539fb07389b98107303.png)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![实例方法](../Images/75465977689b9539fb07389b98107303.png)'
- en: '*Variables within methods.* The Java code we write to implement instance methods
    uses three kinds of variables. Parameter variables and local variables are familiar.
    Instance variables are completely different: they hold data-type values for objects
    in a class.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法内的变量。* 我们编写的Java代码来实现实例方法使用三种类型的变量。参数变量和局部变量是熟悉的。实例变量完全不同：它们保存类中对象的数据类型值。'
- en: '![Instance, parameter and local variables](../Images/6e3d478887d8c9837841e973f1a9e63e.png)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![实例、参数和局部变量](../Images/6e3d478887d8c9837841e973f1a9e63e.png)'
- en: 'Each object in the class has a value: the code in an instance method refers
    to the value for the object that was used to invoke the method. For example, when
    we write `c1.potentialAt(x, y)`, the code in `potentialAt()` is referring to the
    instance variables for `c1`.'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类中的每个对象都有一个值：实例方法中的代码引用了调用该方法的对象的值。例如，当我们写`c1.potentialAt(x, y)`时，`potentialAt()`中的代码是在引用`c1`的实例变量。
- en: '*Test client.* Each class can define its own `main()` method, which we reserve
    for unit testing. At a minimum, the test client should call every constructor
    and instance method in the class.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试客户端。* 每个类都可以定义自己的`main()`方法，我们保留用于单元测试。至少，测试客户端应该调用类中的每个构造函数和实例方法。'
- en: In summary, to define a data type in a Java class, you need instance variables,
    constructors, instance methods, and a test client.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在Java类中定义数据类型，需要实例变量、构造函数、实例方法和一个测试客户端。
- en: '![Anatomy of a class](../Images/ace94fc7cbe724f36aaff409d7ad77db.png)'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![类的解剖](../Images/ace94fc7cbe724f36aaff409d7ad77db.png)'
- en: Stopwatch.
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秒表。
- en: '[Stopwatch.java](Stopwatch.java.html) implements the following API:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[秒表.java](Stopwatch.java.html) 实现了以下API：'
- en: '![Stopwatch API](../Images/d2db4f4e91ded393e9c0d5577dc61b9d.png)'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![秒表API](../Images/d2db4f4e91ded393e9c0d5577dc61b9d.png)'
- en: It is a stripped-down version of an old-fashioned stopwatch. When you create
    one, it starts running, and you can ask it how long it has been running by invoking
    the method `elapsedTime()`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化版本的老式秒表。当你创建一个时，它就开始计时，你可以通过调用方法`elapsedTime()`来询问它已经运行了多长时间。
- en: Histogram.
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直方图。
- en: '![Histogram](../Images/6cd930fcf39a72dd625eaf280149e8b4.png) [Histogram.java](Histogram.java.html)
    is a data type to visualize data using a familiar plot known as a *histogram*.
    For simplicity, we assume that the data consists of a sequence of integer values
    between 0 and *n*−1. A histogram counts the number of times each value appears
    and plots a bar for each value (with height proportional to its frequency). The
    following API describes the operations:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![直方图](../Images/6cd930fcf39a72dd625eaf280149e8b4.png) [Histogram.java](Histogram.java.html)
    是一种使用熟悉的绘图方式*直方图*来可视化数据的数据类型。为简单起见，我们假设数据由0到 *n*−1之间的整数值序列组成。直方图计算每个值出现的次数，并为每个值绘制一个柱（高度与其频率成比例）。以下API描述了操作：'
- en: '![Histogram API](../Images/638f25b16264e1800ef8d57337f35931.png)'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![直方图API](../Images/638f25b16264e1800ef8d57337f35931.png)'
- en: Turtle graphics.
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 海龟图形。
- en: '[Turtle.java](Turtle.java.html) is a mutable type for turtle graphics, in which
    we command a turtle to move a specified distance in a straight line, or rotate
    (counterclockwise) a specified number of degrees.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[Turtle.java](Turtle.java.html) 是一个用于海龟图形的可变类型，我们可以命令海龟沿直线移动指定距离，或者旋转（逆时针）指定角度。'
- en: '![Turtle graphics API](../Images/2bfcee40b61dec8fe413b9e297f77025.png)'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![海龟图形API](../Images/2bfcee40b61dec8fe413b9e297f77025.png)'
- en: 'Here are a few example clients:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例客户端：
- en: '*Regular n-gons.* [Ngon.java](Ngon.java.html) takes a command-line argument
    *n* and draws a regular *n*-gon using turtle graphics. By taking *n* to a sufficiently
    large value, we obtain a good approximation to a circle.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正多边形。* [Ngon.java](Ngon.java.html) 接受一个命令行参数 *n* 并使用海龟图形绘制一个正 *n* 边形。通过将 *n*
    取得足够大的值，我们可以得到一个对圆的良好近似。'
- en: '*Recursive graphics.* [Koch.java](Koch.java.html) takes a command-line argument
    *n* and draws a [Koch curve](https://en.wikipedia.org/wiki/Koch_snowflake) of
    order *n*. A Koch curve of order order 0 is a line segment. To form a Koch curve
    of order *n*:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*递归图形。* [Koch.java](Koch.java.html) 接受一个命令行参数 *n* 并绘制一个 *n* 阶的[Koch曲线](https://en.wikipedia.org/wiki/Koch_snowflake)。0阶的Koch曲线是一条线段。要形成一个
    *n* 阶的Koch曲线：'
- en: Draw a Koch curve of order *n*−1
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个 *n*−1 阶的Koch曲线
- en: Rotate 60° counterclockwise
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆时针旋转60°
- en: Draw a Koch curve of order *n*−1
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个 *n*−1 阶的Koch曲线
- en: Rotate 120° clockwise
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺时针旋转120°
- en: Draw a Koch curve of order *n*−1
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个 *n*−1 阶的Koch曲线
- en: Rotate 60° counterclockwise
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆时针旋转60°
- en: Draw a Koch curve of order *n*−1
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个 *n*−1 阶的Koch曲线
- en: Below are the Koch curves of order 0, 1, 2, and 3.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是0、1、2和3阶的Koch曲线。
- en: '| ![Koch curve 0](../Images/65e1d7653553d4ddb5d1aaefdeaa3bd2.png "Koch curve
    of order 0") | ![Koch curve 1](../Images/828b58ef5abfb4bc9b6e4e24fcedff32.png
    "Koch curve of order 1") | ![Koch curve 2](../Images/274901ba86291bde4babeb5166892b0b.png
    "Koch curve of order 2") | ![Koch curve 3](../Images/2c5362ac4e7fb96038b4799598e767c9.png
    "Koch curve of order 3") |'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![科赫曲线 0](../Images/65e1d7653553d4ddb5d1aaefdeaa3bd2.png "0阶科赫曲线") | ![科赫曲线
    1](../Images/828b58ef5abfb4bc9b6e4e24fcedff32.png "1阶科赫曲线") | ![科赫曲线 2](../Images/274901ba86291bde4babeb5166892b0b.png
    "2阶科赫曲线") | ![科赫曲线 3](../Images/2c5362ac4e7fb96038b4799598e767c9.png "3阶科赫曲线")
    |'
- en: '*Spira mirabilis.* ![logarithmic spiral](../Images/14c718646c168121dac0447a80b3205b.png)
    [Spiral.java](Spiral.java.html) takes an integer *n* and a decay factor as command-line
    arguments, and instructs the turtle to alternately step and turn until it has
    wound around itself 10 times. This produces a geometric shape known as a [logarithmic
    spiral](https://en.wikipedia.org/wiki/Logarithmic_spiral), which arise frequently
    in nature.  Three examples are depicted below: the chambers of a nautilus shell,
    the arms of a spiral galaxy, and the cloud formation in a tropical storm.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*奇妙的螺线。* ![对数螺线](../Images/14c718646c168121dac0447a80b3205b.png) [螺线.java](Spiral.java.html)
    接受一个整数 *n* 和一个衰减因子作为命令行参数，并指示海龟交替前进和转向，直到它绕自身旋转了10次。这产生了一个被称为[对数螺线](https://en.wikipedia.org/wiki/Logarithmic_spiral)的几何形状，它经常出现在自然界中。下面描绘了三个例子：鹦鹉螺壳的腔室、螺旋星系的臂和热带风暴中的云团。'
- en: '| [![Nautilus shell](../Images/5dcac6d8c6d6010ca4b0969209a67615.png)](https://commons.wikimedia.org/wiki/File:NautilusCutawayLogarithmicSpiral.jpg)
    |    | ![arms of a spiral galaxy](../Images/c7d8e3de353841570edc597cfe153a79.png)
    |    | ![Low pressure system over Iceland](../Images/ddc45020e8d0a139eb26a78210595a25.png)
    |'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| [![鹦鹉螺壳](../Images/5dcac6d8c6d6010ca4b0969209a67615.png)](https://commons.wikimedia.org/wiki/File:NautilusCutawayLogarithmicSpiral.jpg)
    |    | ![螺旋星系的臂](../Images/c7d8e3de353841570edc597cfe153a79.png) |    | ![冰岛上空的低气压系统](../Images/ddc45020e8d0a139eb26a78210595a25.png)
    |'
- en: '| This Wikipedia image is from [user Chris 73](https://en.wikipedia.org/wiki/User:Chris_73),
    and is available via the [CC by-SA 3.0 license.](https://creativecommons.org/licenses/by-sa/3.0/)
    |  | Photo: NASA and ESA   |  | Photo: NASA   |'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 这张维基百科图片来自[用户Chris 73](https://en.wikipedia.org/wiki/User:Chris_73)，并可通过[CC
    by-SA 3.0许可证](https://creativecommons.org/licenses/by-sa/3.0/)获得。 |  | 照片：NASA和ESA
      |  | 照片：NASA   |'
- en: '*Brownian motion.* [DrunkenTurtle.java](DrunkenTurtle.java.html) plots the
    path followed by a disoriented turtle, who alternates between moving forward and
    turning in a *random* direction. This process is known as [Brownian motion](https://en.wikipedia.org/wiki/Brownian_motion).
    [DrunkenTurtles.java](DrunkenTurtles.java.html) plots many such turtles, all of
    whom wander around.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布朗运动。* [醉海龟.java](DrunkenTurtle.java.html) 绘制了一个迷失方向的海龟所经过的路径，它交替前进和向*随机*方向转向。这个过程被称为[布朗运动](https://en.wikipedia.org/wiki/Brownian_motion)。[醉海龟们.java](DrunkenTurtles.java.html)绘制了许多这样的海龟，它们都四处游荡。'
- en: Complex numbers.
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数。
- en: 'A *complex* number is a number of the form *x* + *iy*, where *x* and *y* are
    real numbers and *i* is the square root of −1. The basic operations on complex
    numbers are to add and multiply them, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 复数是形式为 *x* + *iy* 的数，其中 *x* 和 *y* 是实数，*i* 是-1的平方根。复数的基本运算是相加和相乘，如下所示：
- en: '*Addition*: \((x_0+iy_0) + (x_1+iy_1) = (x_0+x_1) + i\,(y_0+y_1)\)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加法*: \((x_0+iy_0) + (x_1+iy_1) = (x_0+x_1) + i\,(y_0+y_1)\)'
- en: '*Multiplication*: \((x_0 + iy_0) \cdot (x_1 + iy_1) = (x_0x_1 - y_0y_1) + i\,(y_0x_1
    + x_0y_1)\)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*乘法*: \((x_0 + iy_0) \cdot (x_1 + iy_1) = (x_0x_1 - y_0y_1) + i\,(y_0x_1 +
    x_0y_1)\)'
- en: '*Magnitude*: \(\left | x + iy \right | = \sqrt{x^2 + y^2}\)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*幅度*: \(\left | x + iy \right | = \sqrt{x^2 + y^2}\)'
- en: '*Real part*: \(\operatorname{Re}(x + iy) = x\)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实部*: \(\operatorname{Re}(x + iy) = x\)'
- en: '*Imaginary part*: \( \operatorname{Im}(x + iy) = y\)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚部*: \( \operatorname{Im}(x + iy) = y\)'
- en: '[Complex.java](Complex.java.html) is an immutable data type that implements
    the following API:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[Complex.java](Complex.java.html) 是一个不可变数据类型，实现了以下 API：'
- en: '![Complex number API](../Images/ccfbafd7e0a10894da469106e9b31a99.png)'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![复数 API](../Images/ccfbafd7e0a10894da469106e9b31a99.png)'
- en: This data type introduces a few new features.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据类型引入了一些新功能。
- en: '*Accessing values of other objects of the same type.* The instance methods
    `plus()` and `times()` each need to access values in two objects: the object passed
    as an argument and the object used to invoke the method. If we call the method
    with `a.plus(b)`, we can access the instance variables of `a` using the names
    `re` and `im`, as usual. However, to access the instance variables of `b`, we
    use the code `b.re` and `b.im`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问同一类型其他对象的值。* 实例方法 `plus()` 和 `times()` 需要访问两个对象中的值：作为参数传递的对象和用于调用方法的对象。如果我们用
    `a.plus(b)` 调用方法，我们可以像往常一样使用名称 `re` 和 `im` 访问 `a` 的实例变量。但是，要访问 `b` 的实例变量，我们使用代码
    `b.re` 和 `b.im`。'
- en: '*Creating and returning new objects.* Observe the manner in which `plus()`
    and `times()` provide return values to clients: they need to return a `Complex`
    value, so they each compute the requisite real and imaginary parts, use them to
    create a new object, and then return a reference to that object.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建和返回新对象。* 注意 `plus()` 和 `times()` 如何向客户端提供返回值：它们需要返回一个 `Complex` 值，因此它们分别计算所需的实部和虚部，用它们创建一个新对象，然后返回对该对象的引用。'
- en: '*Chaining method calls.* Observe the manner in which `main()` *chains* two
    method calls into one compact expression `z.times(z).plus(z0)`, which corresponds
    to the mathematical expression *z*² + *z*[0].'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链接方法调用。* 注意 `main()` 如何将两个方法调用链接成一个紧凑的表达式 `z.times(z).plus(z0)`，对应于数学表达式 *z*²
    + *z*[0]。'
- en: '*Final instance variables.* The two instance variables in `Complex` are `final`,
    meaning that their values are set for each `Complex` object when it is created
    and do not change during the lifetime of that object.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最终实例变量。* `Complex` 中的两个实例变量是 `final` 的，这意味着它们的值在创建 `Complex` 对象时设置，并且在该对象的生命周期内不会更改。'
- en: Mandelbrot set.
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 曼德勃罗集。
- en: 'The [Mandelbrot set](https://www.cs.princeton.edu/~wayne/mandel/mandel.html)
    is a specific set of complex numbers with many fascinating properties. The *algorithm*
    for determining whether or not a complex number \(z_0\) is in the Mandelbrot set
    is simple: Consider the sequence of complex numbers \(z_0, z_1, z_2, \ldots, z_t,
    \ldots,\) where \(z_{i+1} = z_i^2 + z_0\). For example, the following table shows
    the first few entries in the sequence corresponding to \(z_0 = 1 + i\):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[曼德勃罗集](https://www.cs.princeton.edu/~wayne/mandel/mandel.html) 是一组具有许多迷人特性的复数。确定一个复数
    \(z_0\) 是否在曼德勃罗集中的算法很简单：考虑复数序列 \(z_0, z_1, z_2, \ldots, z_t, \ldots,\) 其中 \(z_{i+1}
    = z_i^2 + z_0\)。例如，以下表格显示了与 \(z_0 = 1 + i\) 对应的序列的前几个条目：'
- en: '![Mandelbrot sequence](../Images/70ba60fad845c843579dfb5d7587c7c3.png)'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![曼德勃罗集序列](../Images/70ba60fad845c843579dfb5d7587c7c3.png)'
- en: 'Now, if the sequence \( | z_i |\) diverges to infinity, then \(z_0\) is *not*
    in the Mandelbrot set; if the sequence is bounded, then \(z_0\) is in the Mandelbrot
    set. For many points, the test is simple; for many other points, the test requires
    more computation, as indicated by the examples in the following table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果序列 \( | z_i |\) 发散到无穷大，那么 \(z_0\) *不* 在曼德勃罗集中；如果序列有界，那么 \(z_0\) 在曼德勃罗集中。对于许多点，测试很简单；对于许多其他点，测试需要更多计算，如下表中的示例所示：
- en: '![Mandelbrot sequences](../Images/7099b5c20dd94ead91f14619dbe5dcd2.png)'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![曼德勃罗集序列](../Images/7099b5c20dd94ead91f14619dbe5dcd2.png)'
- en: To visualize the Mandelbrot set, we define an evenly spaced *n*-by-*n* pixel
    grid within a specified square and draw a black pixel if the corresponding point
    is in the Mandelbrot set and a white pixel if it is not.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化曼德勃罗集，我们在指定的正方形内定义一个均匀间隔的 *n*×*n* 像素网格，并在相应点属于曼德勃罗集时绘制黑色像素，不属于时绘制白色像素。
- en: '![Mandelbrot set](../Images/2ea3a24598cd9b7c30efd5a27615532b.png)'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![曼德勃罗集](../Images/2ea3a24598cd9b7c30efd5a27615532b.png)'
- en: But how do we determine whether a complex number is in the Mandelbrot set? For
    each complex number, [Mandelbrot.java](Mandelbrot.java.html) computes up to 255
    terms in its sequence. If the magnitude ever exceeds 2, then we can conclude that
    the complex number is not in the set (because it is known that the sequence will
    surely diverge). Otherwise, we conclude that the complex number is in the set
    (knowing that our conclusion might be wrong on occasion).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何确定一个复数是否属于曼德勃罗集？对于每个复数，[Mandelbrot.java](Mandelbrot.java.html) 计算其序列中的最多255个项。如果幅度超过2，那么我们可以得出结论该复数不在集合中（因为已知该序列肯定会发散）。否则，我们得出结论该复数在集合中（知道我们的结论偶尔可能是错误的）。
- en: Commercial data processing.
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 商业数据处理。
- en: '[StockAccount.java](StockAccount.java.html) implements a data type that might
    be used by a financial institution to keep track of customer information.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[StockAccount.java](StockAccount.java.html) 实现了一个数据类型，可能被金融机构用来跟踪客户信息。'
- en: '![Stock account API](../Images/bdc37b5ab057ff677a148545f768a13b.png)'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![股票账户 API](../Images/bdc37b5ab057ff677a148545f768a13b.png)'
- en: Exercises
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Develop an implementation [Rectangle.java](Rectangle.java.html) of your `Rectangle`
    API from Exercise 3.2.1 that that represents rectangles with the *x*- and *y*-coordinates
    of their lower-left and upper-right corners. Do not change the API.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个实现 [Rectangle.java](Rectangle.java.html) 的实现，该实现表示具有其左下角和右上角的 *x* 和 *y*
    坐标的矩形。不要更改 API。
- en: Implement a data type [Rational.java](Rational.java.html) numbers that supports
    addition, subtraction, multiplication, and division.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个支持加法、减法、乘法和除法的数据类型 [Rational.java](Rational.java.html)。
- en: '![Rational API](../Images/75cc28a56a8e170deeebd4dd999b422a.png)'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![有理数 API](../Images/75cc28a56a8e170deeebd4dd999b422a.png)'
- en: 'Write a data type [Interval.java](Interval.java.html) that implements the following
    API:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个实现以下 API 的数据类型 [Interval.java](Interval.java.html)：
- en: '![Interval API](../Images/c7ae1db93430cb56b9f12fac8b144692.png)'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![区间 API](../Images/c7ae1db93430cb56b9f12fac8b144692.png)'
- en: An interval is defined to be the set of all points on the line greater than
    or equal to `min` and less than or equal to `max`. In particular, an interval
    with `max` less than `min` is empty. Write a client that is a filter that takes
    a floating-point command-line argument `x` and prints all of the intervals on
    standard input (each defined by a pair of double values) that contain `x`.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 区间被定义为线上大于等于 `min` 且小于等于 `max` 的所有点的集合。特别地，`max` 小于 `min` 的区间为空。编写一个客户端，它是一个过滤器，接受一个浮点命令行参数
    `x`，并打印所有包含 `x` 的标准输入中的区间（每个由一对双精度值定义）。
- en: 'Write a data type [Point.java](Point.java.html) that implements the following
    API:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个实现以下 API 的数据类型 [Point.java](Point.java.html)：
- en: '![Point API](../Images/32cdef14784826d070f4bd0e1f330c6b.png)'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![点 API](../Images/32cdef14784826d070f4bd0e1f330c6b.png)'
- en: Modify the `toString()` method in [Complex.java](Complex.java.html) so that
    it complex numbers in the traditional format. For example, it should print the
    value \(3-i\) as `3 - i` instead of `3.0 + -1.0i`, the value 3 as `3` instead
    of `3.0 + 0.0i` and the value \3i\) as `3i` instead of `0.0 + 3.0i`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 [Complex.java](Complex.java.html) 中的 `toString()` 方法，使复数以传统格式显示。例如，它应该将值
    \(3-i\) 打印为 `3 - i` 而不是 `3.0 + -1.0i`，将值 3 打印为 `3` 而不是 `3.0 + 0.0i`，将值 \(3i\)
    打印为 `3i` 而不是 `0.0 + 3.0i`。
- en: Write a `Complex` client [RootsOfUnity.java](RootsOfUnity.java.html) that takes
    two `double` values *a* and *b* and an integer *n* from the command line and prints
    the *n*th root of \(a + bi\).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `Complex` 客户端 [RootsOfUnity.java](RootsOfUnity.java.html)，从命令行接受两个 `double`
    值 *a* 和 *b* 以及一个整数 *n*，并打印 \(a + bi\) 的第 *n* 个根。
- en: 'Implement the following additions to [Complex.java](Complex.java.html):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 [Complex.java](Complex.java.html) 实现以下添加：
- en: '![Complex API](../Images/c92359ffac92729a3a79f962f56c7f79.png)'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![复数 API](../Images/c92359ffac92729a3a79f962f56c7f79.png)'
- en: Write a test client that exercises all of your methods.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个测试客户端来测试所有你的方法。
- en: 'Suppose you want to add a constructor to [Complex.java](Complex.java.html)
    that takes a `double` value as its argument and creates a `Complex` number with
    that value as the real part (and no imaginary part). You write the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你想要为 [Complex.java](Complex.java.html) 添加一个以 `double` 值作为参数的构造函数，并创建一个具有该值作为实部（没有虚部）的
    `Complex` 数字。你写下以下代码：
- en: '[PRE0]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But then the statement `Complex c = new Complex(1.0);` does not compile. Why?
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是语句 `Complex c = new Complex(1.0);` 却无法编译通过。为什么？
- en: '*Solution*: Constructors do not have return types, not even `void`. This code
    defines method named `Complex()`, not a constructor. Remove the keyword `void`.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：构造函数没有返回类型，甚至不是 `void`。这段代码定义了一个名为 `Complex()` 的方法，而不是构造函数。移除关键字 `void`。'
- en: Creative Exercises
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Electric potential visualization.** Write a program [Potential.java](Potential.java.html)
    that creates an array of charged particles from values given on standard input
    (each charged particle is specified by its *x*-coordinate, *y*-coordinate, and
    charge value) and produces a visualization of the electric potential in the unit
    square. To do so, sample points in the unit square. For each sampled point, compute
    the electric potential at that point (by summing the electric potentials due to
    each charged particle) and plot the corresponding point in a shade of gray proportional
    to the electric potential.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**电势可视化。** 编写一个程序 [Potential.java](Potential.java.html)，从标准输入中给定的值创建一个带电粒子数组（每个带电粒子由其
    *x* 坐���、*y* 坐标和电荷值指定），并在单位正方形中生成电势的可视化。为此，在单位正方形中采样点。对于每个采样点，计算该点的电势（通过对每个带电粒子的电势求和），并绘制与电势成比例的灰度点。'
- en: '| ![Electric potential](../Images/a596beb117fa57129e0ba62f47f0a960.png) |         
    | ![Electric potential](../Images/97f317b73b3b894557f451ea17b2b05b.png) |'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![电势](../Images/a596beb117fa57129e0ba62f47f0a960.png) |          | ![电势](../Images/97f317b73b3b894557f451ea17b2b05b.png)
    |'
- en: '**Quaternions.** In 1843, Sir William Hamilton discovered an extension to complex
    numbers called [quaternions](http://en.wikipedia.org/wiki/Quaternion). Quaternions
    extend the concept of rotation in three dimensions to four dimensions. They are
    used in computer graphics, control theory, signal processing, and orbital mechanics,
    e.g., command for spacecraft attitude control systems. are related to Pauli spin
    matrices in physics. Create a date type [Quaternion.java](Quaternion.java.html)
    to represent quaternions. Include operations for adding, multiplying, inverting,
    conjugating, and taking the norm of quaternions.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**四元数。** 在 1843 年，威廉·哈密尔顿爵士发现了一种称为[四元数](http://en.wikipedia.org/wiki/Quaternion)的复数扩展。四元数将三维空间中的旋转概念扩展到四维空间。它们被用于计算机图形学、控制理论、信号处理和轨道力学等领域，例如用于航天器姿态控制系统的指令。与物理学中的
    Pauli 自旋矩阵相关。创建一个数据类型 [Quaternion.java](Quaternion.java.html) 来表示四元数。包括四元数的加法、乘法、求逆、共轭和范数运算。'
- en: A quaternion can be represented by a 4-tuple of real numbers \((a_0, a_1, a_2,
    a_3)\), which represents \(a_0 + a_1 i + a_2 j + a_3 k\). The fundamental identity
    is \(i^2 = j^2 = k^2 = ijk = -1\).
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个四元数可以用实数四元组 \((a_0, a_1, a_2, a_3)\) 来表示，表示为 \(a_0 + a_1 i + a_2 j + a_3 k\)。其基本恒等式为
    \(i^2 = j^2 = k^2 = ijk = -1\)。
- en: '*Magnitude*: \( \left \| a \right \| = \sqrt{a_0^2 + a_1^2 + a_2^2 + a_3^2}
    \)'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大小*：\( \left \| a \right \| = \sqrt{a_0^2 + a_1^2 + a_2^2 + a_3^2} \)'
- en: '*Conjugate*: \( a^* = (a_0, -a_1, -a_2, -a_3)\)'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共轭*：\( a^* = (a_0, -a_1, -a_2, -a_3)\)'
- en: '*Inverse*: \( a^{-1} = (a_0\,/\, \left \| a \right \|^2, -a_1\,/\, \left \|
    a \right \|^2, -a_2\,/\, \left \| a \right \|^2, -a_3\,/\, \left \| a \right \|^2)\)'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*求逆*：\( a^{-1} = (a_0\,/\, \left \| a \right \|^2, -a_1\,/\, \left \| a \right
    \|^2, -a_2\,/\, \left \| a \right \|^2, -a_3\,/\, \left \| a \right \|^2)\)'
- en: '*Sum*: \( a + b = (a_0+b_0, a_1+b_1, a_2+b_2, a_3+b_3)\)'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*求和*：\( a + b = (a_0+b_0, a_1+b_1, a_2+b_2, a_3+b_3)\)'
- en: '*Hamilton product*: $$ \begin{align} a \times b \; = \; (& a_0b_0 - a_1b_1
    - a_2b_2 - a_3b_3, \\ & a_0b_1 + a_1b_0 + a_2b_3 - a_3b_2, \\ & a_0b_2 - a_1b_3
    + a_2b_0 + a_3b_1, \\ & a_0b_3 + a_1b_2 - a_2b_1 + a_3b_0) \end{align} $$'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈密顿积*：$$ \begin{align} a \times b \; = \; (& a_0b_0 - a_1b_1 - a_2b_2 - a_3b_3,
    \\ & a_0b_1 + a_1b_0 + a_2b_3 - a_3b_2, \\ & a_0b_2 - a_1b_3 + a_2b_0 + a_3b_1,
    \\ & a_0b_3 + a_1b_2 - a_2b_1 + a_3b_0) \end{align} $$'
- en: '*Quotient*: \( a\,/\,b = a^{-1} \times b \)'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*商*：\( a\,/\,b = a^{-1} \times b \)'
- en: '**Dragon curve.** Write a program [Dragon.java](Dragon.java.html) that reads
    in a command-line parameter N and plots the order N dragon curve using turtle
    graphics. The dragon curve was first discovered by three NASA physicists (John
    E. Heighway, Bruce A. Banks, and William G. Harter) and later popularized by Martin
    Gardner in Scientific American (March and April 1967) and Michael Crichton in
    Jurassic Park.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**龙曲线。** 编写一个程序 [Dragon.java](Dragon.java.html)，读取一个命令行参数 N，并使用海龟图形绘制 N 阶龙曲线。龙曲线最初由三位
    NASA 物理学家（约翰·E·海威、布鲁斯·A·班克斯和威廉·G·哈特）发现，后来由马丁·加德纳在《科学美国人》（1967 年 3 月和 4 月）和迈克尔·克莱顿在《侏罗纪公园》中推广。'
- en: '| ![](../Images/81ee727a661850b081b7679af8bdd73a.png) | ![](../Images/03e93069201391966134b4eb09d3248b.png)
    | ![](../Images/3ff5c50e41512c3684fa7ea4100e76d5.png) | ![](../Images/01a9c5a36526c304722111980f16e864.png)
    | ![](../Images/e5ebbee06be6f528a6da0067d5bf7f7a.png) |'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/81ee727a661850b081b7679af8bdd73a.png) | ![](../Images/03e93069201391966134b4eb09d3248b.png)
    | ![](../Images/3ff5c50e41512c3684fa7ea4100e76d5.png) | ![](../Images/01a9c5a36526c304722111980f16e864.png)
    | ![](../Images/e5ebbee06be6f528a6da0067d5bf7f7a.png) |'
- en: '| ![](../Images/1db7e0fabf47a6d39c0e1df7ad192192.png) | ![](../Images/a48b97a2698ba348ca3b13a96d9c802d.png)
    | ![](../Images/a5f0aea87050b0f8508a6103ae345ddd.png) | ![](../Images/94d0621825ae68f53df6ebff647b0eae.png)
    | ![](../Images/572e10ef9b03f31a0e075e73746dac23.png) |'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/1db7e0fabf47a6d39c0e1df7ad192192.png) | ![](../Images/a48b97a2698ba348ca3b13a96d9c802d.png)
    | ![](../Images/a5f0aea87050b0f8508a6103ae345ddd.png) | ![](../Images/94d0621825ae68f53df6ebff647b0eae.png)
    | ![](../Images/572e10ef9b03f31a0e075e73746dac23.png) |'
- en: This is a sophisticated program that uses two mutually recursive functions.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个使用两个相互递归函数的复杂程序。
- en: Program [SequentialDragon.java](SequentialDragon.java.html) is an iterative
    version of the dragon curve. It is a hacker's paradise.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序 [SequentialDragon.java](SequentialDragon.java.html) 是龙曲线的迭代版本。这是一个黑客的天堂。
- en: '**Hilbert curves.** A [space-filling curve](http://en.wikipedia.org/wiki/Space-filling_curve)
    is a continuous curve in the unit square that passes through every point. Write
    a recursive `Turtle` client [Hilbert.java](Hilbert.java.html) (or [SingleHilbert.java](SingleHilbert.java.html))
    that produces these recursive patterns, which approach a space-filling curve that
    was defined by the mathematician David Hilbert at the end of the 19th century.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**希尔伯特曲线。** [填充空间曲线](http://en.wikipedia.org/wiki/Space-filling_curve) 是一个连续的曲线，在单位正方形中通过每一点。编写一个递归的
    `Turtle` 客户端 [Hilbert.java](Hilbert.java.html)（或 [SingleHilbert.java](SingleHilbert.java.html)），生成这些递归模式，这些模式逼近数学家大卫·希尔伯特在
    19 世纪末定义的填充空间曲线。'
- en: '| ![Hilbert curve of order 1](../Images/23fe4e668b0c42845bb5867f9064676a.png)
    | ![Hilbert curve of order 2](../Images/9ed1814e6a5f61e393d35c2b67b46567.png)
    | ![Hilbert curve of order 3](../Images/b35c952f262ef5ab5c5d90fe93714844.png)
    | ![Hilbert curve of order 4](../Images/95b79850c82744d0501a0d9ab04893b0.png)
    | ![Hilbert curve of order 5](../Images/0870f275cf25dde98d565ea16ea2a3ef.png)
    |'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![一阶希尔伯特曲线](../Images/23fe4e668b0c42845bb5867f9064676a.png) | ![二阶希尔伯特曲线](../Images/9ed1814e6a5f61e393d35c2b67b46567.png)
    | ![三阶希尔伯特曲线](../Images/b35c952f262ef5ab5c5d90fe93714844.png) | ![四阶希尔伯特曲线](../Images/95b79850c82744d0501a0d9ab04893b0.png)
    | ![五阶希尔伯特曲线](../Images/0870f275cf25dde98d565ea16ea2a3ef.png) |'
- en: '**Gosper island.** Write a recursive `Turtle` client [GosperIsland.java](GosperIsland.java.html)
    that produces these recursive patterns.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高斯波岛。** 编写一个递归的 `Turtle` 客户端 [GosperIsland.java](GosperIsland.java.html)，生成这些递归模式。'
- en: '| ![](../Images/32977d4584a6bac5f9f1d4b31dde447c.png) | ![](../Images/31c0a3824f79b7a56d2053b63a6be627.png)
    | ![](../Images/52613bd251649fa1c2d9c31345764f63.png) | ![](../Images/476c882a963f78d9e883a73ddccae5a9.png)
    | ![](../Images/addc9cb23707030811a90c97d0325bbb.png) |'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/32977d4584a6bac5f9f1d4b31dde447c.png) | ![](../Images/31c0a3824f79b7a56d2053b63a6be627.png)
    | ![](../Images/52613bd251649fa1c2d9c31345764f63.png) | ![](../Images/476c882a963f78d9e883a73ddccae5a9.png)
    | ![](../Images/addc9cb23707030811a90c97d0325bbb.png) |'
- en: '**Chaos with Newton''s method.** The polynomial \(f(z) = z^4 - 1\) has 4 roots
    at 1, −1, *i*, and −*i*. We can find the roots using Newton''s method in the complex
    plane: \(z_{k+1} = z_k - f(z_k) \,/ \, f''(z_k)\). Here \(f(z) = z^4 - 1\) and
    \(f''(z) = 4z^3\). The method converges to one of the 4 roots depending on the
    starting point \(z_0\). Write a program [NewtonChaos.java](NewtonChaos.java.html)
    that takes a command-line argument *n* and creates an *n*-by-*n* image corresponding
    to the square of size 2 centered at the origin. Color each pixel white, red, green,
    or blue according to which of the four roots the corresponding complex number
    converges (black if no convergence after 100 iterations).'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用牛顿法混沌。** 多项式 \(f(z) = z^4 - 1\) 在 1, −1, *i*, 和 −*i* 处有 4 个根。我们可以在复平面上使用牛顿法找到这些根：\(z_{k+1}
    = z_k - f(z_k) \,/ \, f''(z_k)\)。这里 \(f(z) = z^4 - 1\)，\(f''(z) = 4z^3\)。该方法收敛到
    4 个根中的一个，取决于起始点 \(z_0\)。编写一个程序 [NewtonChaos.java](NewtonChaos.java.html)，接受一个命令行参数
    *n*，并创建一个以原点为中心、边长为 2 的正方形的 *n*×*n* 图像。根据相应复数收敛到的四个根中的哪一个，将每个像素着色为白色、红色、绿色或蓝色（如果经过
    100 次迭代后仍未收敛，则为黑色）。'
- en: '![Newton''s method chaos](../Images/359f33aa29c7f8b01efd08ddd5b25305.png)'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![牛顿法混沌](../Images/359f33aa29c7f8b01efd08ddd5b25305.png)'
- en: '**Color Mandelbrot plot.** Create a file of 256 integer triples that represent
    interesting `Color` values, and then use those colors instead of grayscale values
    to plot each pixel in [ColorMandelbrot.java](ColorMandelbrot.java.html) Read the
    values to create an array of 256 `Color` values, then index into that array with
    the return value of `mand()`. By experimenting with various color choices at various
    places in the set, you can produce astonishing images. See [mandel.txt](mandel.txt)
    for an example.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**彩色曼德勃罗特图。** 创建一个包含 256 个整数三元组的文件，表示有趣的`Color`值，然后使用这些颜色而不是灰度值来绘制[ColorMandelbrot.java](ColorMandelbrot.java.html)中的每个像素。读取这些值以创建一个包含
    256 个`Color`值的数组，然后使用`mand()`的返回值索引到该数组中。通过在集合的各个位置尝试不同的颜色选择，您可以产生令人惊叹的图像。参见[mandel.txt](mandel.txt)以获取示例。'
- en: '| ![Mandelbrot set](../Images/23977aa3271cc34dbaadd6350988a712.png) |          
    | ![Mandelbrot set](../Images/c5a34b473933eb0aa308a2c9545e151a.png) |'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![曼德勃罗特集](../Images/23977aa3271cc34dbaadd6350988a712.png) |           | ![曼德勃罗特集](../Images/c5a34b473933eb0aa308a2c9545e151a.png)
    |'
- en: '| `-1.5 -1.0 2.0 2.0` |  | `0.10259 -0.641 0.0086 0.0086` |'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| `-1.5 -1.0 2.0 2.0` |  | `0.10259 -0.641 0.0086 0.0086` |'
- en: '**Julia sets.** The *Julia set* for a given complex number *c* is a set of
    points related to the Mandelbrot function. Instead of fixing *z* and varying *c*,
    we fix *c* and vary *z*. Those points *z* for which the modified Mandelbrot function
    stays bounded are in the Julia set; those for which the sequence diverges to infinity
    are not in the set. All points *z* of interest lie in the 4-by-4 box centered
    at the origin. The Julia set for *c* is connected if and only if *c* is in the
    Mandelbrot set! Write a program [ColorJulia.java](ColorJulia.java.html) that takes
    two command-line arguments *a* and *b*, and plots a color version of the Julia
    set for *c* = *a* + *bi*, using the color-table method described in the previous
    exercise.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**朱利亚集。** 对于给定复数 *c*，*朱利亚集*是与曼德勃罗特函数相关的一组点。我们不是固定 *z* 并变化 *c*，而是固定 *c* 并变化
    *z*。那些修改后的曼德勃罗特函数保持有界的点 *z* 属于朱利亚集；那些序列发散到无穷大的点 *z* 不属于该集合。所有感兴趣的点 *z* 都位于以原点为中心的
    4x4 方框内。对于 *c* 的朱利亚集是连通的，当且仅当 *c* 在曼德勃罗特集中时！编写一个程序[ColorJulia.java](ColorJulia.java.html)，它接受两个命令行参数
    *a* 和 *b*，并使用前面练习中描述的颜色表方法绘制 *c* = *a* + *bi* 的朱利亚集的彩色版本。'
- en: '| ![Julia set](../Images/238f5f2bd3de34977d6ac08f9fc8573a.png) |          
    | ![Julia set](../Images/f57ab7f72aebc677652e135ef9e15333.png) |'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![Julia set](../Images/238f5f2bd3de34977d6ac08f9fc8573a.png) |          
    | ![Julia set](../Images/f57ab7f72aebc677652e135ef9e15333.png) |'
- en: '| `-1.25 0.00` |  | `-0.75 0.10` |'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| `-1.25 0.00` |  | `-0.75 0.10` |'
- en: Web Exercises
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习
- en: '**IP addresses.** Create a data type for IPv4 (Internet Protocol, version 4)
    addresses. An IP address is a 32-bit integer.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**IP 地址。** 创建一个用于 IPv4（互联网协议第 4 版）地址的数据类型。IP 地址是一个 32 位整数。'
- en: '**Dates.** Create a data type `Date` that represents a date. You should be
    able to create a new `Date` by specifying the month, day, and year. It should
    supports methods to compute the number of days between two dates, return the day
    of the week that a day falls on, etc.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日期。** 创建一个表示日期的数据类型`Date`。您应该能够通过指定月、日和年来创建一个新的`Date`。它应该支持计算两个日期之间的天数、返回一天落在星期几的方法等。'
- en: '**Time bombs.** UNIX represents the date with a signed integer measuring the
    number of seconds since January 1, 1970. Write a client program to calculate when
    this date will occur. Add a static method `add(Date d, int days)` to your date
    data type that returns a new date which is the specified number of days after
    the date d. Note that there are 86,400 seconds in a day.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定时炸弹。** UNIX 用一个有符号整数表示自 1970 年 1 月 1 日以来的秒数来表示日期。编写一个客户端程序来计算这个日期将发生的时间。在您的日期数据类型中添加一个静态方法`add(Date
    d, int days)`，返回日期 d 之后指定天数的新日期。请注意，一天有 86,400 秒。'
- en: '**Qubits.** In quantum computing, a *qubit* plays the role of a bit. It is
    a complex number a + bi such that |a + bi| = 1\. Once we measure a qubit, it "decides"
    to be a 1 with probability a² and a 0 with probability b². Any subsequent observations
    will always yield the same value. Implement a data type `Qubit` that has a constructor
    `Qubit(a, b)` and a boolean method `observe` that returns `true` or `false` with
    the proscribed probabilities.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**量子位。** 在量子计算中，*量子位*扮演位的角色。它是一个复数 a + bi，使得|a + bi| = 1。一旦我们测量一个量子位，它就会以概率
    a² 成为 1，以概率 b² 成为 0。任何后续的观察都将始终产生相同的值。实现一个数据类型`Qubit`，它具有一个构造函数`Qubit(a, b)`和一个布尔方法`observe`，根据规定的概率返回`true`或`false`。'
- en: '**Biorhythms.** A *biorhythm* is a pseudo-scientific profile of the three natural
    cycles of your body: physical (23 days), emotional (28 days), and intellectual
    (31 days). Write a program that takes six command line inputs M, D, Y, m, d, and
    y where (M, D, Y) is the month (1-12), day (1-31), and year (1900-2100) of your
    birthday and (m, d, y) is today''s month, day, and year. It should then print
    out your biorhythm on a scale of -1.0 to 1.0 according to the formula: sin (2
    π age / cycle length). Use the date data type created in the previous exercise.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生物节律。** *生物节��*是您身体的三个自然周期的伪科学概况：身体（23 天）、情绪（28 天）和智力（31 天）。编写一个程序，接受六个命令行输入
    M、D、Y、m、d 和 y，其中 (M、D、Y) 是您的生日的月份（1-12）、日期（1-31）和年份（1900-2100），而 (m、d、y) 是今天的月份、日期和年份。然后根据公式：sin
    (2 π 年龄 / 周期长度) 在 -1.0 到 1.0 的范围内打印出您的生物节律。使用前面练习中创建的日期数据类型。'
- en: '**Particle.** Create a data type for elementary or composite particles (electron,
    proton, quark, photon, atom, molecule). Each particle should have an instance
    variable to store its name, its mass, its charge, and its spin (multiple of 1/2).'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**粒子。** 创建一个用于基本或复合粒子（电子、质子、夸克、光子、原子、分子）的数据类型。每个粒子应该有一个实例变量来存储其名称、质量、电荷和自旋（1/2
    的倍数）。'
- en: '**Quark.** Quarks are the smallest known building blocks of matter. Create
    a data type for quarks. Include a field for its type (up, down, charm, strange,
    top, or bottom) and its color (red, green, or blue). The charges are +2/3, -1/3,
    +2/3, -1/3, +2/3, -1/3, respectively. All have spin 1/2.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**夸克。** 夸克是已知的物质最小的基本构建块。创建一个用于夸克的数据类型。包括一个字段用于其类型（上夸克、下夸克、魅夸克、奇夸克、顶夸克或底夸克）和其颜色（红色、绿色或蓝色）。其电荷分别为
    +2/3、-1/3、+2/3、-1/3、+2/3、-1/3。所有夸克的自旋都是 1/2。'
- en: '**Biorhythms.** Plot your biorhythm in turtle graphics over a 6 week interval.
    Identify *critical days* when your rhythm goes from positive to negative - according
    to biorhythm theory, this is when you are most prone to accident, instability,
    and error.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生物节律.** 在一个为期 6 周的时间间隔内，使用海龟图形绘制你的生物节律。识别*临界日*，即你的节律从正向负转变的日子 - 根据生物节律理论，这是你最容易发生事故、不稳定和出错的时候。'
- en: '**Vector3.** Include normal vector operations for 3-vectors, including *cross
    product*. The cross product of two vectors is another vector. a cross b = ||a||
    ||b|| sin(theta) n, where theta is angle between a and b, and n is unit normal
    vector perpendicular to both a and b. (a[1], a[2], a[3]) cross (b[1], b[2], b[3])
    = (a[2] b[3] - a[3] b[2], a[3] b[1] - a[1] b[3], a[1] b[2] - a[2] b[1]). Note
    that |a cross b| = area of the parallelogram with sides a and b. Cross product
    arises in definition of torque, angular momentum and vector operator curl.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Vector3.** 包括三维向量的法线向量运算，包括*叉乘*。两个向量的叉乘是另一个向量。a 叉乘 b = ||a|| ||b|| sin(theta)
    n，其中 theta 是 a 和 b 之间的角度，n 是垂直于 a 和 b 的单位法线向量。 (a[1], a[2], a[3]) 叉乘 (b[1], b[2],
    b[3]) = (a[2] b[3] - a[3] b[2], a[3] b[1] - a[1] b[3], a[1] b[2] - a[2] b[1])。注意
    |a 叉乘 b| = 以 a 和 b 为边的平行四边形的面积。叉乘在力矩、角动量和向量算子旋度的定义中出现。'
- en: '**Four-vector.** Create a data type for [four-vectors](http://en.wikipedia.org/wiki/Four-vector).
    A four-vector is a four-dimensional vector (t, x, y, z) subject to Lorentz transformations.
    Useful in special relativity.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**四维矢量.** 创建一个数据类型用于[四维矢量](http://en.wikipedia.org/wiki/Four-vector)。四维矢量是一个四维向量
    (t, x, y, z)，受洛伦兹变换的约束。在狭义相对论中很有用。'
- en: '**Euclidean points.** Create a data type `EuclideanPoint.java` that represents
    a d-dimensional point. Include a method so that `p.distanceTo(q)` returns the
    Euclidean distance between points p and q.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**欧几里德点.** 创建一个名为 `EuclideanPoint.java` 的数据类型，表示一个 d 维点。包括一个方法，使得 `p.distanceTo(q)`
    返回点 p 和 q 之间的欧几里德距离。'
- en: '**Vector field.** A [vector field](http://en.wikipedia.org/wiki/Vector_field)
    associates a vector with every point in a Euclidean space. Widely used in physics
    to model speed and direction of a moving object or or strength and direction of
    a Newtonian force.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**矢量场.** [矢量场](http://en.wikipedia.org/wiki/Vector_field) 将一个向量与欧几里德空间中的每个点相关联。在物理学中广泛用于模拟运动物体的速度和方向，或者牛顿力的强度和方向。'
- en: '**Soda machine.** Create a data type `SodaMachine` that has methods `insertCoin()`,
    `getChange()`, `buy()`, etc.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**饮料机.** 创建一个名为 `SodaMachine` 的数据类型，其中包括 `insertCoin()`、`getChange()`、`buy()`
    等方法。'
- en: '**Months.** Write a data type `Month` that represents one of the twelve months
    of the year. It should have fields for the name of the month, the number of days
    in the month, and the birthstone.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**月份.** 编写一个数据类型 `Month`，表示一年中的十二个月之一。它应该包括月份名称、月份天数和诞生石的字段。'
- en: '| MONTH | DAYS | BIRTHSTONE |'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 月份 | 天数 | 诞生石 |'
- en: '| January | 31 | Garnet |'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 一月 | 31 | 石榴石 |'
- en: '| February | 28 | Amethyst |'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 二月 | 28 | 紫水晶 |'
- en: '| March | 31 | Aquamarine |'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 三月 | 31 | 海蓝宝石 |'
- en: '| April | 30 | Diamond |'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 四月 | 30 | 钻石 |'
- en: '| May | 31 | Emerald |'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 五月 | 31 | 翡翠 |'
- en: '| June | 30 | Alexandrite |'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 六月 | 30 | 紫翠石 |'
- en: '| July | 31 | Ruby |'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 七月 | 31 | 红宝石 |'
- en: '| August | 31 | Peridot |'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 八月 | 31 | 橄榄石 |'
- en: '| September | 30 | Sapphires |'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 九月 | 30 | 蓝宝石 |'
- en: '| October | 31 | Opal |'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 十月 | 31 | 蛋白石 |'
- en: '| November | 30 | Topaz |'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 十一月 | 30 | 黄玉 |'
- en: '| December | 31 | Blue Zircon |'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 十二月 | 31 | 蓝锆石 |'
- en: '**Gauss multiplication.** Implement complex multiplication using only 3 floating
    point multiplications (instead of 4). You may use as many as 5 floating point
    additions. *Answer*: Gauss gave the following method to multiply (a + bi)(c +
    di). Set x1 = (a + b)(c + d), x2 = ac, x3 = bd. Then the product is given by x
    + yi where x = x2 - x3, y = x1 - x2 - x3.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高斯乘法.** 使用仅 3 次浮点乘法（而不是 4 次）实现复数乘法。你可以使用多达 5 次浮点加法。 *答案*: 高斯给出了以下方法来计算 (a
    + bi)(c + di)。设 x1 = (a + b)(c + d)，x2 = ac，x3 = bd。那么乘积为 x + yi，其中 x = x2 - x3，y
    = x1 - x2 - x3。'
- en: '**Tensors.** Create a data type for [tensors](http://en.wikipedia.org/wiki/Tensor).'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**张量.** 创建一个数据类型用于[张量](http://en.wikipedia.org/wiki/Tensor)。'
- en: '**UN Countries.** Create a data type `Country` for [UN countries](../data/countries.csv).
    Include fields for 3 digit UN Code, 3 letter ISO abbreviation, country name, and
    capital. Write a program [Country.java](Country.java.html) that reads in a list
    of countries and stores them in an array of type `Country`. Use the method `String.split`
    to help parse the input file.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**联合国国家.** 为[联合国国家](../data/countries.csv)创建一个名为 `Country` 的数据类型。包括 3 位联合国代码、3
    个字母 ISO 缩写、国家名称和首都的字段。编写一个程序 [Country.java](Country.java.html)，读取国家列表并将它们存储在类型为
    `Country` 的数组中。使用方法 `String.split` 来帮助解析输入文件。'
- en: '**Area codes.** Create a data type for [telephone area codes in North America](../data/phone-na.csv).
    Include fields for the area code, the city, and state, and the two letter state
    abbreviation. Or for [international phone codes](../data/phone-international.csv).
    Include a field for zone, code, and country.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**区号.** 为[北美电话区号](../data/phone-na.csv)创建一个数据类型。包括区号、城市和州名以及两个字母的州缩写。或者为[国际电话区号](../data/phone-international.csv)创建一个数据类型。包括区域、代码和国家的字段。'
- en: '**Congressional districts.** Create a data type for places, counties, and congressional
    districts. Include fields for place name, county name, county code, zip code,
    congressional district, etc. Use the data sets from the [1998 FIPS55-DC3 Index](http://www.itl.nist.gov/fipspubs/55new/nav-top-fr.htm):
    Pennsylvania [(2MB)](../data/fips55-pa.txt) or all 50 states plus DC and 9 outlying
    areas [(30MB)](../data/fips55-all.txt).'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**国会选区.** 为地点、县和国会选区创建一个数据类型。包括地点名称、县名、县代码、邮政编码、国会选区等字段。使用来自[1998 FIPS55-DC3
    索引](http://www.itl.nist.gov/fipspubs/55new/nav-top-fr.htm)的数据集：宾夕法尼亚 [(2MB)](../data/fips55-pa.txt)
    或所有 50 个州加上哥伦比亚特区和 9 个外围地区 [(30MB)](../data/fips55-all.txt)。'
- en: '**Latitudes and longitudes.** For USA latitudes and longitudes, use the [TIGER
    database](http://www.census.gov/geo/www/tiger/) or [www.bcca.org](http://www.bcca.org/misc/qiblih/latlong_us.html)
    or [gazetteer](http://geonames.usgs.gov/stategaz/index.html). For the rest of
    the world, use [earth-info](http://earth-info.nima.mil/gns/html/cntry_files.html).'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**纬度和经度。** 对于美国的纬度和经度，使用[TIGER数据库](http://www.census.gov/geo/www/tiger/)或[www.bcca.org](http://www.bcca.org/misc/qiblih/latlong_us.html)或[地名数据库](http://geonames.usgs.gov/stategaz/index.html)。对于世界其他地区，请使用[earth-info](http://earth-info.nima.mil/gns/html/cntry_files.html)。'
- en: '**Astronomy**. Data for [asteroids](../data/asteroids.csv), [meteors](../data/meteors.csv),
    and [comets](../data/comets.csv).'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**天文学**。有关[小行星](../data/asteroids.csv)、[流星](../data/meteors.csv)和[彗星](../data/comets.csv)的数据。'
- en: '**Fortune 1000 companies.** Create a data type the for [Fortune 1000](../data/fortune1000.csv).
    Include fields for company name and sales revenue in millions of dollars. Data
    taken from April 15, 2002 issue of Fortune. Note: currently need to parse data.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**财富1000强公司。** 创建一个数据类型，用于[财富1000强](../data/fortune1000.csv)。包括公司名称和以百万美元计的销售收入字段。数据取自2002年4月15日《财富》杂志。注意：目前需要解析数据。'
- en: '**Molecular weight.** Write a program so that the user enters a molecule H2
    O and the program calculates its molecular weight.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分子量。** 编写一个程序，用户输入一个分子H2 O，程序计算其分子量。'
- en: 'Some potentially useful datafiles: [aroma therapies](../data/aroma-therapy.txt),
    [nutritional information](../data/calories.csv), [meteorological glossary](../data/meteorological-glossary.txt),
    [psychiatric disorders](../data/psychiatric.csv), [words translated in 15 languages](../data/language.csv),
    [dictionary of emoticons](../data/emoticons.txt), [meanings of common names](../data/names.csv),
    [World Almanac facts about countries](../data/world98.txt).'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些可能有用的数据文件：[芳香疗法](../data/aroma-therapy.txt)、[营养信息](../data/calories.csv)、[气象术语词汇表](../data/meteorological-glossary.txt)、[精神疾病](../data/psychiatric.csv)、[15种语言翻译的单词](../data/language.csv)、[表情符号词典](../data/emoticons.txt)、[常见名字的含义](../data/names.csv)、[世界年鉴关于国家的事实](../data/world98.txt)。
- en: '**Student records.** Create a data type [Student.java](Student.java.html) to
    represent students in an introductory computer science course. Each student record
    object should represent a first name, last name, email address, and section number.
    Include a `toString()` method that returns a string representation of a student
    and a `less()` method that compares two students by section number.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**学生记录。** 创建一个数据类型[Student.java](Student.java.html)来表示初级计算机科学课程中的学生。每个学生记录对象应表示名字、姓氏、电子邮件地址和分组号。包括一个`toString()`方法，返回学生的字符串表示形式，以及一个`less()`方法，通过分组号比较两个学生。'
- en: '**Impedance.** Impedance is the generalization of resistance from DC circuits
    to AC circuits. In an AC circuit, the *impedance* of a component measures its
    opposition to the flow of electrons at a given frequency ω. The impedance has
    two components: the resistance and the reactance. The *resistance* R of a circuit
    component measures its opposition to the movement of electrons (friction against
    motion of electrons) when a given voltage is applied. The *reactance* X of a circuit
    component measures its ability to store and release energy as the current and
    voltage fluctuate (inertia against motion of electrons).'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**阻抗。** 阻抗是从直流电路到交流电路的电阻的概括。在交流电路中，组件的*阻抗*测量其在给定频率ω下对电子流动的阻力。阻抗有两个组成部分：电阻和电抗。电路组件的*电阻*
    R 测量其在给定电压下对电子运动的阻力（对电子运动的摩擦）。电路组件的*电抗* X 测量其在电流和电压波动时存储和释放能量的能力（对电子运动的惯性）。'
- en: In circuits with resistors only, the current is directly proportional to the
    voltage. However, with capacitors and inductors, there is a +- 90 degree "phase
    shift" between the current and voltage. This means that when the voltage wave
    is at its maximum, the current is 0, and when the current is at its maximum the
    voltage is 0\. To unify the treatment of resistors (R), inductors (L), and capacitors
    (C) it is convenient to treat the impedance as the complex quantity Z = R + iX.
    the impedance of an inductor is iwL and the impedance of a capacitor is 1/iwC.
    To determine the impedance of a sequence of circuit elements in series, we simply
    add up their individual impedances. Two important quantities in electrical engineering
    are the*magnitude of the impedance* and the *phase angle*. The magnitude is the
    ratio of the RMS voltage to the RMS current - it equals the magnitude of the complex
    impedance. The *phase angle* is the amount by which the voltage leads or lags
    the current - it is the phase of the complex impedance. Program [CircuitRLC.java](CircuitRLC.java.html)
    does a computation involving complex numbers and impedance of circuits with resistors,
    inductors, and capacitors in series.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在仅有电阻的电路中，电流与电压成正比。然而，对于电容器和电感器，电流和电压之间存在+- 90度的“相位移”。这意味着当电压波达到最大值时，电流为0，当电流达到最大值时，电压为0。为了统一对电阻（R）、电感（L）和电容（C）的处理，方便起见，将阻抗视为复数Z
    = R + iX。电感器的阻抗是iwL，电容器的阻抗是1/iwC。要确定串联电路元件的阻抗，只需将它们各自的阻抗相加即可。电气工程中的两个重要量是*阻抗的大小*和*相位角度*。大小是RMS电压与RMS电流的比值
    - 它等于复阻抗的大小。*相位角度*是电压领先或滞后于电流的量 - 它是复阻抗的相位。程序[CircuitRLC.java](CircuitRLC.java.html)进行了涉及复数和串联电阻、电感和电容电路的阻抗的计算。
- en: 'Exercise: RLC circuit in parallel. 1/Z = 1/Z1 + 1/Z2 + ... 1/Zn.'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：并联RLC电路。1/Z = 1/Z1 + 1/Z2 + ... 1/Zn。
- en: 'Exercise (for objects): repeat series-parallel network for RLC circuits with
    impedances instead of resistance'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习（针对对象）：重复使用阻抗而不是电阻的RLC电路的串并联网络
- en: '**Diffusion of particles in a fluid.** Simulate diffusion of particles in a
    fluid. See [BrownianParticle.java](../98simulation/BrownianParticle.java.html)
    in Section 9.8.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**粒子在流体中的扩散。** 模拟流体中粒子的扩散。参见第9.8节中的[BrownianParticle.java](../98simulation/BrownianParticle.java.html)。'
- en: '**Electric field lines.** Michael Faraday introduced an abstraction called
    *electric field lines* to visualize the electric field. By Coulombs law, the electric
    field at a point induced by a point charge q[i] is given by E[i] = k q[i] / r²,
    and the direction points to q[i] if q[i] is negative and away from q[i] it is
    positive. If there are a group of n point charges, the electric field at a point
    is the *vector sum* of the electric fields induced by the n individual point charges.
    We can compute it by summing up the components in the x- and y- directions. The
    figure below illustrates the field lines for two equal positive point charges
    (left) and two point charges of opposite signs (right). The second configuration
    is called an *electric dipole*: the charges cancel each other out, and the electric
    field weakens very quickly as you move away from the charges. Examples of dipoles
    can be found in molecules where charge is not evenly distributed. Oscillating
    dipoles can be used to produce electromagnetic waves to transmit radio and television
    signals.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**电场线。** 迈克尔·法拉第引入了一种称为*电场线*的抽象概念来可视化电场。根据库仑定律，由点电荷q[i]诱导的点处的电场为E[i] = k q[i]
    / r²，方向指向q[i]如果q[i]为负，远离q[i]如果为正。如果有一组n个点电荷，点处的电场是n个单个点电荷诱导的电场的*矢量和*。我们可以通过在x和y方向上求和分量来计算它。下图说明了两个相等正点电荷（左）和两个异号点电荷（右）的场线。第二种配置称为*电偶极*：电荷互相抵消，当您远离电荷时，电场迅速减弱。电偶极的例���可以在电荷分布不均匀的分子中找到。振荡的电偶极可用于产生电磁波以传输无线电和电视信号。'
- en: '| ![Electric potential](../Images/4ef2d45ba2ce902dd57c4109d87fa6fd.png) |         
    | ![Electric potential](../Images/70e0801a736ba3f60cdd881a550e122c.png) |'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![电势](../Images/4ef2d45ba2ce902dd57c4109d87fa6fd.png) |          | ![电势](../Images/70e0801a736ba3f60cdd881a550e122c.png)
    |'
- en: Program [FieldLines.java](FieldLines.java.html) draws 10 electric field lines
    coming out of each charge. (We take some liberties since traditionally the number
    of field lines per unit area should be proportional to the magnitude of the field
    strength.) Each line starts on a 1-pixel circle around the charge, at twelve equally
    spaced angles. The electric field at a point (x, y) from a point charge q[i] is
    given by E[i] = k q[i] / r², where q[i] is the magnitude of the charge i and r
    is the radial distance from it. The field due to several charges is the vector
    sum of the field due to each, and can be found by adding the x- and y-components.
    After calculating the electric field strength, we move in the direction of the
    vector field and draws a spot. We repeat this process until we reach the boundary
    of the region or another point charge. The figures below illustrate the electric
    potential and field lines for several random charges of equal magnitude.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序[FieldLines.java](FieldLines.java.html)绘制出每个电荷发出的10条电场线。（我们稍微取了些自由，因为传统上单位面积上的电场线条数应该与电场强度的大小成比例。）每条线从电荷周围的一个1像素圆圈开始，以十二等分角度开始。从点电荷q[i]到点(x,
    y)处的电场由E[i] = k q[i] / r²给出，其中q[i]是电荷i的大小，r是到它的径向距离。由几个电荷产生的电场是每个电场的矢量和，可以通过添加x和y分量来找到。计算电场强度后，我们沿着矢量场的方向移动并绘制一个点。我们重复这个过程，直到到达区域边界或另一个点电荷。下面的图示说明了几个相等大小的随机电荷的电势和电场线。
- en: '| ![Electric potential and field lines](../Images/2ef4ae5e4e65a367bf5970f33b9c5015.png)
    |          | ![Electric potential and field lines](../Images/0e67861b77729800af30233b4d750aae.png)
    |          | ![Electric potential and field lines](../Images/87aad6b36c49205594ead19f92777871.png)
    |'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![电势和电场线](../Images/2ef4ae5e4e65a367bf5970f33b9c5015.png) |          | ![电势和电场线](../Images/0e67861b77729800af30233b4d750aae.png)
    |          | ![电势和电场线](../Images/87aad6b36c49205594ead19f92777871.png) |'
- en: '**Koch snowflake with rainbow of colors.**'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**彩虹色的科赫雪花。**'
- en: The *Koch snowflake* of order n consists of three copies of the Koch curve of
    over n. We draw the three Koch curves one after the other, but rotate 120° clockwise
    in between. Below are the Koch snowflakes of order 0, 1, 2, and 3. Write a program
    [KochRainbow.java](KochRainbow.java.html) that plots the Koch snowflake in a continuous
    spectrum of colors from red, to orange, yellow, green, blue, and indigo, and violet.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*第n阶科赫雪花*由三个复制的阶数为n的科赫曲线组成。我们依次绘制这三条科赫曲线，但在它们之间顺时针旋转120°。下面是阶数为0、1、2和3的科赫雪花。编写一个程序[KochRainbow.java](KochRainbow.java.html)，以连续的彩虹色谱从红色到紫色绘制科赫雪花。'
- en: '| ![Koch Snowflake](../Images/873ee77813f59e266cd8c27dd948ef2e.png) | ![Koch
    Snowflake](../Images/e6ae52c75a1535f89f2c176a8df3880c.png) | ![Koch Snowflake](../Images/43e26f8b81aedee055ef31363296e064.png)
    | ![Koch Snowflake](../Images/17a35db785294a7eac10e2e404de80bd.png) | ![Koch Snowflake](../Images/4274183a89bc08f45a45bb113a8504f5.png)
    |'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![科赫雪花](../Images/873ee77813f59e266cd8c27dd948ef2e.png) | ![科赫雪花](../Images/e6ae52c75a1535f89f2c176a8df3880c.png)
    | ![科赫雪花](../Images/43e26f8b81aedee055ef31363296e064.png) | ![科赫雪花](../Images/17a35db785294a7eac10e2e404de80bd.png)
    | ![科赫雪花](../Images/4274183a89bc08f45a45bb113a8504f5.png) |'
- en: '**Anti-Koch snowflakes.** The *anti-Koch snowflake* is generated exactly like
    the Koch snowflake, except that clockwise and counterclockwise are interchanged.
    Write a program `AntiKoch.java` that takes a command line parameter N and plots
    the anti-Koch snowflake of order N using Turtle graphics.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反向科赫雪花。** *反向科赫雪花*的生成方式与科赫雪花完全相同，只是顺时针和逆时针互换。编写一个名为`AntiKoch.java`的程序，接受一个命令行参数N，并使用Turtle图形绘制阶数为N的反向科赫雪花。'
- en: '| ![](../Images/c8d929c8924ce9d0ac29888bc4a6e783.png) | ![](../Images/cbc6ba9b6d720c63305f273f74d875ba.png)
    | ![](../Images/bd24d0d8beff6a41e23b8121a2630418.png) | ![](../Images/1614d81c1c50aa3dd31b3769cc26ec8c.png)
    | ![](../Images/6dc36e2ca7d24ae79366858e741c651f.png) |'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![](../Images/c8d929c8924ce9d0ac29888bc4a6e783.png) | ![](../Images/cbc6ba9b6d720c63305f273f74d875ba.png)
    | ![](../Images/bd24d0d8beff6a41e23b8121a2630418.png) | ![](../Images/1614d81c1c50aa3dd31b3769cc26ec8c.png)
    | ![](../Images/6dc36e2ca7d24ae79366858e741c651f.png) |'
- en: '**Randomized Koch snowflakes.** A *randomized Koch snowflake* is generated
    exactly like the Koch snowflake, except that we flip a coin to generate the clockwise
    and counterclockwise direction at each step.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机科赫雪花。** 生成一个*随机科赫雪花*，与科赫雪花完全相同，只是我们在每一步翻转硬币以生成顺时针和逆时针方向。 '
- en: '**Turtle graphics.**'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**海龟图形。**'
- en: '*Minkowski sausage.* ([Sausage.java](Sausage.java.html))'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*明科夫香肠。* ([Sausage.java](Sausage.java.html))'
- en: '| ![](../Images/068546ef39f48ff2b6918fb93f4475d2.png) | ![](../Images/aa6ce2687f8239eea4594e97cd48d3a9.png)
    | ![](../Images/e6b6a591e5ae6af0df139ac6125492bf.png) | ![](../Images/9913a3d1eacbd7d7361b8ddd3814e5ab.png)
    | ![](../Images/86773831140162a253758973889854f1.png) |'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/068546ef39f48ff2b6918fb93f4475d2.png) | ![](../Images/aa6ce2687f8239eea4594e97cd48d3a9.png)
    | ![](../Images/e6b6a591e5ae6af0df139ac6125492bf.png) | ![](../Images/9913a3d1eacbd7d7361b8ddd3814e5ab.png)
    | ![](../Images/86773831140162a253758973889854f1.png) |'
- en: '*Cesaro broken square.*'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Cesaro破碎的正方形。*'
- en: '| ![](../Images/5f8b83fa3d790f4dbc9f4066f6ddad9e.png) | ![](../Images/5ca548856f8c6ef9760e04cd12751d1b.png)
    | ![](../Images/e1c3a9729636b3aba0a6fc3317367d9d.png) | ![](../Images/6b7d3099519cfbd2bce4b7c6a6a2aff0.png)
    | ![](../Images/ec89b834b9bc0c4f5462b37505e0fde3.png) |'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/5f8b83fa3d790f4dbc9f4066f6ddad9e.png) | ![](../Images/5ca548856f8c6ef9760e04cd12751d1b.png)
    | ![](../Images/e1c3a9729636b3aba0a6fc3317367d9d.png) | ![](../Images/6b7d3099519cfbd2bce4b7c6a6a2aff0.png)
    | ![](../Images/ec89b834b9bc0c4f5462b37505e0fde3.png) |'
- en: '**More turtle graphics.** Write a program to produce each of the following
    recursive patterns.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更多海龟图形。** 编写一个程序来生成以下每个递归图案。'
- en: '*Levy tapestry.* ([Levy.java](Levy.java.html))'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*莱维织物。* ([Levy.java](Levy.java.html))'
- en: '| ![](../Images/21997b00f9237133b8841a742ecbc3f1.png) | ![](../Images/86c64691927f955c72a5955ccf3b8f02.png)
    | ![](../Images/f5e837baad0b1b78d3cf5117b7995b8c.png) | ![](../Images/115613c0801bbdad22e2fcf28492c927.png)
    | ![](../Images/bd9dd2bf185dbd90edada0700ade718d.png) |'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/21997b00f9237133b8841a742ecbc3f1.png) | ![](../Images/86c64691927f955c72a5955ccf3b8f02.png)
    | ![](../Images/f5e837baad0b1b78d3cf5117b7995b8c.png) | ![](../Images/115613c0801bbdad22e2fcf28492c927.png)
    | ![](../Images/bd9dd2bf185dbd90edada0700ade718d.png) |'
- en: '| ![](../Images/6f8e1345902e3491a0601805d9819c94.png) | ![](../Images/03b23db7a0b3dca33547f15e542fc39a.png)
    | ![](../Images/7f5eb02d4bcd5f48614f0bdd83e989c8.png) | ![](../Images/816e46061b859d3e86b97898546ba54e.png)
    | ![](../Images/557b02f05f5e61129f507c2c5cf36680.png) |'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/6f8e1345902e3491a0601805d9819c94.png) | ![](../Images/03b23db7a0b3dca33547f15e542fc39a.png)
    | ![](../Images/7f5eb02d4bcd5f48614f0bdd83e989c8.png) | ![](../Images/816e46061b859d3e86b97898546ba54e.png)
    | ![](../Images/557b02f05f5e61129f507c2c5cf36680.png) |'
- en: '*Fudgeflake.*'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Fudgeflake。*'
- en: '| ![](../Images/0038136785243878c5d65c22e2fbea83.png) | ![](../Images/318d2a86dda6d6fa4be50beec4f53a23.png)
    | ![](../Images/f10c25ae967d4ec252ecfe65bea2a0f1.png) | ![](../Images/d234e8cf1c487e4b5d64758279151186.png)
    | ![](../Images/5110f7cf92608a3e921f1405fa83284f.png) |'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/0038136785243878c5d65c22e2fbea83.png) | ![](../Images/318d2a86dda6d6fa4be50beec4f53a23.png)
    | ![](../Images/f10c25ae967d4ec252ecfe65bea2a0f1.png) | ![](../Images/d234e8cf1c487e4b5d64758279151186.png)
    | ![](../Images/5110f7cf92608a3e921f1405fa83284f.png) |'
- en: '| ![](../Images/6af0ead604e210dbf3e1506b941817a4.png) | ![](../Images/78ce46f6abf3a652ec3756e102d72bf9.png)
    | ![](../Images/6b9d9a079bbaffc1873580e90d165007.png) | ![](../Images/c751c2efa1df38ad27fb78eb803d7466.png)
    | ![](../Images/b5ffc5d31872f5ca41a394906b5837dc.png) |'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/6af0ead604e210dbf3e1506b941817a4.png) | ![](../Images/78ce46f6abf3a652ec3756e102d72bf9.png)
    | ![](../Images/6b9d9a079bbaffc1873580e90d165007.png) | ![](../Images/c751c2efa1df38ad27fb78eb803d7466.png)
    | ![](../Images/b5ffc5d31872f5ca41a394906b5837dc.png) |'
- en: '**Turtle graphics (hard).** Write a program to produce each of the following
    recursive patterns without lifting the pen or tracing over the same line segment
    more than once.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**海龟图形（困难）。** 编写一个程序来生成以下每个递归图案，而不需要抬起笔或重复跟踪同一线段。'
- en: '*Sierpinski arrowhead.*'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*谢尔宾斯基箭头。*'
- en: '| ![](../Images/6db8b417a535330ee7ed358a0a3b3287.png) | ![](../Images/27682b1e2f94a8825655c1cf9bf3318f.png)
    | ![](../Images/4ed2b323fd2f5a3eb2fb880a6c1f5084.png) | ![](../Images/20c1d59ddabb2f984aa1cbd2a442228f.png)
    | ![](../Images/bf44d232c0619aaf357b556e6cb7b9a0.png) |'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/6db8b417a535330ee7ed358a0a3b3287.png) | ![](../Images/27682b1e2f94a8825655c1cf9bf3318f.png)
    | ![](../Images/4ed2b323fd2f5a3eb2fb880a6c1f5084.png) | ![](../Images/20c1d59ddabb2f984aa1cbd2a442228f.png)
    | ![](../Images/bf44d232c0619aaf357b556e6cb7b9a0.png) |'
- en: '*Sierpinski curve.*'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*谢尔宾斯基曲线。*'
- en: '| ![](../Images/12650176a8215f37e66ec9bdc876b976.png) | ![](../Images/e6643e9021562bbf6eb26b8fd499d4e6.png)
    | ![](../Images/2ed5ca1c14893bc72a282f4d71fd65cd.png) | ![](../Images/ec0f05b7a1cbe7cb057d733b1ea17f17.png)
    | ![](../Images/055957116ccf0e2b969f8d37ddeca33b.png) |'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| ![](../Images/12650176a8215f37e66ec9bdc876b976.png) | ![](../Images/e6643e9021562bbf6eb26b8fd499d4e6.png)
    | ![](../Images/2ed5ca1c14893bc72a282f4d71fd65cd.png) | ![](../Images/ec0f05b7a1cbe7cb057d733b1ea17f17.png)
    | ![](../Images/055957116ccf0e2b969f8d37ddeca33b.png) |'
- en: '**Mandelbrot trajectory.** Write an interactive program [Trajectory.java](Trajectory.java.html)
    that plots the sequence of points in the Mandelbrot iteration in the complex plane.
    If the user clicks on (x, y), plot the sequence of iterates for z = x + iy.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**曼德勃罗特轨迹。** 编写一个交互式程序[Trajectory.java](Trajectory.java.html)，在复平面中绘制曼德勃罗特迭代中的点序列。如果用户点击(x,
    y)，则为z = x + iy绘制迭代序列。'
- en: '**Faster Mandelbrot.** Speed up Mandelbrot by performing the computation directly
    instead of using `Complex`. Compare. Incorporate periodicity checking or [boundary
    tracing](http://www.geocities.com/CapeCanaveral/5003/mandel.htm) for further improvements.
    Use divide-and-conquer: choose 4 corners of a rectangle and a few random points
    inside; if they''re all the same color, color the whole rectangle that color;
    otherwise divide into 4 rectangles and recur.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更快的曼德勃罗特。** 通过直接执行计算而不是使用`Complex`来加速曼德勃罗特。进行周期性检查或[边界追踪](http://www.geocities.com/CapeCanaveral/5003/mandel.htm)以进一步改进。使用分而治之：选择矩形的4个角和几个随机点内部；如果它们都是相同颜色，就用该颜色着色整个矩形；否则将其分成4个矩形并递归。'
- en: '**Random walker.** Write a data type `RandomWalker` that simulates the motion
    of a random walker in the plane that starts at the origin and makes a random step
    (left, right, up, or down) at each step. Include a method `step()` that moves
    the random walker one step and a method `distance()` that returns the distance
    the random walker is from the origin. Use this data type to formulate a hypothesis
    as to how far (as a function of N) the random walker is from the origin after
    N steps. (See also Exercise 1.x.)'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机漫步者。** 编写一个数据类型`RandomWalker`，模拟平面上从原点开始的随机漫步者的运动，每一步都是随机的（左、右、上或下）。包括一个移动随机漫步者一步的方法`step()`和一个返回随机漫步者距离原点的距离的方法`distance()`。使用这个数据类型来提出一个关于随机漫步者在N步之后离原点多远（作为N的函数）的假设。（另见练习1.x。）'
- en: '**Big rational numbers.** Create a data type [BigRational.java](BigRational.java.html)
    for positive rational numbers, where the numerators and denominators can be arbitrarily
    large. *Hint*: use [java.math.BigInteger](https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html)'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大有理数。** 创建一个数据类型[BigRational.java](BigRational.java.html)用于正有理数，其中分子和分母可以是任意大的。*提示*：使用[java.math.BigInteger](https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html)'
- en: '**Deluxe turtle graphics.** Extend Turtle in various ways. Make `DeluxeTurtle`
    that adds color, etc. Add a version that supports error checking. For example,
    throw a `TurtleOutOfBounds` exception if turtle goes outside designated boundary.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**豪华海龟图形。** 以各种方式扩展Turtle。创建一个添加颜色等功能的`DeluxeTurtle`。添加一个支持错误检查的版本。例如，如果海龟超出指定边界，则抛出`TurtleOutOfBounds`异常。'
- en: Write a program [FourChargeClient.java](FourChargeClient.java.html) that takes
    a `double` command-line argument `r`, creates four `Charge` objects that are each
    distance `r` from the center of the screen (0.5, 0.5), and prints the potential
    at location (0.25, 0.5) due to the combined four charges. All four charges should
    have the same unit charge.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序 [FourChargeClient.java](FourChargeClient.java.html)，接受一个`double`命令行参数`r`，创建四个`Charge`对象，每个对象距离屏幕中心(0.5,
    0.5)的距离为`r`，并打印由这四个电荷组合在位置(0.25, 0.5)处产生的电势。所有四个电荷应具有相同的单位电荷。
- en: Why does program [Bug1.java](Bug1.java.html) create a `java.lang.NullPointerException`
    when executed?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行程序[Bug1.java](Bug1.java.html)时为什么会创建一个`java.lang.NullPointerException`？
- en: '[PRE1]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Answer:* the programmer probably intended to make the no argument constructor
    set the string to `hello`. However, it has a return type (`void`) so it is an
    ordinary instance method instead of a constructor. It just happens to have the
    same name as the class.'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案:* 程序员可能打算让无参数构造函数将字符串设置为`hello`。然而，它有一个返回类型(`void`)，所以它是一个普通的实例方法，而不是构造函数。它只是碰巧与类名相同。'
- en: Why does program [Bug2.java](Bug2.java.html) create a `java.lang.NullPointerException`
    when executed?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行程序[Bug2.java](Bug2.java.html)时为什么会创建一个`java.lang.NullPointerException`？
- en: Implement a data type `Die` for rolling a fair die, say with 6 sides. Include
    a mutator method `roll()` and an accessor method `value`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个数据类型`Die`用于掷一个公平的骰子，比如有6个面。包括一个修改器方法`roll()`和一个访问器方法`value`。
- en: Implement a mutable data type `LFSR` for a linear feedback shift register.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个可变数据类型`LFSR`用于线性反馈移位寄存器。
- en: Implement a mutable data type `Odometer`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个可变数据类型`Odometer`。
- en: '**Complex trigonometric functions.** Add methods to [Complex.java](Complex.java.html)
    support trigonometric and exponential functions on complex numbers.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复数三角函数。** 在[Complex.java](Complex.java.html)中添加支持��数的三角函数和指数函数。'
- en: \(\exp(a + ib) = e^a \cos(b) + i \, e^a \sin(b)\)
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\exp(a + ib) = e^a \cos(b) + i \, e^a \sin(b)\)
- en: \(\sin(a + ib) = \sin(a) \cosh(b) + i \cos(a) \sinh(b)\)
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\sin(a + ib) = \sin(a) \cosh(b) + i \cos(a) \sinh(b)\)
- en: \(\cos(a + ib) = \cos(a) \cosh(b) - i \sin(a) \sinh(b)\)
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\cos(a + ib) = \cos(a) \cosh(b) - i \sin(a) \sinh(b)\)
- en: \(\tan(a + ib) = \sin(a + ib) \;/\; \cos(a + ib)\)
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(\tan(a + ib) = \sin(a + ib) \;/\; \cos(a + ib)\)
- en: Implement a data type `VotingMachine` for tabulating votes. Include mutator
    methods `voteRepublican()`, `voteDemocrat()`, and `voteIndependent()`. Include
    an accessor method `getCount()` to retrieve the total number of votes.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个数据类型`VotingMachine`用于计票。包括修改器方法`voteRepublican()`，`voteDemocrat()`和`voteIndependent()`。包括一个访问器方法`getCount()`来检索总票数。
- en: What happens when you try to compile and execute the following code fragment?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您尝试编译和执行以下代码片段时会发生什么？
- en: '[PRE2]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Answer*: it complains that `x` may not be initialized, and does not compile.'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案:* 它抱怨`x`可能未初始化，并且无法编译。'
- en: What happens when you try to compile and execute the following code fragment?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您尝试编译和执行以下代码片段时会发生什么？
- en: '[PRE3]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Answer*: it compiles and prints out `null`.'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案:* 它编译并打印出`null`。'
- en: What is wrong with the following code fragment?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段有什么问题？
- en: '[PRE4]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Answer*: it produces a `NullPointerException` because we forgot use `new`
    to create each individual `Dog` object. To correct, add the following loop after
    the array initialization statement.'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案:* 它产生一个`NullPointerException`，因为我们忘记使用`new`来创建每个单独的`Dog`对象。要纠正，添加以下循环在数组初始化语句之后。'
- en: '[PRE5]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What does the following code fragment print?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE6]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What's wrong with the following code fragment that swaps the Student objects
    x and y?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下交换Student对象x和y的代码片段有什么问题？
- en: '[PRE7]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Answer*: First, the data type `Student` does not have a no-argument constructor.
    If it did, then it would technically be correct, but the `new Student()` line
    is unnecessary and wasteful. It allocates memory for a new student object, sets
    `swap` equal to that memory address, then immediately sets `swap` equal to the
    memory address of `x`. The allocated memory is no longer accessible. The following
    version is correct.'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案:* 首先，数据类型`Student`没有无参数构造函数。如果有的话，那么它在技术上是正确的，但`new Student()`这行是多余且浪费的。它为一个新的学生对象分配内存空间，将`swap`设置为该内存地址，然后立即将`swap`设置为`x`的内存地址。分配的内存不再可访问。以下版本是正确的。'
- en: '[PRE8]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Find inputs to the Mandelbrot update formula that make it converge (z0 = 1/2
    + 0i), cycle with a period of 1 (z0 = -2 + 0i), cycle with a period of 2 (z0 =
    -1 + 0i), or stay bounded without converging (z0 = -3/2 + 0i).
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到使Mandelbrot更新公式收敛（z0 = 1/2 + 0i）、周期为1循环（z0 = -2 + 0i）、周期为2循环（z0 = -1 + 0i）或保持有界而不收敛（z0
    = -3/2 + 0i）的输入。
- en: '**Point3D.** Create a data type for points in 3 dimensional space. Include
    a constructor that takes three real coordinates x, y, and z. Include methods `distance`,
    `distanceSquared`, and `distanceL1` for the Euclidean distance, Euclidean distance
    squared, and the L1-distance.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Point3D。** 创建一个用于三维空间中点的数据类型。包括一个接受三个实数坐标 x、y 和 z 的构造函数。包括计算欧几里得距离、欧几里得距离平方和
    L1 距离的方法`distance`、`distanceSquared`和`distanceL1`。'
- en: Create a data type [PhoneNumber.java](PhoneNumber.java.html) that represents
    a US phone number. The constructor should take three string arguments, the area
    code (3 decimal digits), the exchange (3 decimal digits) and the extension (4
    decimal digits). Include a `toString` method that prints out phone numbers of
    the form (800) 867-5309. Include a method so that `p.equals(q)` returns `true`
    if the phone numbers p and q are the same, and `false` otherwise.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数据类型[PhoneNumber.java](PhoneNumber.java.html)，表示美国电话号码。构造函数应该接受三个字符串参数，区号（3
    个十进制数字）、交换机号（3 个十进制数字）和分机号（4 个十进制数字）。包括一个`toString`方法，打印出形式为 (800) 867-5309 的电话号码。包括一个方法，使得`p.equals(q)`返回`true`，如果电话号码
    p 和 q 相同，则返回`false`。
- en: Redo [PhoneNumber.java](PhoneNumber.java.html) but implement it using three
    integer fields. Make the constructor take three integer arguments. Comment on
    the advantages and disadvantages of this approach over the string representation.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新实现[PhoneNumber.java](PhoneNumber.java.html)，但使用三个整数字段来实现。构造函数接受三个整数参数。评论这种方法相对于字符串表示的优缺点。
- en: '*Answer*: more efficient with time and memory. More hassle to handle leading
    0s correct in constructor and `toString` method.'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*答案*：在时间和内存上更有效率。在构造函数和`toString`方法中处理前导 0 的正确性更加麻烦。'
- en: Write a program to draw the field lines for a *uniform field*. Arrange N evenly-spaced
    particles with charge e in a vertical column, and arrange N particles with charge
    -e in a vertical column so that each charge on one side is lined up with a corresponding
    charge on the other side. This simulates the field inside a plane capacitor. What
    can you say about the resulting electric field? A. Almost uniform.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来绘制*均匀场*的场线。在垂直列中排列 N 个等间距带电粒子，带电量为 e，并在另一侧排列 N 个带电量为 -e 的粒子，使得一侧的每个电荷与另一侧对应的电荷对齐。这模拟了平行板电容器内的电场。关于结果电场，你能说些什么？A.
    几乎均匀。
- en: '**Equipotential surfaces.** An *equipotential surface* is the set of all points
    that have the same electric potential V. Given a group of N point charges, it
    is useful to visualize the electric potential by plotting equipotential surfaces
    (aka contour plots). Program [Equipotential.java](Equipotential.java.html) draws
    a line every 5V by computing the potential at each gridpoint and checking whether
    the potential is within 1 pixel of a multiple of 5V. Since the electric field
    E measures how much the potential changes, E * eps is the range that the potential
    changes in a distance of 1 pixel. It relies on the helper program [DeluxeCharge.java](DeluxeCharge.java.html).'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等势面。** 一个*等势面*是所有具有相同电势 V 的点的集合。给定一组 N 个点电荷，通过绘制等势面（又称等势线图），可以直观地可视化电势。程序[Equipotential.java](Equipotential.java.html)通过计算每个网格点的电势并检查电势是否在
    5V 的倍数的像素范围内来绘制每 5V 画一条线。由于电场 E 衡量了电势的变化量，E * eps 是电势在 1 像素距离内变化的范围。它依赖于辅助程序[DeluxeCharge.java](DeluxeCharge.java.html)。'
- en: '| ![Electric equipotential](../Images/1eafa06a86b1e345bd7554b4f844ce5d.png)
    |                | ![Electric equipotential](../Images/fbde9c090fa57146308f21276caeab70.png)
    |'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ![电势等势线](../Images/1eafa06a86b1e345bd7554b4f844ce5d.png) |               
    | ![电势等势线](../Images/fbde9c090fa57146308f21276caeab70.png) |'
- en: It is also interesting to plot the field lines and the equipotential lines simultaneously.
    The field lines are always perpendicular the the equipotential lines.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时绘制场线和等势线也很有趣。场线始终垂直于等势线。
- en: '**Color palettes.** Create Mandelbrot and Julia sets using different color
    palettes. For example, this scheme was proposed by Hubert Grassmann'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调色板。** 使用不同的调色板创建曼德勃罗特集和 Julia 集。例如，这种方案是由 Hubert Grassmann 提出的。'
- en: '[PRE9]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: and produces a striking image of the Julia set
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并生成一个引人注目的 Julia 集图像
- en: '![Julia set](../Images/5accc3563d63b28f21198231a368561a.png)'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Julia 集](../Images/5accc3563d63b28f21198231a368561a.png)'
