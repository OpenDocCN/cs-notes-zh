- en: 3.2   Creating Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://introcs.cs.princeton.edu/java/32class](https://introcs.cs.princeton.edu/java/32class)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this section, we introduce the Java mechanism that enables us to create user-defined
    data types. We consider a range of examples, from charged particles and complex
    numbers to turtle graphics and stock accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Basic elements of a data type.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Coulomb''s law](../Images/a6cb7c619d9a2e9e22f03c5f7217dbe0.png) To illustrate
    the process, we define in [Charge.java](Charge.java.html) a data type for charged
    particles. [Coulomb’s law](https://en.wikipedia.org/wiki/Coulomb%27s_law) tells
    us that the electric potential at a point \((x, y)\) due to a given charged particle
    is \(V = kq /r\), where \(q\) is the charge value, \(r\) is the distance from
    the point \((x, y)\) to the charge, and \(k = 8.99 \times 10^9\) is the electrostatic
    constant.'
  prefs: []
  type: TYPE_NORMAL
- en: '*API.* The application programming interface is the contract with all clients
    and, therefore, the starting point for any implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Charge API](../Images/2f6c4130070ed35aa425e751b62022e7.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Class.* In Java, you implement a data type in a `class`. As usual, we put
    the code for a data type in a file with the same name as the class, followed by
    the `.java` extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Access modifiers.* We designate every instance variable and method within
    a class as either `public` (this entity is accessible by clients) or `private`
    (this entity is not accessible by clients). The `final` modifier indicates that
    the value of the variable will not change once it is initialized—its access is
    read-only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Instance variables.* We declare *instance variables* to represent the data-type
    values in the same way as we declare local variables, except that these declarations
    appear as the first statements in the class, not inside `main()` or any other
    method. For `Charge`, we use three `double` variables—two to describe the charge’s
    position and one to describe the amount of charge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Instance variables](../Images/f5d3c02cdb37e24603fa5f01ba92be09.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Constructors.* A constructor is a special method that creates an object and
    provides a reference to that object. Java automatically invokes a constructor
    when a client program uses the keyword `new`. Each time that a client invokes
    a constructor, Java automatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocates memory for the object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Invokes the constructor code to initialize the instance variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a reference to the newly created object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The constructor in `Charge` is typical: it initializes the instance variables
    with the values provided by the client as arguments.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Constructor](../Images/f8b6f39bebf3114dec183569653b0adc.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Instance methods.* To implement instance methods, we write code that is precisely
    like code for implementing static methods. The one critical distinction is that
    instance methods can perform operations on instance variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Instance method](../Images/75465977689b9539fb07389b98107303.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Variables within methods.* The Java code we write to implement instance methods
    uses three kinds of variables. Parameter variables and local variables are familiar.
    Instance variables are completely different: they hold data-type values for objects
    in a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Instance, parameter and local variables](../Images/6e3d478887d8c9837841e973f1a9e63e.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'Each object in the class has a value: the code in an instance method refers
    to the value for the object that was used to invoke the method. For example, when
    we write `c1.potentialAt(x, y)`, the code in `potentialAt()` is referring to the
    instance variables for `c1`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Test client.* Each class can define its own `main()` method, which we reserve
    for unit testing. At a minimum, the test client should call every constructor
    and instance method in the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, to define a data type in a Java class, you need instance variables,
    constructors, instance methods, and a test client.
  prefs: []
  type: TYPE_NORMAL
- en: '![Anatomy of a class](../Images/ace94fc7cbe724f36aaff409d7ad77db.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Stopwatch.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Stopwatch.java](Stopwatch.java.html) implements the following API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stopwatch API](../Images/d2db4f4e91ded393e9c0d5577dc61b9d.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: It is a stripped-down version of an old-fashioned stopwatch. When you create
    one, it starts running, and you can ask it how long it has been running by invoking
    the method `elapsedTime()`.
  prefs: []
  type: TYPE_NORMAL
- en: Histogram.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Histogram](../Images/6cd930fcf39a72dd625eaf280149e8b4.png) [Histogram.java](Histogram.java.html)
    is a data type to visualize data using a familiar plot known as a *histogram*.
    For simplicity, we assume that the data consists of a sequence of integer values
    between 0 and *n*−1. A histogram counts the number of times each value appears
    and plots a bar for each value (with height proportional to its frequency). The
    following API describes the operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Histogram API](../Images/638f25b16264e1800ef8d57337f35931.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Turtle graphics.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Turtle.java](Turtle.java.html) is a mutable type for turtle graphics, in which
    we command a turtle to move a specified distance in a straight line, or rotate
    (counterclockwise) a specified number of degrees.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Turtle graphics API](../Images/2bfcee40b61dec8fe413b9e297f77025.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'Here are a few example clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Regular n-gons.* [Ngon.java](Ngon.java.html) takes a command-line argument
    *n* and draws a regular *n*-gon using turtle graphics. By taking *n* to a sufficiently
    large value, we obtain a good approximation to a circle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Recursive graphics.* [Koch.java](Koch.java.html) takes a command-line argument
    *n* and draws a [Koch curve](https://en.wikipedia.org/wiki/Koch_snowflake) of
    order *n*. A Koch curve of order order 0 is a line segment. To form a Koch curve
    of order *n*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw a Koch curve of order *n*−1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate 60° counterclockwise
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw a Koch curve of order *n*−1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate 120° clockwise
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw a Koch curve of order *n*−1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate 60° counterclockwise
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw a Koch curve of order *n*−1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below are the Koch curves of order 0, 1, 2, and 3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ![Koch curve 0](../Images/65e1d7653553d4ddb5d1aaefdeaa3bd2.png "Koch curve
    of order 0") | ![Koch curve 1](../Images/828b58ef5abfb4bc9b6e4e24fcedff32.png
    "Koch curve of order 1") | ![Koch curve 2](../Images/274901ba86291bde4babeb5166892b0b.png
    "Koch curve of order 2") | ![Koch curve 3](../Images/2c5362ac4e7fb96038b4799598e767c9.png
    "Koch curve of order 3") |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '*Spira mirabilis.* ![logarithmic spiral](../Images/14c718646c168121dac0447a80b3205b.png)
    [Spiral.java](Spiral.java.html) takes an integer *n* and a decay factor as command-line
    arguments, and instructs the turtle to alternately step and turn until it has
    wound around itself 10 times. This produces a geometric shape known as a [logarithmic
    spiral](https://en.wikipedia.org/wiki/Logarithmic_spiral), which arise frequently
    in nature.  Three examples are depicted below: the chambers of a nautilus shell,
    the arms of a spiral galaxy, and the cloud formation in a tropical storm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| [![Nautilus shell](../Images/5dcac6d8c6d6010ca4b0969209a67615.png)](https://commons.wikimedia.org/wiki/File:NautilusCutawayLogarithmicSpiral.jpg)
    |    | ![arms of a spiral galaxy](../Images/c7d8e3de353841570edc597cfe153a79.png)
    |    | ![Low pressure system over Iceland](../Images/ddc45020e8d0a139eb26a78210595a25.png)
    |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| This Wikipedia image is from [user Chris 73](https://en.wikipedia.org/wiki/User:Chris_73),
    and is available via the [CC by-SA 3.0 license.](https://creativecommons.org/licenses/by-sa/3.0/)
    |  | Photo: NASA and ESA   |  | Photo: NASA   |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '*Brownian motion.* [DrunkenTurtle.java](DrunkenTurtle.java.html) plots the
    path followed by a disoriented turtle, who alternates between moving forward and
    turning in a *random* direction. This process is known as [Brownian motion](https://en.wikipedia.org/wiki/Brownian_motion).
    [DrunkenTurtles.java](DrunkenTurtles.java.html) plots many such turtles, all of
    whom wander around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex numbers.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *complex* number is a number of the form *x* + *iy*, where *x* and *y* are
    real numbers and *i* is the square root of −1. The basic operations on complex
    numbers are to add and multiply them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Addition*: \((x_0+iy_0) + (x_1+iy_1) = (x_0+x_1) + i\,(y_0+y_1)\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Multiplication*: \((x_0 + iy_0) \cdot (x_1 + iy_1) = (x_0x_1 - y_0y_1) + i\,(y_0x_1
    + x_0y_1)\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Magnitude*: \(\left | x + iy \right | = \sqrt{x^2 + y^2}\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Real part*: \(\operatorname{Re}(x + iy) = x\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Imaginary part*: \( \operatorname{Im}(x + iy) = y\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Complex.java](Complex.java.html) is an immutable data type that implements
    the following API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Complex number API](../Images/ccfbafd7e0a10894da469106e9b31a99.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: This data type introduces a few new features.
  prefs: []
  type: TYPE_NORMAL
- en: '*Accessing values of other objects of the same type.* The instance methods
    `plus()` and `times()` each need to access values in two objects: the object passed
    as an argument and the object used to invoke the method. If we call the method
    with `a.plus(b)`, we can access the instance variables of `a` using the names
    `re` and `im`, as usual. However, to access the instance variables of `b`, we
    use the code `b.re` and `b.im`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating and returning new objects.* Observe the manner in which `plus()`
    and `times()` provide return values to clients: they need to return a `Complex`
    value, so they each compute the requisite real and imaginary parts, use them to
    create a new object, and then return a reference to that object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chaining method calls.* Observe the manner in which `main()` *chains* two
    method calls into one compact expression `z.times(z).plus(z0)`, which corresponds
    to the mathematical expression *z*² + *z*[0].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Final instance variables.* The two instance variables in `Complex` are `final`,
    meaning that their values are set for each `Complex` object when it is created
    and do not change during the lifetime of that object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mandelbrot set.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [Mandelbrot set](https://www.cs.princeton.edu/~wayne/mandel/mandel.html)
    is a specific set of complex numbers with many fascinating properties. The *algorithm*
    for determining whether or not a complex number \(z_0\) is in the Mandelbrot set
    is simple: Consider the sequence of complex numbers \(z_0, z_1, z_2, \ldots, z_t,
    \ldots,\) where \(z_{i+1} = z_i^2 + z_0\). For example, the following table shows
    the first few entries in the sequence corresponding to \(z_0 = 1 + i\):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mandelbrot sequence](../Images/70ba60fad845c843579dfb5d7587c7c3.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'Now, if the sequence \( | z_i |\) diverges to infinity, then \(z_0\) is *not*
    in the Mandelbrot set; if the sequence is bounded, then \(z_0\) is in the Mandelbrot
    set. For many points, the test is simple; for many other points, the test requires
    more computation, as indicated by the examples in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mandelbrot sequences](../Images/7099b5c20dd94ead91f14619dbe5dcd2.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: To visualize the Mandelbrot set, we define an evenly spaced *n*-by-*n* pixel
    grid within a specified square and draw a black pixel if the corresponding point
    is in the Mandelbrot set and a white pixel if it is not.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mandelbrot set](../Images/2ea3a24598cd9b7c30efd5a27615532b.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: But how do we determine whether a complex number is in the Mandelbrot set? For
    each complex number, [Mandelbrot.java](Mandelbrot.java.html) computes up to 255
    terms in its sequence. If the magnitude ever exceeds 2, then we can conclude that
    the complex number is not in the set (because it is known that the sequence will
    surely diverge). Otherwise, we conclude that the complex number is in the set
    (knowing that our conclusion might be wrong on occasion).
  prefs: []
  type: TYPE_NORMAL
- en: Commercial data processing.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[StockAccount.java](StockAccount.java.html) implements a data type that might
    be used by a financial institution to keep track of customer information.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stock account API](../Images/bdc37b5ab057ff677a148545f768a13b.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Develop an implementation [Rectangle.java](Rectangle.java.html) of your `Rectangle`
    API from Exercise 3.2.1 that that represents rectangles with the *x*- and *y*-coordinates
    of their lower-left and upper-right corners. Do not change the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a data type [Rational.java](Rational.java.html) numbers that supports
    addition, subtraction, multiplication, and division.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Rational API](../Images/75cc28a56a8e170deeebd4dd999b422a.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'Write a data type [Interval.java](Interval.java.html) that implements the following
    API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Interval API](../Images/c7ae1db93430cb56b9f12fac8b144692.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: An interval is defined to be the set of all points on the line greater than
    or equal to `min` and less than or equal to `max`. In particular, an interval
    with `max` less than `min` is empty. Write a client that is a filter that takes
    a floating-point command-line argument `x` and prints all of the intervals on
    standard input (each defined by a pair of double values) that contain `x`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a data type [Point.java](Point.java.html) that implements the following
    API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Point API](../Images/32cdef14784826d070f4bd0e1f330c6b.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Modify the `toString()` method in [Complex.java](Complex.java.html) so that
    it complex numbers in the traditional format. For example, it should print the
    value \(3-i\) as `3 - i` instead of `3.0 + -1.0i`, the value 3 as `3` instead
    of `3.0 + 0.0i` and the value \3i\) as `3i` instead of `0.0 + 3.0i`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `Complex` client [RootsOfUnity.java](RootsOfUnity.java.html) that takes
    two `double` values *a* and *b* and an integer *n* from the command line and prints
    the *n*th root of \(a + bi\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the following additions to [Complex.java](Complex.java.html):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Complex API](../Images/c92359ffac92729a3a79f962f56c7f79.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: Write a test client that exercises all of your methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Suppose you want to add a constructor to [Complex.java](Complex.java.html)
    that takes a `double` value as its argument and creates a `Complex` number with
    that value as the real part (and no imaginary part). You write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But then the statement `Complex c = new Complex(1.0);` does not compile. Why?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: Constructors do not have return types, not even `void`. This code
    defines method named `Complex()`, not a constructor. Remove the keyword `void`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creative Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Electric potential visualization.** Write a program [Potential.java](Potential.java.html)
    that creates an array of charged particles from values given on standard input
    (each charged particle is specified by its *x*-coordinate, *y*-coordinate, and
    charge value) and produces a visualization of the electric potential in the unit
    square. To do so, sample points in the unit square. For each sampled point, compute
    the electric potential at that point (by summing the electric potentials due to
    each charged particle) and plot the corresponding point in a shade of gray proportional
    to the electric potential.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![Electric potential](../Images/a596beb117fa57129e0ba62f47f0a960.png) |         
    | ![Electric potential](../Images/97f317b73b3b894557f451ea17b2b05b.png) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Quaternions.** In 1843, Sir William Hamilton discovered an extension to complex
    numbers called [quaternions](http://en.wikipedia.org/wiki/Quaternion). Quaternions
    extend the concept of rotation in three dimensions to four dimensions. They are
    used in computer graphics, control theory, signal processing, and orbital mechanics,
    e.g., command for spacecraft attitude control systems. are related to Pauli spin
    matrices in physics. Create a date type [Quaternion.java](Quaternion.java.html)
    to represent quaternions. Include operations for adding, multiplying, inverting,
    conjugating, and taking the norm of quaternions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A quaternion can be represented by a 4-tuple of real numbers \((a_0, a_1, a_2,
    a_3)\), which represents \(a_0 + a_1 i + a_2 j + a_3 k\). The fundamental identity
    is \(i^2 = j^2 = k^2 = ijk = -1\).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Magnitude*: \( \left \| a \right \| = \sqrt{a_0^2 + a_1^2 + a_2^2 + a_3^2}
    \)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conjugate*: \( a^* = (a_0, -a_1, -a_2, -a_3)\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Inverse*: \( a^{-1} = (a_0\,/\, \left \| a \right \|^2, -a_1\,/\, \left \|
    a \right \|^2, -a_2\,/\, \left \| a \right \|^2, -a_3\,/\, \left \| a \right \|^2)\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sum*: \( a + b = (a_0+b_0, a_1+b_1, a_2+b_2, a_3+b_3)\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hamilton product*: $$ \begin{align} a \times b \; = \; (& a_0b_0 - a_1b_1
    - a_2b_2 - a_3b_3, \\ & a_0b_1 + a_1b_0 + a_2b_3 - a_3b_2, \\ & a_0b_2 - a_1b_3
    + a_2b_0 + a_3b_1, \\ & a_0b_3 + a_1b_2 - a_2b_1 + a_3b_0) \end{align} $$'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quotient*: \( a\,/\,b = a^{-1} \times b \)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dragon curve.** Write a program [Dragon.java](Dragon.java.html) that reads
    in a command-line parameter N and plots the order N dragon curve using turtle
    graphics. The dragon curve was first discovered by three NASA physicists (John
    E. Heighway, Bruce A. Banks, and William G. Harter) and later popularized by Martin
    Gardner in Scientific American (March and April 1967) and Michael Crichton in
    Jurassic Park.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/81ee727a661850b081b7679af8bdd73a.png) | ![](../Images/03e93069201391966134b4eb09d3248b.png)
    | ![](../Images/3ff5c50e41512c3684fa7ea4100e76d5.png) | ![](../Images/01a9c5a36526c304722111980f16e864.png)
    | ![](../Images/e5ebbee06be6f528a6da0067d5bf7f7a.png) |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| ![](../Images/1db7e0fabf47a6d39c0e1df7ad192192.png) | ![](../Images/a48b97a2698ba348ca3b13a96d9c802d.png)
    | ![](../Images/a5f0aea87050b0f8508a6103ae345ddd.png) | ![](../Images/94d0621825ae68f53df6ebff647b0eae.png)
    | ![](../Images/572e10ef9b03f31a0e075e73746dac23.png) |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: This is a sophisticated program that uses two mutually recursive functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Program [SequentialDragon.java](SequentialDragon.java.html) is an iterative
    version of the dragon curve. It is a hacker's paradise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hilbert curves.** A [space-filling curve](http://en.wikipedia.org/wiki/Space-filling_curve)
    is a continuous curve in the unit square that passes through every point. Write
    a recursive `Turtle` client [Hilbert.java](Hilbert.java.html) (or [SingleHilbert.java](SingleHilbert.java.html))
    that produces these recursive patterns, which approach a space-filling curve that
    was defined by the mathematician David Hilbert at the end of the 19th century.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![Hilbert curve of order 1](../Images/23fe4e668b0c42845bb5867f9064676a.png)
    | ![Hilbert curve of order 2](../Images/9ed1814e6a5f61e393d35c2b67b46567.png)
    | ![Hilbert curve of order 3](../Images/b35c952f262ef5ab5c5d90fe93714844.png)
    | ![Hilbert curve of order 4](../Images/95b79850c82744d0501a0d9ab04893b0.png)
    | ![Hilbert curve of order 5](../Images/0870f275cf25dde98d565ea16ea2a3ef.png)
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Gosper island.** Write a recursive `Turtle` client [GosperIsland.java](GosperIsland.java.html)
    that produces these recursive patterns.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/32977d4584a6bac5f9f1d4b31dde447c.png) | ![](../Images/31c0a3824f79b7a56d2053b63a6be627.png)
    | ![](../Images/52613bd251649fa1c2d9c31345764f63.png) | ![](../Images/476c882a963f78d9e883a73ddccae5a9.png)
    | ![](../Images/addc9cb23707030811a90c97d0325bbb.png) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Chaos with Newton''s method.** The polynomial \(f(z) = z^4 - 1\) has 4 roots
    at 1, −1, *i*, and −*i*. We can find the roots using Newton''s method in the complex
    plane: \(z_{k+1} = z_k - f(z_k) \,/ \, f''(z_k)\). Here \(f(z) = z^4 - 1\) and
    \(f''(z) = 4z^3\). The method converges to one of the 4 roots depending on the
    starting point \(z_0\). Write a program [NewtonChaos.java](NewtonChaos.java.html)
    that takes a command-line argument *n* and creates an *n*-by-*n* image corresponding
    to the square of size 2 centered at the origin. Color each pixel white, red, green,
    or blue according to which of the four roots the corresponding complex number
    converges (black if no convergence after 100 iterations).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Newton''s method chaos](../Images/359f33aa29c7f8b01efd08ddd5b25305.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '**Color Mandelbrot plot.** Create a file of 256 integer triples that represent
    interesting `Color` values, and then use those colors instead of grayscale values
    to plot each pixel in [ColorMandelbrot.java](ColorMandelbrot.java.html) Read the
    values to create an array of 256 `Color` values, then index into that array with
    the return value of `mand()`. By experimenting with various color choices at various
    places in the set, you can produce astonishing images. See [mandel.txt](mandel.txt)
    for an example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![Mandelbrot set](../Images/23977aa3271cc34dbaadd6350988a712.png) |          
    | ![Mandelbrot set](../Images/c5a34b473933eb0aa308a2c9545e151a.png) |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| `-1.5 -1.0 2.0 2.0` |  | `0.10259 -0.641 0.0086 0.0086` |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '**Julia sets.** The *Julia set* for a given complex number *c* is a set of
    points related to the Mandelbrot function. Instead of fixing *z* and varying *c*,
    we fix *c* and vary *z*. Those points *z* for which the modified Mandelbrot function
    stays bounded are in the Julia set; those for which the sequence diverges to infinity
    are not in the set. All points *z* of interest lie in the 4-by-4 box centered
    at the origin. The Julia set for *c* is connected if and only if *c* is in the
    Mandelbrot set! Write a program [ColorJulia.java](ColorJulia.java.html) that takes
    two command-line arguments *a* and *b*, and plots a color version of the Julia
    set for *c* = *a* + *bi*, using the color-table method described in the previous
    exercise.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![Julia set](../Images/238f5f2bd3de34977d6ac08f9fc8573a.png) |          
    | ![Julia set](../Images/f57ab7f72aebc677652e135ef9e15333.png) |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| `-1.25 0.00` |  | `-0.75 0.10` |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: Web Exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**IP addresses.** Create a data type for IPv4 (Internet Protocol, version 4)
    addresses. An IP address is a 32-bit integer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dates.** Create a data type `Date` that represents a date. You should be
    able to create a new `Date` by specifying the month, day, and year. It should
    supports methods to compute the number of days between two dates, return the day
    of the week that a day falls on, etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Time bombs.** UNIX represents the date with a signed integer measuring the
    number of seconds since January 1, 1970. Write a client program to calculate when
    this date will occur. Add a static method `add(Date d, int days)` to your date
    data type that returns a new date which is the specified number of days after
    the date d. Note that there are 86,400 seconds in a day.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Qubits.** In quantum computing, a *qubit* plays the role of a bit. It is
    a complex number a + bi such that |a + bi| = 1\. Once we measure a qubit, it "decides"
    to be a 1 with probability a² and a 0 with probability b². Any subsequent observations
    will always yield the same value. Implement a data type `Qubit` that has a constructor
    `Qubit(a, b)` and a boolean method `observe` that returns `true` or `false` with
    the proscribed probabilities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Biorhythms.** A *biorhythm* is a pseudo-scientific profile of the three natural
    cycles of your body: physical (23 days), emotional (28 days), and intellectual
    (31 days). Write a program that takes six command line inputs M, D, Y, m, d, and
    y where (M, D, Y) is the month (1-12), day (1-31), and year (1900-2100) of your
    birthday and (m, d, y) is today''s month, day, and year. It should then print
    out your biorhythm on a scale of -1.0 to 1.0 according to the formula: sin (2
    π age / cycle length). Use the date data type created in the previous exercise.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Particle.** Create a data type for elementary or composite particles (electron,
    proton, quark, photon, atom, molecule). Each particle should have an instance
    variable to store its name, its mass, its charge, and its spin (multiple of 1/2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Quark.** Quarks are the smallest known building blocks of matter. Create
    a data type for quarks. Include a field for its type (up, down, charm, strange,
    top, or bottom) and its color (red, green, or blue). The charges are +2/3, -1/3,
    +2/3, -1/3, +2/3, -1/3, respectively. All have spin 1/2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Biorhythms.** Plot your biorhythm in turtle graphics over a 6 week interval.
    Identify *critical days* when your rhythm goes from positive to negative - according
    to biorhythm theory, this is when you are most prone to accident, instability,
    and error.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vector3.** Include normal vector operations for 3-vectors, including *cross
    product*. The cross product of two vectors is another vector. a cross b = ||a||
    ||b|| sin(theta) n, where theta is angle between a and b, and n is unit normal
    vector perpendicular to both a and b. (a[1], a[2], a[3]) cross (b[1], b[2], b[3])
    = (a[2] b[3] - a[3] b[2], a[3] b[1] - a[1] b[3], a[1] b[2] - a[2] b[1]). Note
    that |a cross b| = area of the parallelogram with sides a and b. Cross product
    arises in definition of torque, angular momentum and vector operator curl.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Four-vector.** Create a data type for [four-vectors](http://en.wikipedia.org/wiki/Four-vector).
    A four-vector is a four-dimensional vector (t, x, y, z) subject to Lorentz transformations.
    Useful in special relativity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Euclidean points.** Create a data type `EuclideanPoint.java` that represents
    a d-dimensional point. Include a method so that `p.distanceTo(q)` returns the
    Euclidean distance between points p and q.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vector field.** A [vector field](http://en.wikipedia.org/wiki/Vector_field)
    associates a vector with every point in a Euclidean space. Widely used in physics
    to model speed and direction of a moving object or or strength and direction of
    a Newtonian force.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Soda machine.** Create a data type `SodaMachine` that has methods `insertCoin()`,
    `getChange()`, `buy()`, etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Months.** Write a data type `Month` that represents one of the twelve months
    of the year. It should have fields for the name of the month, the number of days
    in the month, and the birthstone.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| MONTH | DAYS | BIRTHSTONE |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| January | 31 | Garnet |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| February | 28 | Amethyst |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| March | 31 | Aquamarine |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| April | 30 | Diamond |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| May | 31 | Emerald |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| June | 30 | Alexandrite |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| July | 31 | Ruby |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| August | 31 | Peridot |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| September | 30 | Sapphires |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| October | 31 | Opal |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| November | 30 | Topaz |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| December | 31 | Blue Zircon |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Gauss multiplication.** Implement complex multiplication using only 3 floating
    point multiplications (instead of 4). You may use as many as 5 floating point
    additions. *Answer*: Gauss gave the following method to multiply (a + bi)(c +
    di). Set x1 = (a + b)(c + d), x2 = ac, x3 = bd. Then the product is given by x
    + yi where x = x2 - x3, y = x1 - x2 - x3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tensors.** Create a data type for [tensors](http://en.wikipedia.org/wiki/Tensor).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**UN Countries.** Create a data type `Country` for [UN countries](../data/countries.csv).
    Include fields for 3 digit UN Code, 3 letter ISO abbreviation, country name, and
    capital. Write a program [Country.java](Country.java.html) that reads in a list
    of countries and stores them in an array of type `Country`. Use the method `String.split`
    to help parse the input file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Area codes.** Create a data type for [telephone area codes in North America](../data/phone-na.csv).
    Include fields for the area code, the city, and state, and the two letter state
    abbreviation. Or for [international phone codes](../data/phone-international.csv).
    Include a field for zone, code, and country.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Congressional districts.** Create a data type for places, counties, and congressional
    districts. Include fields for place name, county name, county code, zip code,
    congressional district, etc. Use the data sets from the [1998 FIPS55-DC3 Index](http://www.itl.nist.gov/fipspubs/55new/nav-top-fr.htm):
    Pennsylvania [(2MB)](../data/fips55-pa.txt) or all 50 states plus DC and 9 outlying
    areas [(30MB)](../data/fips55-all.txt).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Latitudes and longitudes.** For USA latitudes and longitudes, use the [TIGER
    database](http://www.census.gov/geo/www/tiger/) or [www.bcca.org](http://www.bcca.org/misc/qiblih/latlong_us.html)
    or [gazetteer](http://geonames.usgs.gov/stategaz/index.html). For the rest of
    the world, use [earth-info](http://earth-info.nima.mil/gns/html/cntry_files.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Astronomy**. Data for [asteroids](../data/asteroids.csv), [meteors](../data/meteors.csv),
    and [comets](../data/comets.csv).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fortune 1000 companies.** Create a data type the for [Fortune 1000](../data/fortune1000.csv).
    Include fields for company name and sales revenue in millions of dollars. Data
    taken from April 15, 2002 issue of Fortune. Note: currently need to parse data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Molecular weight.** Write a program so that the user enters a molecule H2
    O and the program calculates its molecular weight.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some potentially useful datafiles: [aroma therapies](../data/aroma-therapy.txt),
    [nutritional information](../data/calories.csv), [meteorological glossary](../data/meteorological-glossary.txt),
    [psychiatric disorders](../data/psychiatric.csv), [words translated in 15 languages](../data/language.csv),
    [dictionary of emoticons](../data/emoticons.txt), [meanings of common names](../data/names.csv),
    [World Almanac facts about countries](../data/world98.txt).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Student records.** Create a data type [Student.java](Student.java.html) to
    represent students in an introductory computer science course. Each student record
    object should represent a first name, last name, email address, and section number.
    Include a `toString()` method that returns a string representation of a student
    and a `less()` method that compares two students by section number.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Impedance.** Impedance is the generalization of resistance from DC circuits
    to AC circuits. In an AC circuit, the *impedance* of a component measures its
    opposition to the flow of electrons at a given frequency ω. The impedance has
    two components: the resistance and the reactance. The *resistance* R of a circuit
    component measures its opposition to the movement of electrons (friction against
    motion of electrons) when a given voltage is applied. The *reactance* X of a circuit
    component measures its ability to store and release energy as the current and
    voltage fluctuate (inertia against motion of electrons).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In circuits with resistors only, the current is directly proportional to the
    voltage. However, with capacitors and inductors, there is a +- 90 degree "phase
    shift" between the current and voltage. This means that when the voltage wave
    is at its maximum, the current is 0, and when the current is at its maximum the
    voltage is 0\. To unify the treatment of resistors (R), inductors (L), and capacitors
    (C) it is convenient to treat the impedance as the complex quantity Z = R + iX.
    the impedance of an inductor is iwL and the impedance of a capacitor is 1/iwC.
    To determine the impedance of a sequence of circuit elements in series, we simply
    add up their individual impedances. Two important quantities in electrical engineering
    are the*magnitude of the impedance* and the *phase angle*. The magnitude is the
    ratio of the RMS voltage to the RMS current - it equals the magnitude of the complex
    impedance. The *phase angle* is the amount by which the voltage leads or lags
    the current - it is the phase of the complex impedance. Program [CircuitRLC.java](CircuitRLC.java.html)
    does a computation involving complex numbers and impedance of circuits with resistors,
    inductors, and capacitors in series.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: RLC circuit in parallel. 1/Z = 1/Z1 + 1/Z2 + ... 1/Zn.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise (for objects): repeat series-parallel network for RLC circuits with
    impedances instead of resistance'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Diffusion of particles in a fluid.** Simulate diffusion of particles in a
    fluid. See [BrownianParticle.java](../98simulation/BrownianParticle.java.html)
    in Section 9.8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Electric field lines.** Michael Faraday introduced an abstraction called
    *electric field lines* to visualize the electric field. By Coulombs law, the electric
    field at a point induced by a point charge q[i] is given by E[i] = k q[i] / r²,
    and the direction points to q[i] if q[i] is negative and away from q[i] it is
    positive. If there are a group of n point charges, the electric field at a point
    is the *vector sum* of the electric fields induced by the n individual point charges.
    We can compute it by summing up the components in the x- and y- directions. The
    figure below illustrates the field lines for two equal positive point charges
    (left) and two point charges of opposite signs (right). The second configuration
    is called an *electric dipole*: the charges cancel each other out, and the electric
    field weakens very quickly as you move away from the charges. Examples of dipoles
    can be found in molecules where charge is not evenly distributed. Oscillating
    dipoles can be used to produce electromagnetic waves to transmit radio and television
    signals.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![Electric potential](../Images/4ef2d45ba2ce902dd57c4109d87fa6fd.png) |         
    | ![Electric potential](../Images/70e0801a736ba3f60cdd881a550e122c.png) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Program [FieldLines.java](FieldLines.java.html) draws 10 electric field lines
    coming out of each charge. (We take some liberties since traditionally the number
    of field lines per unit area should be proportional to the magnitude of the field
    strength.) Each line starts on a 1-pixel circle around the charge, at twelve equally
    spaced angles. The electric field at a point (x, y) from a point charge q[i] is
    given by E[i] = k q[i] / r², where q[i] is the magnitude of the charge i and r
    is the radial distance from it. The field due to several charges is the vector
    sum of the field due to each, and can be found by adding the x- and y-components.
    After calculating the electric field strength, we move in the direction of the
    vector field and draws a spot. We repeat this process until we reach the boundary
    of the region or another point charge. The figures below illustrate the electric
    potential and field lines for several random charges of equal magnitude.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ![Electric potential and field lines](../Images/2ef4ae5e4e65a367bf5970f33b9c5015.png)
    |          | ![Electric potential and field lines](../Images/0e67861b77729800af30233b4d750aae.png)
    |          | ![Electric potential and field lines](../Images/87aad6b36c49205594ead19f92777871.png)
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Koch snowflake with rainbow of colors.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *Koch snowflake* of order n consists of three copies of the Koch curve of
    over n. We draw the three Koch curves one after the other, but rotate 120° clockwise
    in between. Below are the Koch snowflakes of order 0, 1, 2, and 3. Write a program
    [KochRainbow.java](KochRainbow.java.html) that plots the Koch snowflake in a continuous
    spectrum of colors from red, to orange, yellow, green, blue, and indigo, and violet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ![Koch Snowflake](../Images/873ee77813f59e266cd8c27dd948ef2e.png) | ![Koch
    Snowflake](../Images/e6ae52c75a1535f89f2c176a8df3880c.png) | ![Koch Snowflake](../Images/43e26f8b81aedee055ef31363296e064.png)
    | ![Koch Snowflake](../Images/17a35db785294a7eac10e2e404de80bd.png) | ![Koch Snowflake](../Images/4274183a89bc08f45a45bb113a8504f5.png)
    |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '**Anti-Koch snowflakes.** The *anti-Koch snowflake* is generated exactly like
    the Koch snowflake, except that clockwise and counterclockwise are interchanged.
    Write a program `AntiKoch.java` that takes a command line parameter N and plots
    the anti-Koch snowflake of order N using Turtle graphics.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/c8d929c8924ce9d0ac29888bc4a6e783.png) | ![](../Images/cbc6ba9b6d720c63305f273f74d875ba.png)
    | ![](../Images/bd24d0d8beff6a41e23b8121a2630418.png) | ![](../Images/1614d81c1c50aa3dd31b3769cc26ec8c.png)
    | ![](../Images/6dc36e2ca7d24ae79366858e741c651f.png) |'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '**Randomized Koch snowflakes.** A *randomized Koch snowflake* is generated
    exactly like the Koch snowflake, except that we flip a coin to generate the clockwise
    and counterclockwise direction at each step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Turtle graphics.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Minkowski sausage.* ([Sausage.java](Sausage.java.html))'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/068546ef39f48ff2b6918fb93f4475d2.png) | ![](../Images/aa6ce2687f8239eea4594e97cd48d3a9.png)
    | ![](../Images/e6b6a591e5ae6af0df139ac6125492bf.png) | ![](../Images/9913a3d1eacbd7d7361b8ddd3814e5ab.png)
    | ![](../Images/86773831140162a253758973889854f1.png) |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '*Cesaro broken square.*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/5f8b83fa3d790f4dbc9f4066f6ddad9e.png) | ![](../Images/5ca548856f8c6ef9760e04cd12751d1b.png)
    | ![](../Images/e1c3a9729636b3aba0a6fc3317367d9d.png) | ![](../Images/6b7d3099519cfbd2bce4b7c6a6a2aff0.png)
    | ![](../Images/ec89b834b9bc0c4f5462b37505e0fde3.png) |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '**More turtle graphics.** Write a program to produce each of the following
    recursive patterns.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Levy tapestry.* ([Levy.java](Levy.java.html))'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/21997b00f9237133b8841a742ecbc3f1.png) | ![](../Images/86c64691927f955c72a5955ccf3b8f02.png)
    | ![](../Images/f5e837baad0b1b78d3cf5117b7995b8c.png) | ![](../Images/115613c0801bbdad22e2fcf28492c927.png)
    | ![](../Images/bd9dd2bf185dbd90edada0700ade718d.png) |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| ![](../Images/6f8e1345902e3491a0601805d9819c94.png) | ![](../Images/03b23db7a0b3dca33547f15e542fc39a.png)
    | ![](../Images/7f5eb02d4bcd5f48614f0bdd83e989c8.png) | ![](../Images/816e46061b859d3e86b97898546ba54e.png)
    | ![](../Images/557b02f05f5e61129f507c2c5cf36680.png) |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '*Fudgeflake.*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/0038136785243878c5d65c22e2fbea83.png) | ![](../Images/318d2a86dda6d6fa4be50beec4f53a23.png)
    | ![](../Images/f10c25ae967d4ec252ecfe65bea2a0f1.png) | ![](../Images/d234e8cf1c487e4b5d64758279151186.png)
    | ![](../Images/5110f7cf92608a3e921f1405fa83284f.png) |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| ![](../Images/6af0ead604e210dbf3e1506b941817a4.png) | ![](../Images/78ce46f6abf3a652ec3756e102d72bf9.png)
    | ![](../Images/6b9d9a079bbaffc1873580e90d165007.png) | ![](../Images/c751c2efa1df38ad27fb78eb803d7466.png)
    | ![](../Images/b5ffc5d31872f5ca41a394906b5837dc.png) |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '**Turtle graphics (hard).** Write a program to produce each of the following
    recursive patterns without lifting the pen or tracing over the same line segment
    more than once.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Sierpinski arrowhead.*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/6db8b417a535330ee7ed358a0a3b3287.png) | ![](../Images/27682b1e2f94a8825655c1cf9bf3318f.png)
    | ![](../Images/4ed2b323fd2f5a3eb2fb880a6c1f5084.png) | ![](../Images/20c1d59ddabb2f984aa1cbd2a442228f.png)
    | ![](../Images/bf44d232c0619aaf357b556e6cb7b9a0.png) |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '*Sierpinski curve.*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![](../Images/12650176a8215f37e66ec9bdc876b976.png) | ![](../Images/e6643e9021562bbf6eb26b8fd499d4e6.png)
    | ![](../Images/2ed5ca1c14893bc72a282f4d71fd65cd.png) | ![](../Images/ec0f05b7a1cbe7cb057d733b1ea17f17.png)
    | ![](../Images/055957116ccf0e2b969f8d37ddeca33b.png) |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '**Mandelbrot trajectory.** Write an interactive program [Trajectory.java](Trajectory.java.html)
    that plots the sequence of points in the Mandelbrot iteration in the complex plane.
    If the user clicks on (x, y), plot the sequence of iterates for z = x + iy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Faster Mandelbrot.** Speed up Mandelbrot by performing the computation directly
    instead of using `Complex`. Compare. Incorporate periodicity checking or [boundary
    tracing](http://www.geocities.com/CapeCanaveral/5003/mandel.htm) for further improvements.
    Use divide-and-conquer: choose 4 corners of a rectangle and a few random points
    inside; if they''re all the same color, color the whole rectangle that color;
    otherwise divide into 4 rectangles and recur.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Random walker.** Write a data type `RandomWalker` that simulates the motion
    of a random walker in the plane that starts at the origin and makes a random step
    (left, right, up, or down) at each step. Include a method `step()` that moves
    the random walker one step and a method `distance()` that returns the distance
    the random walker is from the origin. Use this data type to formulate a hypothesis
    as to how far (as a function of N) the random walker is from the origin after
    N steps. (See also Exercise 1.x.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Big rational numbers.** Create a data type [BigRational.java](BigRational.java.html)
    for positive rational numbers, where the numerators and denominators can be arbitrarily
    large. *Hint*: use [java.math.BigInteger](https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deluxe turtle graphics.** Extend Turtle in various ways. Make `DeluxeTurtle`
    that adds color, etc. Add a version that supports error checking. For example,
    throw a `TurtleOutOfBounds` exception if turtle goes outside designated boundary.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program [FourChargeClient.java](FourChargeClient.java.html) that takes
    a `double` command-line argument `r`, creates four `Charge` objects that are each
    distance `r` from the center of the screen (0.5, 0.5), and prints the potential
    at location (0.25, 0.5) due to the combined four charges. All four charges should
    have the same unit charge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does program [Bug1.java](Bug1.java.html) create a `java.lang.NullPointerException`
    when executed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer:* the programmer probably intended to make the no argument constructor
    set the string to `hello`. However, it has a return type (`void`) so it is an
    ordinary instance method instead of a constructor. It just happens to have the
    same name as the class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why does program [Bug2.java](Bug2.java.html) create a `java.lang.NullPointerException`
    when executed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a data type `Die` for rolling a fair die, say with 6 sides. Include
    a mutator method `roll()` and an accessor method `value`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a mutable data type `LFSR` for a linear feedback shift register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a mutable data type `Odometer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Complex trigonometric functions.** Add methods to [Complex.java](Complex.java.html)
    support trigonometric and exponential functions on complex numbers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(\exp(a + ib) = e^a \cos(b) + i \, e^a \sin(b)\)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(\sin(a + ib) = \sin(a) \cosh(b) + i \cos(a) \sinh(b)\)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(\cos(a + ib) = \cos(a) \cosh(b) - i \sin(a) \sinh(b)\)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(\tan(a + ib) = \sin(a + ib) \;/\; \cos(a + ib)\)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a data type `VotingMachine` for tabulating votes. Include mutator
    methods `voteRepublican()`, `voteDemocrat()`, and `voteIndependent()`. Include
    an accessor method `getCount()` to retrieve the total number of votes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you try to compile and execute the following code fragment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: it complains that `x` may not be initialized, and does not compile.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What happens when you try to compile and execute the following code fragment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: it compiles and prints out `null`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is wrong with the following code fragment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: it produces a `NullPointerException` because we forgot use `new`
    to create each individual `Dog` object. To correct, add the following loop after
    the array initialization statement.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the following code fragment print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What's wrong with the following code fragment that swaps the Student objects
    x and y?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Answer*: First, the data type `Student` does not have a no-argument constructor.
    If it did, then it would technically be correct, but the `new Student()` line
    is unnecessary and wasteful. It allocates memory for a new student object, sets
    `swap` equal to that memory address, then immediately sets `swap` equal to the
    memory address of `x`. The allocated memory is no longer accessible. The following
    version is correct.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Find inputs to the Mandelbrot update formula that make it converge (z0 = 1/2
    + 0i), cycle with a period of 1 (z0 = -2 + 0i), cycle with a period of 2 (z0 =
    -1 + 0i), or stay bounded without converging (z0 = -3/2 + 0i).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Point3D.** Create a data type for points in 3 dimensional space. Include
    a constructor that takes three real coordinates x, y, and z. Include methods `distance`,
    `distanceSquared`, and `distanceL1` for the Euclidean distance, Euclidean distance
    squared, and the L1-distance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a data type [PhoneNumber.java](PhoneNumber.java.html) that represents
    a US phone number. The constructor should take three string arguments, the area
    code (3 decimal digits), the exchange (3 decimal digits) and the extension (4
    decimal digits). Include a `toString` method that prints out phone numbers of
    the form (800) 867-5309. Include a method so that `p.equals(q)` returns `true`
    if the phone numbers p and q are the same, and `false` otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redo [PhoneNumber.java](PhoneNumber.java.html) but implement it using three
    integer fields. Make the constructor take three integer arguments. Comment on
    the advantages and disadvantages of this approach over the string representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Answer*: more efficient with time and memory. More hassle to handle leading
    0s correct in constructor and `toString` method.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a program to draw the field lines for a *uniform field*. Arrange N evenly-spaced
    particles with charge e in a vertical column, and arrange N particles with charge
    -e in a vertical column so that each charge on one side is lined up with a corresponding
    charge on the other side. This simulates the field inside a plane capacitor. What
    can you say about the resulting electric field? A. Almost uniform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Equipotential surfaces.** An *equipotential surface* is the set of all points
    that have the same electric potential V. Given a group of N point charges, it
    is useful to visualize the electric potential by plotting equipotential surfaces
    (aka contour plots). Program [Equipotential.java](Equipotential.java.html) draws
    a line every 5V by computing the potential at each gridpoint and checking whether
    the potential is within 1 pixel of a multiple of 5V. Since the electric field
    E measures how much the potential changes, E * eps is the range that the potential
    changes in a distance of 1 pixel. It relies on the helper program [DeluxeCharge.java](DeluxeCharge.java.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ![Electric equipotential](../Images/1eafa06a86b1e345bd7554b4f844ce5d.png)
    |                | ![Electric equipotential](../Images/fbde9c090fa57146308f21276caeab70.png)
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: It is also interesting to plot the field lines and the equipotential lines simultaneously.
    The field lines are always perpendicular the the equipotential lines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Color palettes.** Create Mandelbrot and Julia sets using different color
    palettes. For example, this scheme was proposed by Hubert Grassmann'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: and produces a striking image of the Julia set
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Julia set](../Images/5accc3563d63b28f21198231a368561a.png)'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
