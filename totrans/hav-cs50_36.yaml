- en: Lecture 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8讲
- en: 原文：[https://cs50.harvard.edu/python/notes/8/](https://cs50.harvard.edu/python/notes/8/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/python/notes/8/](https://cs50.harvard.edu/python/notes/8/)
- en: '[Object-Oriented Programming](#object-oriented-programming)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[面向对象编程](#object-oriented-programming)'
- en: '[Classes](#classes)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类](#classes)'
- en: '[`raise`](#raise)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[抛出异常](#raise)'
- en: '[Decorators](#decorators)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[装饰器](#decorators)'
- en: '[Connecting to Previous Work in this Course](#connecting-to-previous-work-in-this-course)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将课程中的先前工作联系起来](#connecting-to-previous-work-in-this-course)'
- en: '[Class Methods](#class-methods)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类方法](#class-methods)'
- en: '[Static Methods](#static-methods)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[静态方法](#static-methods)'
- en: '[Inheritance](#inheritance)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[继承](#inheritance)'
- en: '[Inheritance and Exceptions](#inheritance-and-exceptions)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[继承和异常](#inheritance-and-exceptions)'
- en: '[Operator Overloading](#operator-overloading)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[运算符重载](#operator-overloading)'
- en: '[Summing Up](#summing-up)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Object-Oriented Programming
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: There are different paradigms of programming. As you learn other languages,
    you will start recognizing patterns like these.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程有不同的范式。当你学习其他语言时，你将开始识别这些模式。
- en: Up until this point, you have worked procedurally step-by-step.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，你一直是按步骤进行过程式编程的。
- en: Object-oriented programming (OOP) is a compelling solution to programming-related
    problems.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是解决编程相关问题的有力解决方案。
- en: 'To begin, type `code student.py` in the terminal window and code as follows:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在终端窗口中输入`code student.py`，然后按照以下方式编写代码：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice that this program follows a procedural, step-by-step paradigm: Much
    like you have seen in prior parts of this course.'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这个程序遵循的是一种过程式、按步骤的范式：就像你在课程的前几部分看到的那样。
- en: Drawing on our work from previous weeks, we can create functions to abstract
    away parts of this program.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借鉴前几周的工作，我们可以创建函数来抽象掉程序的一部分。
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how `get_name` and `get_house` abstract away some of the needs of our
    `main` function. Further, notice how the final lines of the code above tell the
    interpreter to run the `main` function.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`get_name`和`get_house`如何抽象掉`main`函数的一些需求。此外，注意代码的最后一行是如何告诉解释器运行`main`函数的。
- en: We can further simplify our program by storing the student as a `tuple`. A `tuple`
    is a sequence of values. Unlike a `list`, a `tuple` can’t be modified. In spirit,
    we are returning two values.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将学生存储为`tuple`来进一步简化我们的程序。`tuple`是一系列值。与`list`不同，`tuple`不能被修改。在精神上，我们正在返回两个值。
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how `get_student` returns `name, house`.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`get_student`返回`name, house`。
- en: Packing that `tuple`, such that we are able to return both items to a variable
    called `student`, we can modify our code as follows.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`tuple`打包，以便我们能够将两个项目返回到名为`student`的变量中，我们可以按如下方式修改我们的代码。
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that `(name, house)` explicitly tells anyone reading our code that we
    are returning two values within one. Further, notice how we can index into `tuple`s
    using `student[0]` or `student[1]`.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`(name, house)`明确地告诉阅读我们代码的人，我们在一个返回值中返回两个值。此外，注意我们如何使用`student[0]`或`student[1]`来索引`tuple`。
- en: '`tuple`s are immutable, meaning we cannot change those values. Immutability
    is a way by which we can program defensively.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuple`是不可变的，这意味着我们无法更改这些值。不可变性是我们进行防御性编程的一种方式。'
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that this code produces an error. Since `tuple`s are immutable, we’re
    not able to reassign the value of `student[1]`.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这段代码会产生错误。由于`tuple`是不可变的，我们无法重新分配`student[1]`的值。
- en: If we wanted to provide our fellow programmers flexibility, we could utilize
    a `list` as follows.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要给其他程序员提供灵活性，我们可以使用`list`如下。
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that lists are mutable. That is, the order of `house` and `name` can be
    switched by a programmer. You might decide to utilize this in some cases where
    you want to provide more flexibility at the cost of the security of your code.
    After all, if the order of those values is changeable, programmers that work with
    you could make mistakes down the road.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意列表是可变的。也就是说，`house`和`name`的顺序可以被程序员切换。你可能会决定在某些需要提供更多灵活性但以代码安全性为代价的情况下使用它。毕竟，如果这些值的顺序可以更改，与你一起工作的程序员可能会在将来犯错误。
- en: A dictionary could also be utilized in this implementation. Recall that dictionaries
    provide a key-value pair.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个实现中也可以使用字典。回想一下，字典提供键值对。
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice in this case, two key-value pairs are returned. An advantage of this
    approach is that we can index into this dictionary using the keys.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意在这个例子中，返回了两个键值对。这种方法的优点是我们可以使用键来索引这个字典。
- en: Still, our code can be further improved. Notice that there is an unneeded variable.
    We can remove `student = {}` because we don’t need to create an empty dictionary.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，我们的代码还可以进一步改进。请注意，存在一个不必要的变量。我们可以移除 `student = {}`，因为我们不需要创建一个空字典。
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice we can utilize `{}` braces in the `return` statement to create the dictionary
    and return it all in the same line.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们可以在 `return` 语句中使用 `{}` 大括号来创建字典并在同一行返回它。
- en: We can provide our special case with Padma in our dictionary version of our
    code.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在我们的代码字典版本中为 Padma 提供一个特殊案例。
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how, similar in spirit to our previous iterations of this code, we can
    utilize the key names to index into our student dictionary.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，与之前代码的迭代类似，我们可以利用键名来索引我们的学生字典。
- en: Classes
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: Classes are a way by which, in object-oriented programming, we can create our
    own type of data and give them names.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面向对象编程中，类提供了一种创建我们自己的数据类型并为其命名的方法。
- en: A class is like a mold for a type of data – where we can invent our own data
    type and give them a name.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类就像是一种数据类型的模具——在那里我们可以发明我们自己的数据类型并为其命名。
- en: 'We can modify our code as follows to implement our own class called `Student`:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式修改我们的代码来实现我们自己的名为 `Student` 的类：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice by convention that `Student` is capitalized. Further, notice the `...`
    simply means that we will later return to finish that portion of our code. Further,
    notice that in `get_student`, we can create a `student` of class `Student` using
    the syntax `student = Student()`. Further, notice that we utilize “dot notation”
    to access attributes of this variable `student` of class `Student`.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意按照惯例，`Student` 是大写的。进一步，注意 `...` 简单地意味着我们将在稍后返回并完成代码的这一部分。进一步，注意在 `get_student`
    中，我们可以使用语法 `student = Student()` 创建一个 `Student` 类的 `student`。进一步，注意我们利用“点表示法”来访问这个
    `student` 变量的属性。
- en: Any time you create a class and you utilize that blueprint to create something,
    you create what is called an “object” or an “instance”. In the case of our code,
    `student` is an object.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何时候你创建一个类并利用这个蓝图来创建东西，你就创建了一个“对象”或“实例”。在我们的代码中，`student` 是一个对象。
- en: 'Further, we can lay some groundwork for the attributes that are expected inside
    an object whose class is `Student`. We can modify our code as follows:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们可以为期望在类 `Student` 的对象内部拥有的属性打下一些基础。我们可以按照以下方式修改我们的代码：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that within `Student`, we standardize the attributes of this class. We
    can create a function within `class Student`, called a “method”, that determines
    the behavior of an object of class `Student`. Within this function, it takes the
    `name` and `house` passed to it and assigns these variables to this object. Further,
    notice how the constructor `student = Student(name, house)` calls this function
    within the `Student` class and creates a `student`. `self` refers to the current
    object that was just created.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意在 `Student` 中，我们标准化了这个类的属性。我们可以在 `class Student` 中创建一个函数，称为“方法”，它决定了类 `Student`
    的对象的行为。在这个函数中，它接收传递给它的 `name` 和 `house` 并将这些变量分配给这个对象。进一步，注意构造函数 `student = Student(name,
    house)` 在 `Student` 类中调用这个函数并创建一个 `student`。`self` 指的是刚刚创建的当前对象。
- en: 'We can simplify our code as follows:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将代码简化如下：
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how `return Student(name, house)` simplifies the previous iteration of
    our code where the constructor statement was run on its own line.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `return Student(name, house)` 如何简化了我们之前代码中的迭代，其中构造函数语句单独占一行。
- en: You can learn more in Python’s documentation of [classes](https://docs.python.org/3/tutorial/classes.html).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的[类](https://docs.python.org/3/tutorial/classes.html)文档中了解更多信息。
- en: '`raise`'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`raise`'
- en: 'Object-oriented programming encourages you to encapsulate all the functionality
    of a class within the class definition. What if something goes wrong? What if
    someone tries to type in something random? What if someone tries to create a student
    without a name? Modify your code as follows:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程鼓励你将类的所有功能封装在类定义中。如果出了问题怎么办？如果有人输入了随机的数据怎么办？如果有人试图创建一个没有名字的学生怎么办？请按照以下方式修改你的代码：
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how we check now that a name is provided and a proper house is designated.
    It turns out we can create our own exceptions that alerts the programmer to a
    potential error created by the user called `raise`. In the case above, we raise
    `ValueError` with a specific error message.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们现在检查是否提供了名字并且指定了合适的宿舍。结果证明我们可以创建自己的异常，通过 `raise` 通知程序员用户可能创建的错误。在上面的例子中，我们使用特定的错误消息引发
    `ValueError`。
- en: 'It just so happens that Python allows you to create a specific function by
    which you can print the attributes of an object. Modify your code as follows:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰巧的是，Python 允许你创建一个特定的函数，通过它可以打印对象的属性。按照以下方式修改你的代码：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how `def __str__(self)` provides a means by which a student is returned
    when called. Therefore, you can now, as the programmer, print an object, its attributes,
    or almost anything you desire related to that object.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `def __str__(self)` 提供了一种在调用时返回学生的方式。因此，现在作为程序员，你可以打印对象、其属性或与该对象相关的几乎所有内容。
- en: '`__str__` is a built-in method that comes with Python classes. It just so happens
    that we can create our own methods for a class as well! Modify your code as follows:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__str__` 是 Python 类自带的一个内置方法。碰巧的是，我们也可以为类创建自己的方法！按照以下方式修改你的代码：'
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how we define our own method `charm`. Unlike dictionaries, classes can
    have built-in functions called methods. In this case, we define our `charm` method
    where specific cases have specific results. Further, notice that Python has the
    ability to utilize emojis directly in our code.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们定义了自己的方法 `charm`。与字典不同，类可以有内置的函数，称为方法。在这种情况下，我们定义了 `charm` 方法，其中特定的案例有特定的结果。此外，注意
    Python 有能力在我们的代码中直接使用表情符号。
- en: 'Before moving forward, let us remove our patronus code. Modify your code as
    follows:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继续前进之前，让我们移除我们的守护神代码。按照以下方式修改你的代码：
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice how we have only two methods: `__init__` and `__str__`.'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们只有两个方法：`__init__` 和 `__str__`。
- en: Decorators
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'Properties can be utilized to harden our code. In Python, we define properties
    using function “decorators”, which begin with `@`. Modify your code as follows:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性可以被用来加固我们的代码。在 Python 中，我们使用以 `@` 开头的函数“装饰器”来定义属性。按照以下方式修改你的代码：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how we’ve written `@property` above a function called `house`. Doing
    so defines `house` as a property of our class. With `house` as a property, we
    gain the ability to define how some attribute of our class, `_house`, should be
    set and retrieved. Indeed, we can now define a function called a “setter”, via
    `@house.setter`, which will be called whenever the house property is set—for example,
    with `student.house = "Gryffindor"`. Here, we’ve made our setter validate values
    of `house` for us. Notice how we raise a `ValueError` if the value of `house`
    is not any of the Harry Potter houses, otherwise, we’ll use `house` to update
    the value of `_house`. Why `_house` and not `house`? `house` is a property of
    our class, with functions via which a user attempts to set our class attribute.
    `_house` is that class attribute itself. The leading underscore, `_`, indicates
    to users they need not (and indeed, shouldn’t!) modify this value directly. `_house`
    should *only* be set through the `house` setter. Notice how the `house` property
    simply returns that value of `_house`, our class attribute that has presumably
    been validated using our `house` setter. When a user calls `student.house`, they’re
    getting the value of `_house` through our `house` “getter”.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何在名为 `house` 的函数上方写上 `@property` 的。这样做定义了 `house` 为我们类的一个属性。有了 `house`
    属性，我们就能定义如何设置和检索我们类的一些属性，例如 `_house`。确实，我们现在可以通过 `@house.setter` 定义一个名为“setter”的函数，每当设置
    house 属性时都会被调用——例如，使用 `student.house = "Gryffindor"`。在这里，我们让我们的 setter 为我们验证 `house`
    的值。注意，如果 `house` 的值不是哈利·波特的任何一个学院，我们会抛出一个 `ValueError`，否则我们会使用 `house` 更新 `_house`
    的值。为什么是 `_house` 而不是 `house`？`house` 是我们类的一个属性，用户通过它尝试设置我们的类属性。`_house` 是那个类属性本身。前导下划线
    `_` 表示用户不需要（实际上也不应该！）直接修改这个值。`_house` 应该*仅*通过 `house` setter 来设置。注意 `house` 属性只是简单地返回
    `_house` 的值，这是我们通过 `house` setter 可能已经验证过的类属性。当用户调用 `student.house` 时，他们通过我们的
    `house` “getter” 获取 `_house` 的值。
- en: 'In addition to the name of the house, we can protect the name of our student
    as well. Modify your code as follows:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了房子的名字，我们还可以保护我们学生的名字。按照以下方式修改你的代码：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how, much like the previous code, we provide a getter and setter for
    the name.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，和之前的代码类似，我们为名称提供了 getter 和 setter。
- en: You can learn more in Python’s documentation of [methods](https://docs.python.org/3/tutorial/classes.html).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 Python 的 [方法](https://docs.python.org/3/tutorial/classes.html) 文档中了解更多信息。
- en: Connecting to Previous Work in this Course
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到本课程中的先前工作
- en: While not explicitly stated in past portions of this course, you have been using
    classes and objects the whole way through.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管在课程的前几部分没有明确说明，但你一直在使用类和对象。
- en: If you dig into the documentation of `int`, you’ll see that it is a class with
    a constructor. It’s a blueprint for creating objects of type `int`. You can learn
    more in Python’s documentation of [`int`](https://docs.python.org/3/library/functions.html#int).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你深入研究`int`的文档，你会发现它是一个具有构造函数的类。它是创建`int`类型对象的蓝图。你可以在Python的`int`文档中了解更多信息，链接为[Python的`int`文档](https://docs.python.org/3/library/functions.html#int)。
- en: Strings too are also a class. If you have used `str.lower()`, you were using
    a method that came within the `str` class. You can learn more in Python’s documentation
    of [`str`](https://docs.python.org/3/library/stdtypes.html#str).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串也是一个类。如果你使用过`str.lower()`，你就是在使用`str`类中的方法。你可以在Python的`str`文档中了解更多信息，链接为[Python的`str`文档](https://docs.python.org/3/library/stdtypes.html#str)。
- en: '`list` is also a class. Looking at that documentation for `list`, you can see
    the methods that are contained therein, like `list.append()`. You can learn more
    in Python’s documentation of [`list`](https://docs.python.org/3/library/stdtypes.html#list).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`也是一个类。查看`list`的文档，你可以看到其中包含的方法，如`list.append()`。你可以在Python的`list`文档中了解更多信息，链接为[Python的`list`文档](https://docs.python.org/3/library/stdtypes.html#list)。'
- en: '`dict` is also a class within Python. You can learn more in Python’s documentation
    of [`dict`](https://docs.python.org/3/library/stdtypes.html#dict).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict`也是Python中的一个类。你可以在Python的`dict`文档中了解更多信息，链接为[Python的`dict`文档](https://docs.python.org/3/library/stdtypes.html#dict)。'
- en: 'To see how you have been using classes all along, go to your console and type
    `code type.py` and then code as follows:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解你一直是如何使用类的，请打开你的控制台，输入`code type.py`，然后按照以下方式编写代码：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how by executing this code, it will display that the class of `50` is
    `int`.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，通过执行这段代码，它将显示`50`的类是`int`。
- en: 'We can also apply this to `str` as follows:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以将此应用于`str`，如下所示：
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how executing this code will indicate this is of the class `str`.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，执行这段代码将表明这是`str`类。
- en: 'We can also apply this to `list` as follows:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以按照以下方式应用于`list`：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how executing this code will indicate this is of the class `list`.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，执行这段代码将表明这是`list`类。
- en: 'We can also apply this to a `list` using the name of Python’s built-in `list`
    class as follows:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以使用Python内置的`list`类的名称来应用于`list`，如下所示：
- en: '[PRE21]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how executing this code will indicate this is of the class `list`.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，执行这段代码将表明这是`list`类。
- en: 'We can also apply this to `dict` as follows:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以将此应用于`dict`，如下所示：
- en: '[PRE22]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how executing this code will indicate this is of the class `dict`.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，执行这段代码将表明这是`dict`类。
- en: 'We can also apply this to a `dict` using the name of Python’s built in `dict`
    class as follows:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以使用Python内置的`dict`类的名称来应用于`dict`，如下所示：
- en: '[PRE23]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how executing this code will indicate this is of the class `dict`.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，执行这段代码将表明这是`dict`类。
- en: Class Methods
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法
- en: Sometimes, we want to add functionality to a class itself, not to instances
    of that class.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，我们希望给类本身添加功能，而不是给该类的实例添加。
- en: '`@classmethod` is a function that we can use to add functionality to a class
    as a whole.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@classmethod`是一个函数，我们可以用它来给整个类添加功能。'
- en: 'Here’s an example of *not* using a class method. In your terminal window, type
    `code hat.py` and code as follows:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是一个**不**使用类方法的例子。在你的终端窗口中，输入`code hat.py`并按照以下方式编写代码：
- en: '[PRE24]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how when we pass the name of the student to the sorting hat, it will
    tell us what house is assigned to the student. Notice that `hat = Hat()` instantiates
    a `hat`. The `sort` functionality is always handled by the *instance* of the class
    `Hat`. By executing `hat.sort("Harry")`, we pass the name of the student to the
    `sort` method of the particular instance of `Hat`, which we’ve called `hat`.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，当我们把学生的名字传递给排序帽子时，它会告诉我们学生被分配到了哪个学院。注意`hat = Hat()`实例化了`hat`。`sort`功能始终由类的*实例*处理。通过执行`hat.sort("Harry")`，我们向`Hat`的特定实例的`sort`方法传递了学生的名字，我们称之为`hat`。
- en: 'We may want, though, to run the `sort` function without creating a particular
    instance of the sorting hat (there’s only one, after all!). We can modify our
    code as follows:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，我们可能希望运行`sort`函数而不创建特定的排序帽子实例（毕竟只有一个）。我们可以修改我们的代码如下：
- en: '[PRE25]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how the `__init__` method is removed because we don’t need to instantiate
    a hat anywhere in our code. `self`, therefore, is no longer relevant and is removed.
    We specify this `sort` as a `@classmethod`, replacing `self` with `cls`. Finally,
    notice how `Hat` is capitalized by convention near the end of this code, because
    this is the name of our class.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `__init__` 方法被移除，因为我们不需要在我们的代码中的任何地方实例化一顶帽子。因此，`self` 就不再相关，并被移除。我们指定这个
    `sort` 为一个 `@classmethod`，用 `cls` 替换 `self`。最后，注意在代码的末尾，根据惯例，`Hat` 被大写，因为这是我们的类名。
- en: 'Returning back to `students.py` we can modify our code as follows, addressing
    some missed opportunities related to `@classmethod`s:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回到 `students.py`，我们可以修改我们的代码如下，解决一些与 `@classmethod` 相关的遗漏机会：
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that `get_student` is removed and a `@classmethod` called `get` is created.
    This method can now be called without having to create a student first.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `get_student` 被移除，并创建了一个名为 `get` 的 `@classmethod`。现在，可以调用此方法而无需首先创建一个学生。
- en: Static Methods
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法
- en: It turns out that besides `@classmethod`s, which are distinct from instance
    methods, there are other types of methods as well.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果表明，除了与实例方法不同的 `@classmethod` 之外，还有其他类型的函数。
- en: Using `@staticmethod` may be something you might wish to explore. While not
    covered explicitly in this course, you are welcome to go and learn more about
    static methods and their distinction from class methods.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@staticmethod` 可能是你希望探索的事情。虽然本课程没有明确涵盖，但你欢迎去学习更多关于静态方法和它们与类方法的区别。
- en: Inheritance
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is, perhaps, the most powerful feature of object-oriented programming.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承可能是面向对象编程中最强大的特性。
- en: It just so happens that you can create a class that “inherits” methods, variables,
    and attributes from another class.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恰好可以创建一个“继承”其他类的方法、变量和属性的类。
- en: 'In the terminal, execute `code wizard.py`. Code as follows:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中，执行 `code wizard.py`。编写如下代码：
- en: '[PRE27]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that there is a class above called `Wizard` and a class called `Student`.
    Further, notice that there is a class called `Professor`. Both students and professors
    have names. Also, both students and professors are wizards. Therefore, both `Student`
    and `Professor` inherit the characteristics of `Wizard`. Within the “child” class
    `Student`, `Student` can inherit from the “parent” or “super” class `Wizard` as
    the line `super().__init__(name)` runs the `init` method of `Wizard`. Finally,
    notice that the last lines of this code create a wizard called Albus, a student
    called Harry, and so on.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到有一个名为 `Wizard` 的类和一个名为 `Student` 的类。此外，还有一个名为 `Professor` 的类。学生和教授都有名字。学生和教授都是巫师。因此，`Student`
    和 `Professor` 继承了 `Wizard` 的特性。在“子”类 `Student` 中，`Student` 可以从“父”或“超”类 `Wizard`
    继承，如 `super().__init__(name)` 运行 `Wizard` 的 `init` 方法。最后，注意代码的最后几行创建了一个名为 Albus
    的巫师，一个名为 Harry 的学生，等等。
- en: Inheritance and Exceptions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承和异常
- en: While we have just introduced inheritance, we have been using this all along
    during our use of exceptions.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们刚刚介绍了继承，但我们一直在使用异常时使用它。
- en: 'It just so happens that exceptions come in a hierarchy, where there are children,
    parent, and grandparent classes. These are illustrated below:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恰好异常有一个层次结构，其中包含子类、父类和祖父母类。这些在下图中展示：
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can learn more in Python’s documentation of [exceptions](https://docs.python.org/3/library/exceptions.html).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 Python 的 [异常](https://docs.python.org/3/library/exceptions.html) 文档中了解更多信息。
- en: Operator Overloading
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Some operators such as `+` and `-` can be “overloaded” such that they can have
    more abilities beyond simple arithmetic.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些运算符，如 `+` 和 `-`，可以被“重载”，以便它们可以拥有超出简单算术的更多能力。
- en: 'In your terminal window, type `code vault.py`. Then, code as follows:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，输入 `code vault.py`。然后，编写如下代码：
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how the `__str__` method returns a formatted string. Further, notice
    how the `__add__` method allows for the addition of the values of two vaults.
    `self` is what is on the left of the `+` operand. `other` is what is right of
    the `+`.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `__str__` 方法返回一个格式化的字符串。此外，注意到 `__add__` 方法允许两个保险库值的相加。`self` 是 `+` 运算符左侧的内容。`other`
    是 `+` 运算符右侧的内容。
- en: You can learn more in Python’s documentation of [operator overloading](https://docs.python.org/3/reference/datamodel.html#special-method-names).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 Python 的 [运算符重载](https://docs.python.org/3/reference/datamodel.html#special-method-names)
    文档中了解更多信息。
- en: Summing Up
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Now, you’ve learned a whole new level of capability through object-oriented
    programming.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经通过面向对象编程学习了一个全新的能力级别。
- en: Object-oriented programming
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Classes
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: '`raise`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raise`'
- en: Class Methods
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法
- en: Static Methods
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: Inheritance
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Operator Overloading
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载
