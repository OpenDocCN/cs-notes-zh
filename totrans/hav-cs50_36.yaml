- en: Lecture 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/python/notes/8/](https://cs50.harvard.edu/python/notes/8/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Object-Oriented Programming](#object-oriented-programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Classes](#classes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`raise`](#raise)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Decorators](#decorators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Connecting to Previous Work in this Course](#connecting-to-previous-work-in-this-course)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Class Methods](#class-methods)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Static Methods](#static-methods)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Inheritance](#inheritance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Inheritance and Exceptions](#inheritance-and-exceptions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Operator Overloading](#operator-overloading)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different paradigms of programming. As you learn other languages,
    you will start recognizing patterns like these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up until this point, you have worked procedurally step-by-step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming (OOP) is a compelling solution to programming-related
    problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To begin, type `code student.py` in the terminal window and code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that this program follows a procedural, step-by-step paradigm: Much
    like you have seen in prior parts of this course.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Drawing on our work from previous weeks, we can create functions to abstract
    away parts of this program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `get_name` and `get_house` abstract away some of the needs of our
    `main` function. Further, notice how the final lines of the code above tell the
    interpreter to run the `main` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can further simplify our program by storing the student as a `tuple`. A `tuple`
    is a sequence of values. Unlike a `list`, a `tuple` can’t be modified. In spirit,
    we are returning two values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `get_student` returns `name, house`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Packing that `tuple`, such that we are able to return both items to a variable
    called `student`, we can modify our code as follows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `(name, house)` explicitly tells anyone reading our code that we
    are returning two values within one. Further, notice how we can index into `tuple`s
    using `student[0]` or `student[1]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`tuple`s are immutable, meaning we cannot change those values. Immutability
    is a way by which we can program defensively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this code produces an error. Since `tuple`s are immutable, we’re
    not able to reassign the value of `student[1]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we wanted to provide our fellow programmers flexibility, we could utilize
    a `list` as follows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that lists are mutable. That is, the order of `house` and `name` can be
    switched by a programmer. You might decide to utilize this in some cases where
    you want to provide more flexibility at the cost of the security of your code.
    After all, if the order of those values is changeable, programmers that work with
    you could make mistakes down the road.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A dictionary could also be utilized in this implementation. Recall that dictionaries
    provide a key-value pair.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice in this case, two key-value pairs are returned. An advantage of this
    approach is that we can index into this dictionary using the keys.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Still, our code can be further improved. Notice that there is an unneeded variable.
    We can remove `student = {}` because we don’t need to create an empty dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice we can utilize `{}` braces in the `return` statement to create the dictionary
    and return it all in the same line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can provide our special case with Padma in our dictionary version of our
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how, similar in spirit to our previous iterations of this code, we can
    utilize the key names to index into our student dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes are a way by which, in object-oriented programming, we can create our
    own type of data and give them names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class is like a mold for a type of data – where we can invent our own data
    type and give them a name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can modify our code as follows to implement our own class called `Student`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice by convention that `Student` is capitalized. Further, notice the `...`
    simply means that we will later return to finish that portion of our code. Further,
    notice that in `get_student`, we can create a `student` of class `Student` using
    the syntax `student = Student()`. Further, notice that we utilize “dot notation”
    to access attributes of this variable `student` of class `Student`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Any time you create a class and you utilize that blueprint to create something,
    you create what is called an “object” or an “instance”. In the case of our code,
    `student` is an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Further, we can lay some groundwork for the attributes that are expected inside
    an object whose class is `Student`. We can modify our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that within `Student`, we standardize the attributes of this class. We
    can create a function within `class Student`, called a “method”, that determines
    the behavior of an object of class `Student`. Within this function, it takes the
    `name` and `house` passed to it and assigns these variables to this object. Further,
    notice how the constructor `student = Student(name, house)` calls this function
    within the `Student` class and creates a `student`. `self` refers to the current
    object that was just created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can simplify our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `return Student(name, house)` simplifies the previous iteration of
    our code where the constructor statement was run on its own line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [classes](https://docs.python.org/3/tutorial/classes.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`raise`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Object-oriented programming encourages you to encapsulate all the functionality
    of a class within the class definition. What if something goes wrong? What if
    someone tries to type in something random? What if someone tries to create a student
    without a name? Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we check now that a name is provided and a proper house is designated.
    It turns out we can create our own exceptions that alerts the programmer to a
    potential error created by the user called `raise`. In the case above, we raise
    `ValueError` with a specific error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It just so happens that Python allows you to create a specific function by
    which you can print the attributes of an object. Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `def __str__(self)` provides a means by which a student is returned
    when called. Therefore, you can now, as the programmer, print an object, its attributes,
    or almost anything you desire related to that object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`__str__` is a built-in method that comes with Python classes. It just so happens
    that we can create our own methods for a class as well! Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we define our own method `charm`. Unlike dictionaries, classes can
    have built-in functions called methods. In this case, we define our `charm` method
    where specific cases have specific results. Further, notice that Python has the
    ability to utilize emojis directly in our code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before moving forward, let us remove our patronus code. Modify your code as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how we have only two methods: `__init__` and `__str__`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Properties can be utilized to harden our code. In Python, we define properties
    using function “decorators”, which begin with `@`. Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we’ve written `@property` above a function called `house`. Doing
    so defines `house` as a property of our class. With `house` as a property, we
    gain the ability to define how some attribute of our class, `_house`, should be
    set and retrieved. Indeed, we can now define a function called a “setter”, via
    `@house.setter`, which will be called whenever the house property is set—for example,
    with `student.house = "Gryffindor"`. Here, we’ve made our setter validate values
    of `house` for us. Notice how we raise a `ValueError` if the value of `house`
    is not any of the Harry Potter houses, otherwise, we’ll use `house` to update
    the value of `_house`. Why `_house` and not `house`? `house` is a property of
    our class, with functions via which a user attempts to set our class attribute.
    `_house` is that class attribute itself. The leading underscore, `_`, indicates
    to users they need not (and indeed, shouldn’t!) modify this value directly. `_house`
    should *only* be set through the `house` setter. Notice how the `house` property
    simply returns that value of `_house`, our class attribute that has presumably
    been validated using our `house` setter. When a user calls `student.house`, they’re
    getting the value of `_house` through our `house` “getter”.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In addition to the name of the house, we can protect the name of our student
    as well. Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how, much like the previous code, we provide a getter and setter for
    the name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [methods](https://docs.python.org/3/tutorial/classes.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to Previous Work in this Course
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While not explicitly stated in past portions of this course, you have been using
    classes and objects the whole way through.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you dig into the documentation of `int`, you’ll see that it is a class with
    a constructor. It’s a blueprint for creating objects of type `int`. You can learn
    more in Python’s documentation of [`int`](https://docs.python.org/3/library/functions.html#int).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings too are also a class. If you have used `str.lower()`, you were using
    a method that came within the `str` class. You can learn more in Python’s documentation
    of [`str`](https://docs.python.org/3/library/stdtypes.html#str).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list` is also a class. Looking at that documentation for `list`, you can see
    the methods that are contained therein, like `list.append()`. You can learn more
    in Python’s documentation of [`list`](https://docs.python.org/3/library/stdtypes.html#list).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dict` is also a class within Python. You can learn more in Python’s documentation
    of [`dict`](https://docs.python.org/3/library/stdtypes.html#dict).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see how you have been using classes all along, go to your console and type
    `code type.py` and then code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how by executing this code, it will display that the class of `50` is
    `int`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also apply this to `str` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how executing this code will indicate this is of the class `str`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also apply this to `list` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how executing this code will indicate this is of the class `list`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also apply this to a `list` using the name of Python’s built-in `list`
    class as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how executing this code will indicate this is of the class `list`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also apply this to `dict` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how executing this code will indicate this is of the class `dict`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also apply this to a `dict` using the name of Python’s built in `dict`
    class as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how executing this code will indicate this is of the class `dict`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Class Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we want to add functionality to a class itself, not to instances
    of that class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@classmethod` is a function that we can use to add functionality to a class
    as a whole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of *not* using a class method. In your terminal window, type
    `code hat.py` and code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how when we pass the name of the student to the sorting hat, it will
    tell us what house is assigned to the student. Notice that `hat = Hat()` instantiates
    a `hat`. The `sort` functionality is always handled by the *instance* of the class
    `Hat`. By executing `hat.sort("Harry")`, we pass the name of the student to the
    `sort` method of the particular instance of `Hat`, which we’ve called `hat`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We may want, though, to run the `sort` function without creating a particular
    instance of the sorting hat (there’s only one, after all!). We can modify our
    code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the `__init__` method is removed because we don’t need to instantiate
    a hat anywhere in our code. `self`, therefore, is no longer relevant and is removed.
    We specify this `sort` as a `@classmethod`, replacing `self` with `cls`. Finally,
    notice how `Hat` is capitalized by convention near the end of this code, because
    this is the name of our class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Returning back to `students.py` we can modify our code as follows, addressing
    some missed opportunities related to `@classmethod`s:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `get_student` is removed and a `@classmethod` called `get` is created.
    This method can now be called without having to create a student first.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Static Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out that besides `@classmethod`s, which are distinct from instance
    methods, there are other types of methods as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `@staticmethod` may be something you might wish to explore. While not
    covered explicitly in this course, you are welcome to go and learn more about
    static methods and their distinction from class methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance is, perhaps, the most powerful feature of object-oriented programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It just so happens that you can create a class that “inherits” methods, variables,
    and attributes from another class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the terminal, execute `code wizard.py`. Code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that there is a class above called `Wizard` and a class called `Student`.
    Further, notice that there is a class called `Professor`. Both students and professors
    have names. Also, both students and professors are wizards. Therefore, both `Student`
    and `Professor` inherit the characteristics of `Wizard`. Within the “child” class
    `Student`, `Student` can inherit from the “parent” or “super” class `Wizard` as
    the line `super().__init__(name)` runs the `init` method of `Wizard`. Finally,
    notice that the last lines of this code create a wizard called Albus, a student
    called Harry, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inheritance and Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we have just introduced inheritance, we have been using this all along
    during our use of exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It just so happens that exceptions come in a hierarchy, where there are children,
    parent, and grandparent classes. These are illustrated below:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can learn more in Python’s documentation of [exceptions](https://docs.python.org/3/library/exceptions.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some operators such as `+` and `-` can be “overloaded” such that they can have
    more abilities beyond simple arithmetic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your terminal window, type `code vault.py`. Then, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the `__str__` method returns a formatted string. Further, notice
    how the `__add__` method allows for the addition of the values of two vaults.
    `self` is what is on the left of the `+` operand. `other` is what is right of
    the `+`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [operator overloading](https://docs.python.org/3/reference/datamodel.html#special-method-names).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, you’ve learned a whole new level of capability through object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`raise`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator Overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
