- en: 1.4   Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4   数组
- en: 原文：[https://introcs.cs.princeton.edu/java/14array](https://introcs.cs.princeton.edu/java/14array)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/java/14array](https://introcs.cs.princeton.edu/java/14array)
- en: '![An array](../Images/8dc0add35e4461218ac3d9e05edc1769.png) In this section,
    we consider a fundamental construct known as the *array*. An array stores a sequence
    of values that are all of the same type. We want not just to store values but
    also to be able to quickly access each individual value. The method that we use
    to refer to individual values in an array is to number and then *index* them—if
    we have *n* values, we think of them as being numbered from 0 to *n*−1.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个数组](../Images/8dc0add35e4461218ac3d9e05edc1769.png) 在本节中，我们考虑一种称为*数组*的基本构造。数组存储一系列相同类型的值。我们不仅想��储值，还想能够快速访问每个单独的值。我们用来引用数组中单个值的方法是对它们进行编号，然后*索引*它们——如果我们有*n*个值，我们将它们视为从0到*n*−1编号。'
- en: Arrays in Java.
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java中的数组。
- en: 'Making an array in a Java program involves three distinct steps:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java程序中创建数组涉及三个不同的步骤：
- en: Declare the array name.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明数组名称。
- en: Create the array.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数组。
- en: Initialize the array values.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化数组数值。
- en: 'We refer to an array element by putting its index in square brackets after
    the array name: the code `a[i]` refers to element `i` of array `a[]`. For example,
    the following code makes an array of n numbers of type double, all initialized
    to 0:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在数组名称后面的方括号中放置其索引来引用数组元素：代码`a[i]`表示数组`a[]`的第`i`个元素。例如，以下代码创建了一个类型为double的n个数字的数组，所有元素都初始化为0：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Typical array-processing code.
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 典型的数组处理代码。
- en: '[ArrayExamples.java](ArrayExamples.java.html) contains typical examples of
    using arrays in Java.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[ArrayExamples.java](ArrayExamples.java.html) 包含了Java中使用数组的典型示例。'
- en: '![examples of array processing](../Images/15e7a579b26a16f91989722fdbe4b7c3.png)'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![数组处理示例](../Images/15e7a579b26a16f91989722fdbe4b7c3.png)'
- en: Programming with arrays.
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组进行编程。
- en: Before considering more examples, we consider a number of important characteristics
    of programming with arrays.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑更多示例之前，我们先考虑一些与数组编程相关的重要特性。
- en: '*Zero-based indexing.* We always refer to the first element of an array `a[]`
    as `a[0]`, the second as `a[1]`, and so forth. It might seem more natural to you
    to refer to the first element as `a[1]`, the second value as `a[2]`, and so forth,
    but starting the indexing with 0 has some advantages and has emerged as the convention
    used in most modern programming languages.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于零的索引。* 我们总是将数组`a[]`的第一个元素称为`a[0]`，第二个称为`a[1]`，依此类推。你可能认为将第一个元素称为`a[1]`，第二个值称为`a[2]`等更自然，但从0开始索引有一些优势，并已成为大多数现代编程语言使用的约定。'
- en: '*Array length.* Once we create an array, its length is fixed. You can refer
    to the length of an `a[]` in your program with the code `a.length`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组长度。* 一旦我们创建了一个数组，它的长度就是固定的。您可以在程序中使用代码`a.length`引用`a[]`的长度。'
- en: '*Default array initialization.* For economy in code, we often take advantage
    of Java''s default array initialization convention. For example, the following
    statement is equivalent to the four lines of code at the top of this page:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认数组初始化。* 为了节省代码，我们经常利用Java的默认数组初始化约定。例如，以下语句等同于本页顶部的四行代码：'
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default initial value is 0 for all numeric primitive types and `false` for
    type `boolean`.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于所有数值原始类型，默认初始值为0，对于布尔类型`boolean`为`false`。
- en: '*Memory representation.* When you use `new` to create an array, Java reserves
    space in memory for it (and initializes the values). This process is called *memory
    allocation*.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存表示。* 当您使用`new`创建数组时，Java会在内存中为其保留空间（并初始化值）。这个过程称为*内存分配*。'
- en: '*Bounds checking.* When programming with arrays, you must be careful. It is
    your responsibility to use legal indices when accessing an array element.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边界检查。* 在使用数组编程时，您必须小心。在访问数组元素时使用合法的索引是您的责任。'
- en: '*Setting array values at compile time.* When we have a small number of literal
    values that we want to keep in array, we can initialize it by listing the values
    between curly braces, separated by a comma. For example, we might use the following
    code in a program that processes playing cards.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在编译时设置数组值。* 当我们有一小组我们想要保留在数组中的文字值时，我们可以通过在大括号中列出用逗号分隔的值来初始化它。例如，我们可以在处理扑克牌的程序中使用以下代码。'
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After creating the two arrays, we might use them to print a random card name
    such as `Queen of Clubs`, as follows.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建这两个数组后，我们可以使用它们来打印一个随机的卡片名称，比如`梅花皇后`，如下所示。
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Setting array values at run time.* A more typical situation is when we wish
    to compute the values to be stored in an array. For example, we might use the
    following code to initialize an array of length 52 that represents a deck of playing
    cards, using the arrays `RANKS[]` and `SUITS[]` just defined.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在运行时设置数组值。* 更典型的情况是，当我们希望计算要存储在数组中的值时。例如，我们可以使用以下代码初始化一个长度为52的数组，表示一副扑克牌，使用刚刚定义的数组`RANKS[]`和`SUITS[]`。'
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Shuffling and sampling.
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 洗牌和抽样。
- en: Now we describe some useful algorithms for rearranging the elements in an array.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们描述一些有用的算法来重新排列数组中的元素。
- en: '*Exchange.* Frequently, we wish to exchange two values in an array. Continuing
    our example with playing cards, the following code exchanges the card at position
    `i` and the card at position `j`:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交换。* 经常，我们希望在数组中交换两个值。继续我们的扑克牌示例，以下代码交换了位置`i`处的卡片和位置`j`处的卡片：'
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Shuffling.* The following code shuffles our deck of cards:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*洗牌。* 以下代码洗牌我们的牌组：'
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Proceeding from left to right, we pick a random card from `deck[i]` through
    `deck[n-1]` (each card equally likely) and exchange it with `deck[i]`. This code
    is more sophisticated than it might seem: see the textbook for details. [Deck.java](Deck.java.html)
    contains the full code for creating and shuffling a deck of cards.'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从左到右，我们从`deck[i]`到`deck[n-1]`中选择一张随机卡片（每张卡片同等可能）并将其与`deck[i]`交换。这段代码比看起来更复杂：详情请参阅教科书。[Deck.java](Deck.java.html)
    包含了创建和洗牌一副扑克牌的完整代码。
- en: '*Sampling without replacement.* In many situations, we want to draw a random
    sample from a set such that each member of the set appears at most once in the
    sample. [Sample.java](Sample.java.html) takes two command-line arguments `m` and
    `n`, and creates a *permutation* of length `n` whose first `m` entries comprise
    a random sample. See the textbook for details.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无替换抽样*。在许多情况下，我们希望从一个集合中抽取一个随机样本，使得集合中的每个成员在样本中最多出现一次。[Sample.java](Sample.java.html)
    接受两个命令行参数 `m` 和 `n`，并创建一个长度为 `n` 的*排列*，其中前 `m` 个条目组成一个随机样本。详情请参阅教科书。'
- en: Precomputed values.
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预先计算的值。
- en: One simple application of arrays is to save values that you have computed, for
    later use. As an example, suppose that you are writing a program that performs
    calculations using small values of the harmonic numbers. One easy way to accomplish
    such a task is to save the values in an array with the following code
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的一个简单应用是保存你计算过的值，以供以后使用。例如，假设你正在编写一个使用调和数小值进行计算的程序。实现这样一个任务的一种简单方法是将值保存在一个数组中，代码如���
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'and then simply use the code `harmonic[i]` to refer to any of the values. Precomputing
    values in this way in an example of a *space-time tradeoff*: by investing in space
    (to save the values) we save time (since we do not need to recompute them). This
    method is not effective if we need values for huge n, but it is very effective
    if we need a huge number of values for small n.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后简单地使用代码 `harmonic[i]` 来引用任何一个值。以这种方式预先计算值是*时空权衡*的一个例子：通过投资空间（保存值）来节省时间（因为我们不需要重新计算它们）。如果我们需要大量的
    n 值，这种方法并不有效，但如果我们需要大量小 n 值的值，这种方法非常有效。
- en: Simplifying repetitive code.
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化重复的代码。
- en: 'As an example of another simple application of arrays, consider the following
    code fragment, which prints the name of a month given its number (1 for January,
    2 for February, and so forth):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数组的另一个简单应用的示例，考虑以下代码片段，根据月份的数字（1代表一月，2代表二月，依此类推）打印月份的名称。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We could also use a `switch` statement, but a much more compact alternative
    is to use an array of strings consisting of the names of each month:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `switch` 语句，但一个更紧凑的替代方案是使用一个包含每个月份名称的字符串数组：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This technique would be especially useful if you needed to access the name of
    a month by its number in several different places in your program. Note that we
    intentionally waste one slot in the array (element 0) to make `MONTHS[1]` correspond
    to January, as required. ![Coupon collection](../Images/3cc0a4109328288f5cc8c7b7a8134320.png)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在程序的多个不同位置通过其数字访问月份名称，这种技术将特别有用。请注意，我们故意浪费数组中的一个槽（元素 0）以使 `MONTHS[1]` 对应于一月，如所需。![优惠券收集](../Images/3cc0a4109328288f5cc8c7b7a8134320.png)
- en: Coupon collector.
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优惠券收集器。
- en: 'Suppose that you have a shuffled deck of cards and you turn them face up, one
    by one. How many cards do you need to turn up before you have seen one of each
    suit? This is an example of the famous *coupon collector* problem. In general,
    suppose that a trading card company issues trading cards with *n* different possible
    cards: how many do you have to collect before you have all *n* possibilities,
    assuming that each possibility is equally likely for each card that you collect?
    [CouponCollector.java](CouponCollector.java.html) takes an integer command-line
    argument *n* and simulates this process. See the textbook for details.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一副洗过的扑克牌，并且你一个接一个地把它们翻面。在你看到每种花色之前，你需要翻多少张牌？这是著名的*收集优惠券*问题的一个例子。一般来说，假设一个交易卡公司发行具有
    *n* 种不同可能卡片的交易卡：在你收集到所有 *n* 种可能性之前，你需要收集多少张卡片，假设每张卡片的每种可能性对于你收集的每张卡片都是等可能的？[CouponCollector.java](CouponCollector.java.html)
    接受一个整数命令行参数 *n* 并模拟这个过程。详情请参阅教科书。
- en: Sieve of Eratosthenes.
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 埃拉托斯特尼筛法。
- en: The [prime counting function](http://mathworld.wolfram.com/PrimeCountingFunction.html)
    π(*n*) is the number of primes less than or equal to *n*. For example π(17) =
    7 since the first seven primes are 2, 3, 5, 7, 11, 13, and 17. [PrimeSieve.java](PrimeSieve.java.html)
    takes an integer command-line argument *n* and computes π(*n*) using the [Sieve
    of Eratosthenes](http://mathworld.wolfram.com/SieveofEratosthenes.html). See the
    textbook for details. ![A 2d array](../Images/b671e674b19b2d5bd564253c19240e18.png)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[素数计数函数](http://mathworld.wolfram.com/PrimeCountingFunction.html) π(*n*) 是小于或等于
    *n* 的素数数量。例如，π(17) = 7，因为前七个素数是2, 3, 5, 7, 11, 13 和 17。[PrimeSieve.java](PrimeSieve.java.html)
    接受一个整数命令行参数 *n* 并使用[埃拉托斯特尼筛法](http://mathworld.wolfram.com/SieveofEratosthenes.html)计算
    π(*n*)。详情请参阅教科书。![一个二维数组](../Images/b671e674b19b2d5bd564253c19240e18.png)'
- en: Two-dimensional arrays.
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二维数组。
- en: In many applications, a natural way to organize information is to use a table
    of numbers organized in a rectangle and to refer to rows and columns in the table.
    The mathematical abstraction corresponding to such tables is a *matrix*; the corresponding
    Java construct is a two-dimensional array.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用中，组织信息的一种自然方式是使用一个按照矩形组织的数字表，并在表中引用行和列。对应于这种表的数学抽象是*矩阵*；相应的Java构造是二维数组。
- en: '*Two-dimensional arrays in Java.* To refer to the element in row `i` and column
    `j` of a two-dimensional array `a[][]`, we use the notation `a[i][j]`; to declare
    a two-dimensional array, we add another pair of brackets; to create the array,
    we specify the number of rows followed by the number of columns after the type
    name (both within brackets), as follows:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java中的二维数组*。要引用二维数组 `a[][]` 中第 `i` 行和第 `j` 列的元素，我们使用记法 `a[i][j]`；要声明一个二维数组，我们在类型名称后添加另一对方括号；要创建数组，我们在类型名称后指定行数，然后是列数（都在方括号内），如下所示：'
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We refer to such an array as an *m-by-n array*. By convention, the first dimension
    is the number of rows and the second dimension is the number of columns.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将这样的数组称为*m行n列数组*。按照惯例，第一个维度是行数，第二个维度是列数。
- en: '*Default initialization.* As with one-dimensional arrays, Java initializes
    all entries in arrays of numbers to 0 and in arrays of booleans to `false`. Default
    initialization of two-dimensional arrays is useful because it masks more code
    than for one-dimensional arrays. To access each of the elements in a two-dimensional
    array, we need nested loops:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认初始化。* 与一维数组一样，Java将数字数组中的所有条目初始化为0，布尔数组中的所有条目初始化为`false`。二维数组的默认初始化很有用，因为它比一维数组需要更多的代码。要访问二维数组中的每个元素，我们需要嵌套循环：'
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Memory representation.* Java represents a two-dimensional array as an array
    of arrays. A matrix with `m` rows and `n` columns is actually an array of length
    `m`, each entry of which is an array of length `n`. In a two-dimensional Java
    array, we can use the code `a[i]` to refer to the ith row (which is a one-dimensional
    array). Enables ragged arrays.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存表示。* Java将二维数组表示为一个数组的数组。一个具有`m`行和`n`列的矩阵实际上是一个长度为`m`的数组，其中每个条目都是长度为`n`的数组。在Java的二维数组中，我们可以使用代码`a[i]`来引用第i行（这是一个一维数组）。支持不规则数组。'
- en: '*Setting values at compile time.* The following code initializes the 11-by-4
    array `a[][]`:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在编译时设置值。* 以下代码初始化了11行4列的数组`a[][]`：'
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Ragged arrays.* There is no requirement that all rows in a two-dimensional
    array have the same length—an array with rows of nonuniform length is known as
    a *ragged array*. The possibility of ragged arrays creates the need for more care
    in crafting array-processing code. For example, this code prints the contents
    of a ragged array:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不规则数组。* 二维数组中的所有行不需要具有相同的长度要求，一个具有非统一长度行的数组称为*不规则数组*。不规则数组的可能性需要更多的注意来编写数组处理代码。例如，这段代码打印了一个不规则数组的内容：'
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Multidimensional arrays.* The same notation extends to arrays that have any
    number of dimensions. For instance, we can declare and initialize a three-dimensional
    array with the code'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多维数组。* 相同的���示法适用于具有任意维数的数组。例如，我们可以使用以下代码声明和初始化一个三维数组'
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: and then refer to an entry with code like `a[i][j][k]`.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后通过类似`a[i][j][k]`的代码引用一个条目。
- en: '![matrix multiplication](../Images/ed1d2ea391443d5e5a93cdf14f4b6ffb.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](../Images/ed1d2ea391443d5e5a93cdf14f4b6ffb.png)'
- en: Matrix operations.
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵操作。
- en: 'Typical applications in science and engineering involve implementing various
    mathematical operations with matrix operands. For example, we can *add* two *n*-by-*n*
    matrices as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学和工程中的典型应用中，涉及使用矩阵操作数执行各种数学操作。例如，我们可以如下*相加*两个*n*乘*n*的矩阵：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similarly, we can *multiply* two matrices. Each entry `c[i][j]` in the product
    of `a[]` and `b[]` is computed by taking the dot product of row `i` of `a[]` with
    column `j` of `b[]`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以*相乘*两个矩阵。矩阵`a[]`和`b[]`的乘积中的每个条目`c[i][j]`是通过计算`a[]`的第i行与`b[]`的第j列的点积来计算的。
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Self-avoiding walk.
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免自我交叉的行走。
- en: '[SelfAvoidingWalk.java](SelfAvoidingWalk.java.html) is an application of two-dimensional
    arrays to chemistry. See textbook for details.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[SelfAvoidingWalk.java](SelfAvoidingWalk.java.html)是将二维数组应用于化学的一个应用。详情请参阅教科书。'
- en: Exercises
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: 'Describe and explain what happens when you try to compile a program [HugeArray.java](HugeArray.java.html)
    with the following statement:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述并解释当您尝试编译一个程序[HugeArray.java](HugeArray.java.html)时会发生什么，其中包含以下语句：
- en: '[PRE17]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write a code fragment that reverses the order of values in a one-dimensional
    string array. Do not create another array to hold the result. *Hint*: Use the
    code in the text for exchanging two elements.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码片段，将一维字符串数组中的值顺序颠倒。不要创建另一个数组来保存结果。*提示*：使用文本中用于交换两个元素的代码。
- en: '*Solution.*'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。*'
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What is wrong with the following code fragment?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段有什么问题？
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Solution*: It does not allocate memory for `a[]` with `new`. The code results
    in a `variable might not have been initialized` compile-time error.'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：* 它没有使用`new`为`a[]`分配内存。该代码导致`variable might not have been initialized`编译时错误。'
- en: What does the following code fragment print?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段打印什么？
- en: '[PRE20]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Solution:* It prints false. The `==` operator compares whether the (memory
    addresses of the) two arrays are identical, not whether their corresponding values
    are equal.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：* 它打印false。`==`运算符比较（内存地址的）两个数组是否相同，而不是它们对应的值是否相等。'
- en: Write a program [Deal.java](Deal.java.html) that takes an integer command-line
    argument `n` and prints `n` poker hands (five cards each) from a shuffled deck,
    separated by blank lines.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Deal.java](Deal.java.html)，它接受一个整数命令行参数`n`，并从洗牌后的牌组中打印`n`个扑克牌手（每手五张牌），用空行分隔。
- en: Write a program [HowMany.java](HowMany.java.html) that takes a variable number
    of command-line arguments and prints how many there are.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[HowMany.java](HowMany.java.html)，它接受可变数量的命令行参数并打印它们的数量。
- en: Write a program [DiscreteDistribution.java](DiscreteDistribution.java.html)
    that takes a variable number of integer command-line arguments and prints the
    integer `i` with probability proportional to the `i`th command-line argument.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[DiscreteDistribution.java](DiscreteDistribution.java.html)，它接受可变数量的整数命令行参数，并按照第`i`个命令行参数的比例打印整数`i`。
- en: Write a code fragment [Transpose.java](Transpose.java.html) to transpose a square
    two-dimensional array in place without creating a second array.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码片段[Transpose.java](Transpose.java.html)，在不创建第二个数组的情况下对一个方形的二维数组进行转置。
- en: Creative Exercises
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意练习
- en: '**Bad shuffling.** Suppose that you choose a random integer between 0 and n-1
    in our shuffling code instead of one between i and n-1\. Show that the resulting
    order is not equally likely to be one of the n! possibilities. Run the test of
    the previous exercise for this version.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**糟糕的洗牌。** 假设在我们的洗牌代码中，你选择一个在0到n-1之间的随机整数，而不是在i到n-1之间选择一个。证明结果的顺序不可能是n!种可能性之一。对这个版本运行上一个练习的测试。'
- en: '*Partial solution:* when n = 3, all 3! = 6 outcomes are possible, but some
    are more likely:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*部分解决方案：* 当n = 3时，所有3! = 6种结果都是可能的，但有些更有可能：'
- en: '| ABC | ACB | BAC | BCA | CAB | CBA |'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ABC | ACB | BAC | BCA | CAB | CBA |'
- en: '| 4/27 | 5/27 | 6/27 | 4/27 | 5/27 | 3/27 |'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 4/27 | 5/27 | 6/27 | 4/27 | 5/27 | 3/27 |'
- en: Here's what happened to [PlanetPoker](https://www.datamation.com/entdev/article.php/616221/How-We-Learned-to-Cheat-at-Online-Poker-A-Study-in-Software-Security.htm)
    when they used a broken shuffling algorithm that could only generate only about
    200,000 of the possible 52! shuffles.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当[PlanetPoker](https://www.datamation.com/entdev/article.php/616221/How-We-Learned-to-Cheat-at-Online-Poker-A-Study-in-Software-Security.htm)使用一个只能生成可能的52!中约200,000个洗牌的破损洗牌算法时发生了什么。
- en: '**Inverse permutation.** Write a program [InversePermutation.java](InversePermutation.java.html)
    that reads in a permutation of the integers `0` to `n-1` from `n` command-line
    arguments and prints the *inverse permutation*. (If the permutation is in an array
    `a[]`, its *inverse* is the array `b[]` such that `a[b[i]] = b[a[i]] = i`.) Be
    sure to check that the input is a valid permutation.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逆排列。** 编写一个程序[InversePermutation.java](InversePermutation.java.html)，从`n`个命令行参数中读取0到`n-1`的整数的一个排列，并打印*逆排列*。（如果排列在一个数组`a[]`中，其*逆排列*是数组`b[]`，使得`a[b[i]]
    = b[a[i]] = i`。）确保检查输入是否是有效的排列。'
- en: '**Hadamard matrix.** The n-by-n Hadamard H(n) matrix is a boolean matrix with
    the remarkable property that any two rows differ in exactly n/2 bits. (This property
    makes it useful for designing *error-correcting codes*.) H(1) is a 1-by-1 matrix
    with the single entry true, and for n > 1, H(2n) is obtained by aligning four
    copies of H(n) in a large square, and then inverting all of the entries in the
    lower right n-by-n copy, as shown in the following examples (with T representing
    true and F representing false, as usual).'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哈达玛矩阵。** n阶哈达玛矩阵H(n)是一个布尔矩阵，具有这样一个显著的特性，即任意两行在恰好n/2位上不同。（这个特性使其在设计*纠错码*时非常有用。）H(1)是一个1阶矩阵，其中唯一的元素为true，对于n
    > 1，H(2n)通过将四个H(n)的副本对齐在一个大正方形中获得，然后反转右下角的n阶副本中的所有元素，如下例所示（T代表true，F代表false，如常）。'
- en: '[PRE21]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Write a program [Hadamard.java](Hadamard.java.html) that takes one command-line
    argument n and prints H(n). Assume that n is a power of 2\.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[Hadamard.java](Hadamard.java.html)，接受一个命令行参数n并打印H(n)。假设n是2的幂。
- en: '**Random walkers.** Suppose that n random walkers, starting in the center of
    an n-by-n grid, move one step at a time, choosing to go left, right, up, or down
    with equal probability at each step. Write a program [RandomWalkers.java](RandomWalkers.java.html)
    to help formulate and test a hypothesis about the number of steps taken before
    all cells are touched.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机漫步者。** 假设有n个随机漫步者，从一个n乘n的网格的中心开始，每次移动一步，选择向左、向右、向上或向下的概率相等。编写一个程序[RandomWalkers.java](RandomWalkers.java.html)来帮助制定和测试有关在所有单元格被触及之前所需步数的假设。'
- en: '**Birthday problem.** Suppose that people enter an empty room until a pair
    of people share a birthday. On average, how many people will have to enter before
    there is a match? Write a program [Birthday.java](Birthday.java.html) to simulate
    one experiment. Write a program [Birthdays.java](Birthdays.java.html) to repeat
    the experiment many times and estimate the average value. Assume birthdays to
    be uniform random integers between 0 and 364\.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生日问题。** 假设人们进入一个空房间，直到有一对人共享生日。平均来说，有多少人会进入才会有匹配？编写一个程序[Birthday.java](Birthday.java.html)来模拟一个实验。编写一个程序[Birthdays.java](Birthdays.java.html)来重复实验多次并估计平均值。假设生日是在0到364之间均匀随机的整数。'
- en: '**Binomial coefficients.** Write a program [BinomialDistribution.java](BinomialDistribution.java.html)
    that builds and prints a two-dimensional ragged array a such that `a[n][k]` contains
    the probability that you get exactly k heads when you toss a coin n times. Take
    a command-line argument to specify the maximum value of n. These numbers are known
    as the *binomial distribution*: if you multiply each entry in row i by 2^n, you
    get the *binomial coefficients*—the coefficients of x^k in (x+1)^n—arranged in
    *Pascal''s triangle*. To compute them, start with `a[n][0] = 0.0` for all n and
    `a[1][1] = 1.0`, then compute values in successive rows, left to right, with `a[n][k]
    = (a[n-1][k] + a[n-1][k-1]) / 2`.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二项式系数。** 编写一个程序[BinomialDistribution.java](BinomialDistribution.java.html)，构建并打印一个二维不规则数组a，使得`a[n][k]`包含抛掷n次硬币时获得恰好k个正面的概率。接受一个命令行参数以指定n的最大值。这些数字被称为*二项分布*：如果将第i行中的每个条目乘以2^n，就得到*二项式系数*—(x+1)^n中x^k的系数—排列在*帕斯卡三角形*中。要计算它们，从`a[n][0]
    = 0.0`开始对所有n，`a[1][1] = 1.0`，然后按行从左到右计算值，`a[n][k] = (a[n-1][k] + a[n-1][k-1])
    / 2`。'
- en: '[PRE22]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Web Exercises
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习
- en: '**Birthday problem.** Modify [Birthday.java](Birthday.java.html) so that it
    compute the probability that two people have a birthday within a day of each other.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生日问题。** 修改[Birthday.java](Birthday.java.html)以计算两个人生日相差不超过一天的概率。'
- en: '**Above average.** 90% of incoming college students rate themselves as above
    average. Write a program `AboveAverage.java` that takes a command-line argument
    n, reads in n integers from standard input, and prints the fraction of values
    that are strictly above the average value.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高于平均水平。** 90%的大学新生认为自己高于平均水平。编写一个程序`AboveAverage.java`，它接受一个命令行参数n，从标准输入读取n个整数，并打印严格高于平均值的值的比例。'
- en: '**Random permutation.** Write a program [Permutation.java](Permutation.java.html)
    so that it takes a command-line argument N and prints a random permutation of
    the integers 0 through N-1. Also print a *checkerboard visualization* of the permutation.
    As an example, the permutation { 4, 1, 3, 0, 2 } corresponds to:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机排列。** 编写一个程序[Permutation.java](Permutation.java.html)，使其接受一个命令行参数N，并打印整数0到N-1的一个随机排列。同时打印排列的*棋盘可视化*。例如，排列{
    4, 1, 3, 0, 2 }对应于：'
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**8 queens checker.** A permutation of the integer 0 to n-1 corresponds to
    a placement of queens on an n-by-n chessboard so that no two queens are in the
    same row or column. Write a program `QueensChecker.java` that determines whether
    or not a permutation corresponds to a placement of queens so that no two are in
    the same row, column, or *diagonal*. As an example, the permutation { 4, 1, 3,
    0, 2 } is a legal placement:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**8皇后检查器。** 整数0到n-1的排列对应于在n×n的棋盘上放置皇后，以便没有两个皇后在同一行或列中。编写一个程序`QueensChecker.java`，确定排列是否对应于放置皇后的位置，以便没有两个皇后在同一行、列或*对角线*上。例如，排列{
    4, 1, 3, 0, 2 }是一个合法的放置：'
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Try to do it without using any extra arrays besides the length n input permutation
    `q`. *Hint*: to determine whether setting q[i] conflicts with q[j] for i < j.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试在除了长度为n的输入排列`q`之外不使用任何额外数组。*提示*：确定设置q[i]是否与q[j]冲突，其中i < j。
- en: 'if q[i] equals q[j]: two queens are placed in the same row'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果q[i]等于q[j]：两个皇后放在同一行上
- en: 'if q[i] - q[j] equals j - i: two queens are on same major diagonal'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果q[i] - q[j]等于j - i：两个皇后在同一主对角线上
- en: 'if q[j] - q[i] equals j - i: two queens are on same minor diagonal'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果q[j] - q[i]等于j - i：两个皇后在同一副对角线上
- en: '**Finding your beer.** A large number of college students are attending a party.
    Each guest is drinking a can of beer (or soda of they are under 21). An emergency
    causes the lights to go out and the fire alarm to go off. The guests calmly put
    down their beer and exit the building. When the alarm goes off, they re-enter
    and try to retrieve their beer. However, the lights are still off, so each student
    randomly grabs a bottle of beer. What are the chances that at least one student
    gets his or her original beer? Write a program `MyBeer.java` that takes a command-line
    argument n and runs 1,000 simulations this event, assuming their are n guests.
    Print the fraction of times that at least one guest gets their original beer.
    As n gets large, does this fraction approach 0 or 1 or something in between?'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**找到你的啤酒。** 大量的大学生正在参加一个派对。每位客人都在喝一罐啤酒（如果他们未满21岁，则为苏打）。一次紧急情况导致灯灭和火警响起。客人们平静地放下他们的啤酒并离开建筑物。当警报响起时，他们重新进入并尝试找回他们的啤酒。然而，灯还是关着，所以每个学生随机拿起一瓶啤酒。至少有一个学生拿到自己原来的啤酒的机会有多大？编写一个程序`MyBeer.java`，接受一个命令行参数n，并运行1000次模拟这个事件，假设有n位客人。打印至少有一位客人拿到自己原来啤酒的次数比例。当n变大时，这个比例是接近0还是1还是介于两者之间？'
- en: '**Linear feedback shift register.** Rewrite [linear feedback shift register](../10overview/LFSR.java.html)
    from Chapter 1 by using an array to streamline it and makes it more extensible,
    e.g., if the number of cells in the shift register increases. Program [LFSR.java](LFSR.java.html)
    uses a `boolean` *Hint*: use the `^` operator to take the exclusive or of two
    boolean values.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**线性反馈移位寄存器。** 通过使用数组重写[线性反馈移位寄存器](../10overview/LFSR.java.html)第1章，使其更加简洁和可扩展，例如，如果移位寄存器中的单元数增加。程序[LFSR.java](LFSR.java.html)使用一个`boolean`
    *提示*：使用`^`运算符对两个布尔值进行异或操作。'
- en: '**Lockers.** Your are in a locker room with 100 open lockers, numbered 1 to
    100. Toggle all of the lockers that are even. By *toggle*, we mean close if it
    is open, and open if it is closed. Now toggle all of the lockers that are multiples
    of three. Repeat with multiples of 4, 5, up to 100. How many lockers are open?
    *Answer*: lockers 1, 4, 9, 16, 25, ..., 100 will be open. Guess you don''t need
    an array once you see the pattern.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**储物柜。** 你在一个有100个开放储物柜的更衣室里，编号从1到100。切换所有偶数的储物柜。通过*切换*，我们的意思是如果是开着的就关闭，如果是关闭的就打开。现在切换所有3的倍数的储物柜。重复4、5、直到100的倍数。有多少个储物柜是开着的？*答案*：储物柜1、4、9、16、25、...、100将是开着的。一旦看到模式，你可能不需要数组。'
- en: '**Scheduling with deadline.** Suppose that you have N tasks to schedule. Each
    task takes 1 unit of time and has a deadline by which time it is expected to finish.
    If a task is not completed by its deadline, you pay a $1,000 fine. Find a schedule
    that minimizes the penalty. *Hint*: schedule the tasks in order of their deadline,
    but don''t bother with any task that won''t finish by its deadline.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**带截止日期的调度。** 假设您有N个任务要安排。每个任务需要1个单位的时间，并且有一个截止日期，到达截止日期时应该完成任务。如果任务未在截止日期前完成，您将支付1000美元的罚款。找到一个最小化罚款的调度方案。*提示*：按照截止日期的顺序安排任务，但不要为无法在截止日期前完成的任务费心。'
- en: '**Calendar.** Repeat Exercise 1.33 to produce a calendar for a given month
    and year. Use arrays to store the names of the days of the week, the names of
    the months, and the number of days in a month.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日历。** 重复练习1.33，为给定的月份和年份制作一个日历。使用数组存储一周中的天的名称，月份的名称以及一个月中的天数。'
- en: '**Connect Four.** Given an N-by-N grid with each cell either occupied by an
    ''X'', an ''O'', or empty, write a program to find the longest sequence of consecutive
    ''X''s either horizontal, vertically, or diagonally. To test your program, you
    can create a random grid where each cell contains an ''X'' or ''O'' with probability
    1/3.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**四子连珠。** 给定一个N×N的网格，每个单元格都被''X''、''O''或空占据，编写一个程序来找到水平、垂直或对角线上连续''X''的最长序列。为了测试您的程序，您可以创建一个随机网格，其中每个单元格包含''X''或''O''的概率为1/3。'
- en: '**Thai kickboxing**. Write a program [KickBoxer.java](KickBoxer.java.html)
    that takes an integer weight w as a command line input and prints the corresponding
    kickboxing weight-class according to the table below.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**泰拳。** 编写一个程序[KickBoxer.java](KickBoxer.java.html)，接受一个整数体重w作为命令行输入，并根据下表打印相应的泰拳体重级别。'
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Use an integer array to store the weight limits and a string array to store
    the weight categories (ranging from Flyweight to Super Heavyweight).
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用一个整数数组来存储重量限制，一个字符串数组来存储重量类别（从Flyweight到Super Heavyweight）。
- en: '**N-ary counter**. Write a program that counts in base N from 0 to N^(20) -
    1\. Use an array of 20 elements.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**N进制计数器。** 编写一个程序，从0计数到N^(20) - 1的N进制数。使用一个包含20个元素的数组。'
- en: '**Terrain analysis.** Given an N-by-N grid of elevation values (in meters),
    a *peak* is a grid point for which all four neighboring cells are strictly lower.
    Write a code fragment that counts the number of peaks in a given N-by-N grid.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**地形分析。** 给定一个N×N的海拔值网格（以米为单位），*峰值*是一个所有四个相邻单元格都严格较低的网格点。编写一个代码片段，计算给定N×N网格中的峰值数量。'
- en: '**Magic squares.** Write a program [MagicSquare.java](MagicSquare.java.html)
    that reads in an odd integer N from the command line and prints out an N-by-N
    magic square. The square contains each of the integers between 1 and N^2 exactly
    once, such that all row sums, column sums, and diagonal sums are equal.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**幻方。** 编写��个名为[MagicSquare.java](MagicSquare.java.html)的程序，从命令行读取一个奇数整数N，并打印出一个N×N的幻方。该方格包含1到N^2之间的每个整数，使得所有行总和、列总和和对角线总和相等。'
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One simple algorithm is to assign the integers 1 to N^2 in ascending order,
    starting at the bottom, middle cell. Repeatedly assign the next integer to the
    cell adjacent diagonally to the right and down. If this cell has already been
    assigned another integer, instead use the cell adjacently above. Use wrap-around
    to handle border cases.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个简单的算法是按升序分配整数1到N^2，从底部中间单元格开始。重复将下一个整数分配给右下角对角线相邻的单元格。如果此单元格已分配了另一个整数，则改为使用上方相邻的单元格。使用环绕处理边界情况。
- en: '**Banner.** Write a program `Banner.java` that takes a string as a command
    line argument and prints the string in large letters as below.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**横幅。** 编写一个名为`Banner.java`的程序，接受一个字符串作为命令行参数，并按照以下方式打印出大字母的字符串。'
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Mimics the Unix utility `banner`.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模仿Unix实用程序`banner`。
- en: '**Voting and social choice theory.** Plurality (US presidential election),
    run-off elections, sequential run-off elections (Australia, Ireland, Princeton
    faculty committees), Condorcet. Kemeny rank aggregation. Arrow''s impossibility
    theorem. Same ideas for sports, google, meta-search, machine learning'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选举和社会选择理论。** 多数制（美国总统选举）、决胜选举、顺序决胜选举（澳大利亚、爱尔兰、普林斯顿大学教师委员会）、康多塞。肯尼米排名聚合。阿罗不可能定理。体育、谷歌、元搜索、机器学习等领域的相同思想。'
- en: '**Borda count.** In 1781, Borda proposed a positional method for determining
    the outcome of a political election with K voters and N candidates. Each voter
    ranks the candidates in increasing order of preference (from 1 to N). Borda''s
    method assigns a score to each candidate equal to the sum of their rankings. The
    candidate with the highest sum wins. This is used in Major League Baseball to
    determine the MVP.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波达计数。** 1781年，波达提出了一种用于确定具有K选民和N候选人的政治选举结果的位置方法。每个选民按照偏好的递增顺序（从1到N）对候选人进行排名。波达的方法为每个候选人分配一个分数，等于他们的排名之和。得分最高的候选人获胜。这在美国职业棒球大联盟中用于确定最有价值球员。'
- en: '**Kendall''s tau distance.** Given two permutations, Kendall''s tau distance
    is the number of pairs out of position. "Bubblesort metric." Useful in top-k lists.
    Optimal Kemeny rank aggregation in voting theory minimizes Kendall tau distance.
    Also useful for ranking genes using several expression profiles, ranking search
    engine results, etc.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**肯德尔的tau距离。** 给定两个排列，肯德尔的tau距离是位置不同的对数。"冒泡排序度量"。在前k个列表中很有用。在选举理论中，最优的肯尼米排名聚合可以最小化肯德尔的tau距离。也可用于使用多个表达谱来排名基因、排名搜索引擎结果等。'
- en: '**Spearman''s footrule distance.** Given two permutations, Spearman''s footrule
    distance is the L1 distance between the permutations as vectors. Useful in top-k
    lists.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**斯皮尔曼的脚距离。** 给定两个排列，斯皮尔曼的脚距离是排列作为向量之间的L1距离。在前k个列表中很有用。'
- en: '[PRE28]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**US postal barcodes.** The [POSTNET](http://en.wikipedia.org/wiki/POSTNET)
    barcode is used by the US Postal System to route mail. Each decimal digit in the
    zip code is encoded using a sequence of 5 short and long lines for use by scanners
    as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**美国邮政条形码。** [POSTNET](http://en.wikipedia.org/wiki/POSTNET)条形码被美国邮政系统用于邮件路由。邮政编码中的每个十进制数字都使用一系列5个短线和长线进行编码，以供扫描仪使用，如下所示：'
- en: '| VALUE | ENCODING |'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| VALUE | ENCODING |'
- en: '| 0 | `&#124;&#124;╷╷╷` |'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0 | `&#124;&#124;╷╷╷` |'
- en: '| 1 | `╷╷╷&#124;&#124;` |'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 | `╷╷╷&#124;&#124;` |'
- en: '| 2 | `╷╷&#124;╷&#124;` |'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 2 | `╷╷&#124;╷&#124;` |'
- en: '| 3 | `╷╷&#124;&#124;╷` |'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 3 | `╷╷&#124;&#124;╷` |'
- en: '| 4 | `╷&#124;╷╷&#124;` |'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 4 | `╷&#124;╷╷&#124;` |'
- en: '| 5 | `╷&#124;╷&#124;╷` |'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 5 | `╷&#124;╷&#124;╷` |'
- en: '| 6 | `╷&#124;&#124;╷╷` |'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 6 | `╷&#124;&#124;╷╷` |'
- en: '| 7 | `&#124;╷╷╷&#124;` |'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 7 | `&#124;╷╷╷&#124;` |'
- en: '| 8 | `&#124;╷╷&#124;╷` |'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 8 | `&#124;╷╷&#124;╷` |'
- en: '| 9 | `&#124;╷&#124;╷╷` |'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| 9 | `&#124;╷&#124;╷╷` |'
- en: 'A sixth checksum digit is appended: it is computed by summing up the original
    five digits mod 10. In addition, a long line is added to the beginning and appended
    to the end. Write a program [ZipBarCoder.java](ZipBarCoder.java.html) that reads
    in a five digit zip code as the command line parameter and prints the corresponding
    [postal barcode](http://www.ams.org/new-in-math/cover/barcodes3.html). Print the
    code vertically instead of horizontally, e.g, the following encodes 08540 (with
    the check digit of 7).'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加第六个校验和数字：通过对原始五位数字进行模10求和来计算。此外，将一条长线添加到开头并附加到末尾。编写一个名为[ZipBarCoder.java](ZipBarCoder.java.html)的程序，从命令行参数读取一个五位数邮政编码，并打印相应的[邮政条形码](http://www.ams.org/new-in-math/cover/barcodes3.html)。垂直打印代码，而不是水平打印，例如，以下编码08540（校验位为7）。
- en: '[PRE29]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**US postal barcodes.** Repeat the previous exercise, but plot the output using
    Turtle graphics.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**美国邮政条形码。** 重复上一个练习，但使用海龟图形绘制输出。'
- en: '**Gaps with no primes.** Find the longest consecutive sequence of integers
    with no primes. Write a program [PrimeGap.java](PrimeGap.java.html) that takes
    a command line parameter N and prints the largest block of integers between 2
    and N with no primes.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**没有质数的间隙。** 找到最长的连续整数序列，其中没有质数。编写一个名为[PrimeGap.java](PrimeGap.java.html)的程序，接受一个命令行参数N，并打印出2到N之间没有质数的最大整数块。'
- en: '**Goldbach conjecture.** In 1742, Christian Goldbach conjectured that every
    even number greater than 2 could be written as the sum of two primes. For example,
    16 = 3 + 13. Write a program [Goldbach.java](Goldbach.java.html) that takes one
    command line parameter N and expresses N as the sum of two primes. [Goldbach''s
    conjecture](http://mathworld.wolfram.com/GoldbachConjecture.html) is still unresolved,
    but it is known to be true for all N < 10^(14).'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哥德巴赫猜想。** 1742年，克里斯蒂安·哥德巴赫猜想，每个大于2的偶数都可以写成两个质数的和。例如，16 = 3 + 13。编写一个程序[Goldbach.java](Goldbach.java.html)，接受一个命令行参数N，并将N表示为两个质数的和。[哥德巴赫猜想](http://mathworld.wolfram.com/GoldbachConjecture.html)仍未解决，但已知对于所有N
    < 10^(14)都成立。'
- en: '**Minima in permutations.** Write a program that takes an integer n from the
    command line, generates a random permutation, prints the permutation, and prints
    the number of left-to-right minima in the permutation (the number of times an
    element is the smallest seen so far). Then write a program that takes integers
    m and n from the command line, generates m random permutations of length n, and
    prints the average number of left-to-right minima in the permutations generated.
    *Extra credit*: Formulate a hypothesis about the number of left-to-right minima
    in a permutation of length n, as a function of n.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排列中的最小值。** 编写一个程序，从命令行接受一个整数n，生成一个随机排列，打印排列，然后打印排列中从左到右的最小值的次数（元素是迄今为止看到的最小值的次数）。然后编写一个程序，从命令行接受整数m和n，生成长度为n的m个随机排列，并打印生成的排列中从左到右的最小值的平均次数。*额外学分*：提出一个关于长度为n的排列中从左到右的最小值次数的假设函数。'
- en: '**In-place inverse permutation.** Redo Exercise 1.4.25, but compute the permutation
    in-place, i.e., do not allocate a second array for the inverse permutation. *Caveat*:
    this is hard.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原地逆置排列。** 重新做练习1.4.25，但在原地计算排列，即不为逆置排列分配第二个数组。*注意*：这很困难。'
- en: '**Most likely roll.** Alice and Bob are in a heated argument about whether
    if they repeatedly roll a die until the sum is more than 12, is 13 the most likely
    sum? Write a program [MostLikelyRoll.java](MostLikelyRoll.java.html) to simulate
    the process a million times and produce a table of the fraction of times the sum
    is 13, 14, 15, 16, 17, and 18.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最有可能的点数。** 爱丽丝和鲍勃就是否重复掷骰子直到总和超过12而争论不休，13是否是最有可能的总和？编写一个程序[MostLikelyRoll.java](MostLikelyRoll.java.html)来模拟这个过程一百万次，并生成一个表格，显示总和为13、14、15、16、17和18的次数比例。'
- en: '**Spiraling 2-D array.** Given a 2-D array, write a program [Spiral.java](Spiral.java.html)
    to print it out in spiral order.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**螺旋2D数组。** 给定一个2D数组，编写一个程序[Spiral.java](Spiral.java.html)以螺旋顺序打印出来。'
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Sudoko verifier.** Given a 9-by-9 array of integers between 1 and 9, check
    if it is a valid solution to a Sudoku puzzle: each row, column, and block should
    contain the 9 integers exactly once.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数独验证器。** 给定一个9x9的整数数组，检查它是否是数独谜题的有效解：每行、每列和每个块应该包含9个整数，且仅出现一次。'
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Sum of powers conjecture.** Redo Exercise 1.3.x, but precompute the 5th powers
    of all relevant integers. Evaluate how much time this saves. The program [Euler.java](Euler.java.html)
    searches for integral solutions to a⁵ + b⁵ + c⁵ + d⁵= e⁵.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**幂和猜想。** 重新做练习1.3.x，但预先计算所有相关整数的5次幂。评估这样做节省了多少时间。程序[Euler.java](Euler.java.html)搜索整数解a⁵
    + b⁵ + c⁵ + d⁵= e⁵。'
- en: '**Haar wavelet transform.** Given, an array `a[]` of length 2^n, its [1D Haar
    transform](http://online.redwoods.cc.ca.us/instruct/darnold/LAPROJ/Fall2002/ames/paper.pdf)
    is obtained as follows: Compute the average and difference of a[2i] and a[2i+1],
    and compute the array of the same length containing the averages, followed by
    the differences. Then apply the same technique to the averages (the first 2^n-1
    entries) and so on. An example with 2^3 entries is shown below.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哈尔小波变换。** 给定长度为2^n的数组`a[]`，其[1D哈尔变换](http://online.redwoods.cc.ca.us/instruct/darnold/LAPROJ/Fall2002/ames/paper.pdf)如下获得：计算a[2i]和a[2i+1]的平均值和差值，计算相同长度的数组，包含平均值，然后是差值。然后对平均值（前2^n-1个条目）应用相同的技术，依此类推。下面展示了一个有2^3个条目的示例。'
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The *2D Haar wavelet transform* of a 2^n-by-2^n matrix, is obtained by applying
    the Haar wavelet transform to each row, and then to each column. The Haar wavelet
    transform is useful in signal processing, medical imaging, and data compression.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2^n乘以2^n矩阵的*2D哈尔小波变换*，通过对每一行应用哈尔小波变换，然后对每一列应用哈尔小波变换获得。哈尔小波变换在信号处理、医学成像和数据压缩中很有用。
- en: What happens when you try to compile a program with the following statement?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您尝试编译具有以下语句的程序时会发生什么？
- en: '[PRE33]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It compiles cleanly, but throws a `java.lang.NegativeArraySizeException` when
    you execute it.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它可以干净地编译，但在执行时抛出`java.lang.NegativeArraySizeException`。
- en: '**Blackjack.** Write a program [Blackjack.java](Blackjack.java.html) that takes
    three command line integers x, y, and z representing your two blackjack cards
    x and y, and the dealer''s face-up card z, and prints the "standard strategy"
    for a 6 card deck in Atlantic city. Assume that x, y, and z are integers between
    1 and 10, representing an ace through a face card. Report whether the player should
    hit, stand, or split according to these [strategy tables](http://www.blackjackinfo.com/cgi-bin/bjbse.cgi?game=ac6).
    Encode the strategy tables using three 2-D boolean arrays.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二十一点。** 编写一个程序[Blackjack.java](Blackjack.java.html)，接受三个命令行整数x、y和z，表示您的两张二十一点牌x和y，以及庄家的明牌z，并根据大西洋城6副牌的“标准策略”打印出来。假设x、y和z是1到10之间的整数，表示从A到面牌。根据这些[策略表](http://www.blackjackinfo.com/cgi-bin/bjbse.cgi?game=ac6)报告玩家应该要牌、停牌还是分牌。使用三个2D布尔数组编码策略表。'
- en: Modify `Blackjack.java` to allow *doubling*.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改`Blackjack.java`以允许*加倍*。
- en: '**Boltzmann distribution.** Here''s a simple model to approximate the Boltzmann
    distribution from statistical physics: generate 100 random integers between 1
    and 10. If the sum is exactly 200 keep this trial. Repeat this process until you
    get 1,000 trials that meet the criterion. Now plot a histogram of the number of
    times each of the 10 integers occurs.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**玻尔兹曼分布。**这里有一个简单的模型来近似统计物理中的玻尔兹曼分布：生成1到10之间的100个随机整数。如果总和恰好为200，则保留此试验。重复此过程，直到满足条件的试验达到1,000次。现在绘制每个10个整数出现次数的直方图。'
- en: '**Doubly stochastic.** Write a program to read in an N-by-N matrix of real
    numbers and print `true` if the matrix is *doubly stochastic*, and `false` otherwise.
    A matrix is *stochastic* if all of the row and column sums are 1\. Since you are
    dealing with floating point numbers, allow the sums to be between 1 - ε and 1
    + ε where ε= 0.000000001.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双随机。**编写一个程序来读取一个N×N的实数矩阵，并在矩阵是*双随机*时打印`true`，否则打印`false`。如果所有行和列的和都为1，则矩阵是*随机*的。由于涉及浮点数，允许和在1-ε和1+ε之间，其中ε=
    0.000000001。'
- en: Suppose that `b[]` is an array of 100 elements, with all entries initialized
    to 0, and that `a[]` is an array of N elements, each of which is an integer between
    0 and 99\. What is the effect of the following loop?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`b[]`是一个包含100个元素的数组，所有条目都初始化为0，并且`a[]`是一个包含N个元素的数组，每个元素都是介于0和99之间的整数。以下循环的效果是什么？
- en: '|'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: 'Modify [RandomStudent.java](RandomStudent.java.html) so that it stores a parallel
    array of type boolean named `isFemale`, where element i is `true` if student i
    is female and `false` otherwise. Now, print one male student at random and one
    female student at random. *Hint*: use a `do-while` loop to generate random integers
    until you get one that indexes a male student.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[RandomStudent.java](RandomStudent.java.html)以便它存储一个名为`isFemale`的布尔类型的并行数组，其中元素i如果学生i是女性则为`true`，否则为`false`。现在，随机打印一个男学生和一个女学生。*提示*：使用`do-while`循环生成随机整数，直到得到一个索引男学生的整数。
- en: Which of the following require using arrays. For each, the input comes from
    standard input and consists of N real numbers between 0.0 and 1.0.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些需要使用数组。对于每个输入来自标准输入，包含N个介于0.0和1.0之间的实数。
- en: Print the maximum element.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印最大的元素。
- en: Print the maximum and minimum elements.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印最大和最小的元素。
- en: Print the median element.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印中位数元素。
- en: Print the element that occurs most frequently.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出现频率最高的元素。
- en: Print the sum of the squares of the elements.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印元素的平方和。
- en: Print the average of the N elements.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印N个元素的平均值。
- en: Print the element closest to 0.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印最接近0的元素。
- en: Print all the numbers greater than the average.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印所有大于平均值的数字。
- en: Print the N elements in increasing order.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以递增顺序打印N个元素。
- en: Print the N elements in random order.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以随机顺序打印N个元素。
- en: Print histogram (with, say 10 bins of size 0.1).
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印直方图（例如，大小为0.1的10个箱）。
- en: Write a program Yahtzee.java that simulates the rolling of five dice and prints
    "Yahtzee" if all five dice are the same; otherwise it should print "Try again."
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序Yahtzee.java来模拟掷五个骰子并打印“Yahtzee”，如果所有五个骰子都相同；否则应打印“再试一次”。
- en: Modify [DayOfWeek.java](../12types/DayOfWeek.java.html) so that it reads in
    a date and print which day of the week that date falls on. Your program should
    take three command line arguments, M (month), D (day), and Y (year). Do not use
    any `if-else` statements; instead use a string array consisting of the names of
    the 7 days of the week.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[DayOfWeek.java](../12types/DayOfWeek.java.html)以便它读取一个日期并打印该日期是星期几。您的程序应该接受三个命令行参数，M（月份），D（日期）和Y（年份）。不要使用任何`if-else`语句；而是使用一个包含一周7天名称的字符串数组。
- en: Write a program [Pascal.java](Pascal.java.html) to compute Pascal's triangle
    using a ragged array.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[Pascal.java](Pascal.java.html)来使用一个不规则数组计算帕斯卡三角形。
- en: '**Zero out matrix rows and columns.** Given an *m*-by-*n* integer matrix `a[][]`,
    if `a[i][j]` is 0, set row `i` and column `j` to 0. Do not use any extra arrays.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将矩阵行和列清零。**给定一个*m*×*n*整数矩阵`a[][]`，如果`a[i][j]`为0，则将第i行和第j列设置为0。不要使用任何额外的数组。'
- en: '*Solution*. First, check whether row 0 has a 0 and whether column 0 has a 0;
    record this information in two boolean variables. Next, for each element `a[i][j]`
    that is 0, set element `a[i][0]` and `a[0][j]` to 0\. Finally, set `a[i][j]` to
    0 if either `a[i][0]` or `a[0][j]`.'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*。首先，检查第0行是否有0，以及第0列是否有0；将此信息记录在两个布尔变量中。接下来，对于每个为0的元素`a[i][j]`，将元素`a[i][0]`和`a[0][j]`设置为0。最后，如果`a[i][0]`或`a[0][j]`中有一个为0，则将`a[i][j]`设置为0。'
