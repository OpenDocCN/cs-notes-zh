- en: 4.1   Undirected Graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1   无向图
- en: 原文：[https://algs4.cs.princeton.edu/41graph](https://algs4.cs.princeton.edu/41graph)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://algs4.cs.princeton.edu/41graph](https://algs4.cs.princeton.edu/41graph)
- en: Graphs.
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图。
- en: A *graph* is a set of *vertices* and a collection of *edges* that each connect
    a pair of vertices. We use the names 0 through V-1 for the vertices in a V-vertex
    graph.![Graph](../Images/258e1245c0f0d47382c14553af418f18.png)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*图*是一组*顶点*和连接一对顶点的*边*的集合。我们在V-1个顶点的图中使用0到V-1的名称表示顶点。![图](../Images/258e1245c0f0d47382c14553af418f18.png)'
- en: Glossary.
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语表。
- en: Here are some definitions that we use.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们使用的一些定义。
- en: A *self-loop* is an edge that connects a vertex to itself.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自环*是连接顶点与自身的边。'
- en: Two edges are *parallel* if they connect the same pair of vertices.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们连接相同的一对顶点，则两条边是*平行*的。
- en: When an edge connects two vertices, we say that the vertices are *adjacent to*
    one another and that the edge is *incident on* both vertices.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一条边连接两个顶点时，我们说这两个顶点*相邻*，并且该边*关联*这两个顶点。
- en: The *degree* of a vertex is the number of edges incident on it.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个顶点的*度*是与其关联的边的数量。
- en: A *subgraph* is a subset of a graph's edges (and associated vertices) that constitutes
    a graph.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*子图*是构成图的边（和相关顶点）的子集，构成一个图。'
- en: A *path* in a graph is a sequence of vertices connected by edges, with no repeated
    edges.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图中的*路径*是由边连接的顶点序列，没有重复的边。
- en: A *simple path* is a path with no repeated vertices.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*简单路径*是一个没有重复顶点的路径。
- en: A *cycle* is a path (with at least one edge) whose first and last vertices are
    the same.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*循环*是一条路径（至少有一条边），其第一个和最后一个顶点相同。'
- en: A *simple cycle* is a cycle with no repeated vertices (other than the requisite
    repetition of the first and last vertices).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单循环*是一个没有重复顶点（除了第一个和最后一个顶点必须重复）的循环。'
- en: The *length* of a path or a cycle is its number of edges.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条路径或循环的*长度*是其边的数量。
- en: We say that one vertex is *connected to* another if there exists a path that
    contains both of them.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在包含它们两者的路径，则我们说一个顶点*连接到*另一个顶点。
- en: A graph is *connected* if there is a path from every vertex to every other vertex.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从每个顶点到每个其他顶点都存在路径，则图是*连通*的。
- en: A graph that is not connected consists of a set of *connected components*, which
    are maximal connected subgraphs.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非连通的图由一组*连通分量*组成，这些连通分量是最大连通子图。
- en: An *acyclic graph* is a graph with no cycles.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无环图*是一个没有循环的图。'
- en: A *tree* is an acyclic connected graph.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*树*是一个无环连通图。'
- en: A *forest* is a disjoint set of trees.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*森林*是一组不相交的树。'
- en: A *spanning tree* of a connected graph is a subgraph that contains all of that
    graph's vertices and is a single tree. A *spanning forest* of a graph is the union
    of the spanning trees of its connected components.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连通图的*生成树*是包含该图所有顶点且为单棵树的子图。图的*生成森林*是其连通分量的生成树的并集。
- en: A *bipartite graph* is a graph whose vertices we can divide into two sets such
    that all edges connect a vertex in one set with a vertex in the other set.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二分图*是一个我们可以将其顶点分为两组的图，使得所有边连接一组中的顶点与另一组中的顶点。'
- en: '![Anatomy of a Graph](../Images/46daced0fbff7aa77c7d4c8ace7b72b0.png) ![A tree](../Images/e23ecfdc8c0e0b3eb55c47b055fc8dba.png)
    ![A spanning forest](../Images/ae66ac547a8a63b8d3a44e8466d652e2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图的解剖](../Images/46daced0fbff7aa77c7d4c8ace7b72b0.png) ![一棵树](../Images/e23ecfdc8c0e0b3eb55c47b055fc8dba.png)
    ![一个生成森林](../Images/ae66ac547a8a63b8d3a44e8466d652e2.png)'
- en: Undirected graph data type.
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无向图数据类型。
- en: We implement the following undirected graph API.![Graph API](../Images/0e51968dc76e973997bf5601690a0af7.png)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现以下无向图API。![图API](../Images/0e51968dc76e973997bf5601690a0af7.png)
- en: The key method `adj()` allows client code to iterate through the vertices adjacent
    to a given vertex. Remarkably, we can build all of the algorithms that we consider
    in this section on the basic abstraction embodied in `adj()`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关键方法`adj()`允许客户端代码迭代给定顶点相邻的顶点。值得注意的是，我们可以在`adj()`所体现的基本抽象上构建本节中考虑的所有算法。
- en: We prepare the test data [tinyG.txt](tinyG.txt), [mediumG.txt](mediumG.txt),
    and [largeG.txt](largeG.txt), using the following input file format.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备了测试数据[tinyG.txt](tinyG.txt)、[mediumG.txt](mediumG.txt)和[largeG.txt](largeG.txt)，使用以下输入文件格式。
- en: '![Graph input format](../Images/bc23edebc7ea6cf17d86aea5d7ae5a66.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图输入格式](../Images/bc23edebc7ea6cf17d86aea5d7ae5a66.png)'
- en: '[GraphClient.java](GraphClient.java.html) contains typical graph-processing
    code.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[图客户端.java](GraphClient.java.html)包含典型的图处理代码。'
- en: Graph representation.
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表示。
- en: We use the *adjacency-lists representation*, where we maintain a vertex-indexed
    array of lists of the vertices connected by an edge to each vertex.![Adjacency-lists
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*邻接表表示法*，其中我们维护一个以顶点索引的数组，数组中的每个元素是与每个顶点通过边连接的顶点的列表。![邻接表
- en: representation of an undirected graph](../Images/a03cd6de373b9fe9b46255254691e839.png)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无向图的表示](../Images/a03cd6de373b9fe9b46255254691e839.png)
- en: '[Graph.java](Graph.java.html) implements the graph API using the adjacency-lists
    representation. [AdjMatrixGraph.java](AdjMatrixGraph.java.html) implements the
    same API using the adjacency-matrix representation.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图.java](Graph.java.html)使用邻接表表示法实现了图API。[邻接矩阵图.java](AdjMatrixGraph.java.html)使用邻接矩阵表示法实现了相同的API。'
- en: Depth-first search.
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度优先搜索。
- en: Depth-first search is a classic recursive method for systematically examining
    each of the vertices and edges in a graph. To visit a vertex
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索是一种经典的递归方法，用于系统地检查图中的每个顶点和边。要访问一个顶点
- en: Mark it as having been visited.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其标记为已访问。
- en: Visit (recursively) all the vertices that are adjacent to it and that have not
    yet been marked.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问（递归地）所有与其相邻且尚未标记的���点。
- en: '[DepthFirstSearch.java](DepthFirstSearch.java.html) implements this approach
    and the following API:![Search API](../Images/cf60cdfd3ef4b9527a3058d7aa0c12f7.png)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[深度优先搜索.java](DepthFirstSearch.java.html)实现了这种方法和以下API：![搜索API](../Images/cf60cdfd3ef4b9527a3058d7aa0c12f7.png)'
- en: Finding paths.
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找路径。
- en: It is easy to modify depth-first search to not only determine whether there
    exists a path between two given vertices but to find such a path (if one exists).
    We seek to implement the following API:![Paths API](../Images/1f002f067f834492b9dc3f4994acf121.png)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 修改深度优先搜索以确定两个给定顶点之间是否存在路径以及找到这样的路径（如果存在）。我们试图实现以下API：![路径API](../Images/1f002f067f834492b9dc3f4994acf121.png)
- en: To accomplish this, we remember the edge `v-w` that takes us to each vertex
    `w` for the *first* time by setting `edgeTo[w]` to `v`. In other words, `v-w`
    is the last edge on the known path from <t>s to `w`. The result of the search
    is a tree rooted at the source; `edgeTo[]` is a parent-link representation of
    that tree. [DepthFirstPaths.java](DepthFirstPaths.java.html) implements this approach.</t>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们通过将`edgeTo[w]`设置为`v`来记住将我们带到每个顶点`w`的边缘`v-w`，这是*第一次*。换句话说，`v-w`是从源到`w`的已知路径上的最后一条边。搜索的结果是以源为根的树；`edgeTo[]`是该树的父链接表示。[深度优先路径.java](DepthFirstPaths.java.html)实现了这种方法。
- en: Breadth-first search.
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广度优先搜索。
- en: Depth-first search finds some path from a source vertex s to a target vertex
    v. We are often interested in finding the *shortest* such path (one with a minimal
    number of edges). Breadth-first search is a classic method based on this goal.
    To find a shortest path from `s` to `v`, we start at `s` and check for `v` among
    all the vertices that we can reach by following one edge, then we check for `v`
    among all the vertices that we can reach from `s` by following two edges, and
    so forth.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索找到从源顶点s到目标顶点v的一条路径。我们经常有兴趣找到*最短*这样的路径（具有最小数量的边）。广度优先搜索是基于这个目标的经典方法。要从`s`到`v`找到最短路径，我们从`s`开始，并在我们可以通过一条边到达的所有顶点中检查`v`，然后我们在我们可以通过两条边从`s`到达的所有顶点中检查`v`，依此类推。
- en: 'To implement this strategy, we maintain a queue of all vertices that have been
    marked but whose adjacency lists have not been checked. We put the source vertex
    on the queue, then perform the following steps until the queue is empty:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种策略，我们维护一个队列，其中包含所有已标记但其邻接列表尚未被检查的顶点。我们将源顶点放入队列，然后执行以下步骤，直到队列为空：
- en: Remove the next vertex `v` from the queue.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从队列中移除下一个顶点`v`。
- en: Put onto the queue all unmarked vertices that are adjacent to `v` and mark them.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有未标记的与`v`相邻的顶点放入队列并标记它们。
- en: '[BreadthFirstPaths.java](BreadthFirstPaths.java.html) is an implementation
    of the `Paths` API that finds shortest paths. It relies on [Queue.java](Queue.java.html)
    for the FIFO queue.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[广度优先路径.java](BreadthFirstPaths.java.html)是实现`Paths` API的一个实现，用于找到最短路径。它依赖于[FIFO队列.java](Queue.java.html)。'
- en: Connected components.
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连通分量。
- en: Our next direct application of depth-first search is to find the connected components
    of a graph. Recall from Section 1.5 that "is connected to" is an equivalence relation
    that divides the vertices into equivalence classes (the connected components).
    For this task, we define the following API:![Connected Components API](../Images/cd756b03442c99919be26c3000b7ce1e.png)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个直接应用深度优先搜索的是找到图的连通分量。回想一下第1.5节，“连接到”是将顶点划分为等价类（连通分量）的等价关系。对于这个任务，我们定义以下API：![连通分量API](../Images/cd756b03442c99919be26c3000b7ce1e.png)
- en: '[CC.java](CC.java.html) uses DFS to implement this API.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[CC.java](CC.java.html)使用DFS实现此API。'
- en: '**Proposition.** DFS marks all the vertices connected to a given source in
    time proportional to the sum of their degrees and provides clients with a path
    from a given source to any marked vertex in time proportional to its length.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题。** DFS在时间上标记与给定源连接的所有顶点，其时间与其度数之和成正比，并为客户提供从给定源到任何标记顶点的路径，其时间与其长度成正比。'
- en: '**Proposition.** For any vertex `v` reachable from `s`, BFS computes a shortest
    path from `s` to `v` (no path from `s` to `v` has fewer edges). BFS takes time
    proportional to V + E in the worst case.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题。**对于从`s`可达的任何顶点`v`，BFS计算从`s`到`v`的最短路径（从`s`到`v`没有更少的边的路径）。在最坏情况下，BFS花费时间与V
    + E成正比。'
- en: '**Proposition.** DFS uses preprocessing time and space proportional to V +
    E to support constant-time connectivity queries in a graph.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**命题。** DFS使用预处理时间和空间与V + E成正比，以支持图中的常数时间连接查询。'
- en: More depth-first search applications.
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多深度优先搜索应用。
- en: 'The problems that we have solved with DFS are fundamental. Depth-first search
    can also be used to solve the following problems:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用DFS解决的问题是基础的。深度优先搜索还可以用于解决以下问题：
- en: '*Cycle detection:* Is a given graph acyclic? [Cycle.java](Cycle.java.html)
    uses depth-first search to determine whether a graph has a cycle, and if so return
    one. It takes time proportional to V + E in the worst case.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*循环检测：*给定图是否无环？[循环.java](Cycle.java.html)使用深度优先搜索来确定图是否有循环，如果有，则返回一个。在最坏情况下，它花费时间与V
    + E成正比。'
- en: '*Two-colorability:* Can the vertices of a given graph be assigned one of two
    colors in such a way that no edge connects vertices of the same color? [Bipartite.java](Bipartite.java.html)
    uses depth-first search to determine whether a graph has a bipartition; if so,
    return one; if not, return an odd-length cycle. It takes time proportional to
    V + E in the worst case.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双色性：*给定图的顶点是否可以被分配为两种颜色，以便没有边连接相同颜色的顶点？[二分图.java](Bipartite.java.html)使用深度优先搜索来确定图是否具有二��图；如果是，则返回一个；如果不是，则返回一个奇数长度的循环。在最坏情况下，它花费时间与V
    + E成正比。'
- en: '*Bridge:* A *bridge* (or *cut-edge*) is an edge whose deletion increases the
    number of connected components. Equivalently, an edge is a bridge if and only
    if it is not contained in any cycle. [Bridge.java](Bridge.java.html) uses depth-first
    search to find time the bridges in a graph. It takes time proportional to V +
    E in the worst case.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*桥：* *桥*（或*割边*）是一条删除后会增加连接组件数量的边。等价地，仅当边不包含在任何循环中时，边才是桥。[桥.java](Bridge.java.html)使用深度优先搜索在图中找到桥。在最坏情况下，它花费时间与V
    + E成正比。'
- en: '*Biconnectivity:* An *articulation vertex* (or *cut vertex*) is a vertex whose
    removal increases the number of connected components. A graph is *biconnected*
    if it has no articulation vertices. [Biconnected.java](Biconnected.java.html)
    uses depth-first search to find the bridges and articulation vertices. It takes
    time proportional to V + E in the worst case.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双连通性：*一个*关节点*（或*割点*）是一个移除后会增加连接组件数量的顶点。如果没有关节点，则图形是*双连通*的。[Biconnected.java](Biconnected.java.html)使用深度优先搜索来查找桥梁和关节点。在最坏情况下，它的时间复杂度为V
    + E。'
- en: '*Planarity:* A graph is *planar* if it can be drawn in the plane such that
    no edges cross one another. The Hopcroft-Tarjan algorithm is an advanced application
    of depth-first search that determines whether a graph is planar in linear time.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平面性：*如果可以在平面上绘制图形，使得没有边相互交叉，则图形是*平面*的。 Hopcroft-Tarjan算法是深度优先搜索的高级应用，它可以在线性时间内确定图形是否是平面的。'
- en: Symbol graphs.
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号图。
- en: 'Typical applications involve processing graphs using strings, not integer indices,
    to define and refer to vertices. To accommodate such applications, we define an
    input format with the following properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 典型应用涉及使用字符串而不是整数索引来处理图形，以定义和引用顶点。为了适应这些应用程序，我们定义了具有以下属性的输入格式：
- en: Vertex names are strings.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点名称是字符串。
- en: A specified delimiter separates vertex names (to allow for the possibility of
    spaces in names).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的分隔符分隔顶点名称（以允许名称中包含空格的可能性）。
- en: Each line represents a set of edges, connecting the first vertex name on the
    line to each of the other vertices named on the line.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行表示一组边，将该行上的第一个顶点名称连接到该行上命名的每个其他顶点。
- en: The input file [routes.txt](routes.txt) is a small example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件[routes.txt](routes.txt)是一个小例子。
- en: '![airline routes](../Images/2f0ea35e84ad2da2af76274beca97414.png)'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![航线](../Images/2f0ea35e84ad2da2af76274beca97414.png)'
- en: The input file [movies.txt](movies.txt) is a larger example from the [Internet
    Movie Database](imdb.com). This file consists of lines listing a movie name followed
    by a list of the performers in the movie.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件[movies.txt](movies.txt)是来自[互联网电影数据库](imdb.com)的一个更大的示例。该文件包含列出电影名称后跟电影中表演者列表的行。
- en: '![movie-performer graph](../Images/73fe01debd55f407d63e6dde777b1ea2.png)'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![电影-表演者图](../Images/73fe01debd55f407d63e6dde777b1ea2.png)'
- en: '*API.* The following API allows us to use our graph-processing routines for
    such input files.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*API。* 以下API允许我们为这种输入文件使用我们的图处理例程。'
- en: '![symbol graph API](../Images/2218ddcda67356768e65337c6dbb2d04.png)'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![符号图API](../Images/2218ddcda67356768e65337c6dbb2d04.png)'
- en: '*Implementation.* [SymbolGraph.java](SymbolGraph.java.html) implements the
    API. It builds three data structures:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现。*[SymbolGraph.java](SymbolGraph.java.html)实现了API。它构建了三种数据结构：'
- en: A symbol table `st` with `String` keys (vertex names) and `int` values (indices)
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个符号表`st`，具有`String`键（顶点名称）和`int`值（索引）
- en: An array `keys[]` that serves as an inverted index, giving the vertex name associated
    with each integer index
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个作为反向索引的数组`keys[]`，给出与每个整数索引关联的顶点名称
- en: A `Graph` `G` built using the indices to refer to vertices
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用索引构建的`Graph` `G`，以引用顶点
- en: '![symbol graph data structures](../Images/eed7178c60fcb5112f09b6876942314f.png)'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![符号图数据结构](../Images/eed7178c60fcb5112f09b6876942314f.png)'
- en: '*Degrees of separation.* [DegreesOfSeparation.java](DegreesOfSeparation.java.html)
    uses breadth-first search to find the degree of separation between two individuals
    in a social network. For the actor-movie graph, it plays the Kevin Bacon game.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分离度。*[DegreesOfSeparation.java](DegreesOfSeparation.java.html)使用广度优先搜索来查找社交网络中两个个体之间的分离度。对于演员-电影图，它玩的是凯文·贝肯游戏。'
- en: Exercises
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: Create a copy constructor for [Graph.java](Graph.java.html) that takes as input
    a graph `G` and creates and initializes a new copy of the graph. Any changes a
    client makes to `G` should not affect the newly created graph.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为[Graph.java](Graph.java.html)创建一个复制构造函数，该构造函数以图`G`作为输入，并创建并初始化图的新副本。客户端对`G`所做的任何更改都不应影响新创建的图。
- en: Add a `distTo()` method to [BreadthFirstPaths.java](BreadthFirstPaths.java.html),
    which returns the number of edges on the shortest path from the source to a given
    vertex. A `distTo()` query should run in constant time.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向[BreadthFirstPaths.java](BreadthFirstPaths.java.html)添加一个`distTo()`方法，该方法返回从源到给定顶点的最短路径上的边数。`distTo()`查询应在常数时间内运行。
- en: Write a program [BaconHistogram.java](BaconHistogram.java.html) that prints
    a histogram of Kevin Bacon numbers, indicating how many performers from [movies.txt](movies.txt)
    have a Bacon number of 0, 1, 2, 3, ... . Include a category for those who have
    an infinite number (not connected to Kevin Bacon).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序[BaconHistogram.java](BaconHistogram.java.html)，打印凯文·贝肯号的直方图，指示[movies.txt](movies.txt)中有多少表演者的贝肯号为0、1、2、3等。包括那些具有无限号码的类别（与凯文·贝肯没有联系）。
- en: Write a `SymbolGraph` client [DegreesOfSeparationDFS.java](DegreesOfSeparationDFS.java.html)
    that uses *depth-first* instead of breadth-first search to find paths connecting
    two performers.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`SymbolGraph`客户端[DegreesOfSeparationDFS.java](DegreesOfSeparationDFS.java.html)，该客户端使用*深度优先*而不是广度优先搜索来查找连接两个表演者的路径。
- en: Determine the amount of memory used by `Graph` to represent a graph with `V`
    vertices and `E` edges, using the memory-cost model of Section 1.4.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第1.4节的内存成本模型确定`Graph`表示具有`V`个顶点和`E`条边的图所使用的内存量。
- en: '*Solution.* 56 + 40V + 128E. [MemoryOfGraph.java](MemoryOfGraph.java.html)
    computes it empirically assuming that no `Integer` values are cached—Java typically
    caches the integers -128 to 127.'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案。* 56 + 40V + 128E。[MemoryOfGraph.java](MemoryOfGraph.java.html)根据经验计算，假设没有缓��`Integer`值—Java通常会缓存-128到127之间的整数。'
- en: Creative Problems
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创意问题
- en: '**Parallel edge detection.** Devise a linear-time algorithm to count the parallel
    edges in a graph.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**并行边检测。**设计一个线性时间算法来计算图中的平行边数。'
- en: '*Hint*: maintain a boolean array of the neighbors of a vertex, and reuse this
    array by only reinitializing the entries as needed.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：维护一个顶点的邻居的布尔数组，并通过仅在需要时重新初始化条目来重复使用此数组。'
- en: '**Two-edge connectivity.** A *bridge* in a graph is an edge that, if removed,
    would separate a connected graph into two disjoint subgraphs. A graph that has
    no bridges is said to be *two-edge connected*. Develop a DFS-based data type [Bridge.java](Bridge.java.html)
    for determining whether a given graph is edge connected.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双边连通性。** 在图中，*桥*是一条边，如果移除，则会将一个连通图分隔成两个不相交的子图。没有桥的图被称为*双边连通*。开发一个基于DFS的数据类型[Bridge.java](Bridge.java.html)，用于确定给定图是否是边连通的。'
- en: Web Exercises
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网页练习
- en: Find some interesting graphs. Are they directed or undirected? Sparse or dense?
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找一些有趣的图。它们是有向的还是无向的？稀疏的还是密集的？
- en: '**Degree.** The degree of a vertex is the number of incident edges. Add a method
    `int degree(int v)` to `Graph` that returns the degree of the vertex v.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**度。** 顶点的度是与之关联的边的数量。向`Graph`添加一个方法`int degree(int v)`，返回顶点v的度数。'
- en: Suppose you use a stack instead of a queue when running breadth-first search.
    Does it still compute shortest paths?
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设在运行广度优先搜索时使用堆栈而不是队列。它仍然计算最短路径吗？
- en: '**DFS with an explicit stack.** Give an example of possibility of stack overflow
    with DFS using the function call stack, e.g., line graph. Modify [DepthFirstPaths.java](DepthFirstPaths.java.html)
    so that it uses an explicit stack instead of the function call stack.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用显式堆栈的DFS。** 给出DFS可能出现堆栈溢出的示例，例如，线图。修改[DepthFirstPaths.java](DepthFirstPaths.java.html)，使其使用显式堆栈而不是函数调用堆栈。'
- en: '**Perfect maze.** Generate a [perfect maze](http://www.mazeworks.com/mazegen/mazetut/index.htm)
    like this one'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完美迷宫。** 生成一个[完美迷宫](http://www.mazeworks.com/mazegen/mazetut/index.htm)像这样的'
- en: '| ![14-by-14 perfect maze](../Images/8bbbfca0ad42890f0b0413098edbbbb6.png)
    | ![22-by-22 perfect maze](../Images/90a35a525fbaaf918d724c57d4c9a95e.png) |'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![14×14完美迷宫](../Images/8bbbfca0ad42890f0b0413098edbbbb6.png) | ![22×22完美迷宫](../Images/90a35a525fbaaf918d724c57d4c9a95e.png)
    |'
- en: 'Write a program [Maze.java](Maze.java.html) that takes a command-line argument
    n, and generates a random n-by-n perfect maze. A maze is *perfect* if it has exactly
    one path between every pair of points in the maze, i.e., no inaccessible locations,
    no cycles, and no open spaces. Here''s a nice algorithm to generate such mazes.
    Consider an n-by-n grid of cells, each of which initially has a wall between it
    and its four neighboring cells. For each cell (x, y), maintain a variable `north[x][y]`
    that is `true` if there is wall separating (x, y) and (x, y + 1). We have analogous
    variables `east[x][y]`, `south[x][y]`, and `west[x][y]` for the corresponding
    walls. Note that if there is a wall to the north of (x, y) then `north[x][y] =
    south[x][y+1] = true`. Construct the maze by knocking down some of the walls as
    follows:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序[Maze.java](Maze.java.html)，它接受一个命令行参数n，并生成一个随机的n×n完美迷宫。如果迷宫*完美*，则每对迷宫中的点之间都有一条路径，即没有无法访问的位置，没有循环，也没有开放空间。这里有一个生成这样的迷宫的好算法。考虑一个n×n的单元格网格，每个单元格最初与其四个相邻单元格之间都有一堵墙。对于每个单元格（x,
    y），维护一个变量`north[x][y]`，如果存在将（x, y）和（x, y + 1）分隔的墙，则为`true`。我们有类似的变量`east[x][y]`，`south[x][y]`和`west[x][y]`用于相应的墙壁。请注意，如果（x,
    y）的北面有一堵墙，则`north[x][y] = south[x][y+1] = true`。通过以下方式拆除一些墙壁来构建迷宫：
- en: Start at the lower level cell (1, 1).
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从较低级别单元格（1, 1）开始。
- en: Find a neighbor at random that you haven't yet been to.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机找到一个您尚未到达的邻居。
- en: If you find one, move there, knocking down the wall. If you don't find one,
    go back to the previous cell.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到一个，就移动到那里，拆除墙壁。如果找不到，则返回上一个单元格。
- en: Repeat steps ii. and iii. until you've been to every cell in the grid.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤ii.和iii.，直到您访问了网格中的每个单元格。
- en: '*Hint:* maintain an (n+2)-by-(n+2) grid of cells to avoid tedious special cases.'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：维护一个(n+2)×(n+2)的单元格网格，以避免繁琐的特殊情况。'
- en: Here is a Mincecraft maze created by Carl Eklof using this algorithm.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是由卡尔·埃克洛夫使用此算法创建的一个Mincecraft迷宫。
- en: '![Minecraft maze](../Images/be08c6c1c40896e8782849a774cb48be.png)'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Minecraft迷宫](../Images/be08c6c1c40896e8782849a774cb48be.png)'
- en: '**Getting out of the maze.** Given an n-by-n maze (like the one created in
    the previous exercise), write a program to find a path from the start cell (1,
    1) to the finish cell (n, n), if it exists. To find a solution to the maze, run
    the following algorithm, starting from (1, 1) and stopping if we reach cell (n,
    n).'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**走出迷宫。** 给定一个n×n的迷宫（就像在前一个练习中创建的那样），编写一个程序，如果存在路径，则从起始单元格（1, 1）到终点单元格（n, n）找到一条路径。要找到迷宫的解决方案，请运行以下算法，从（1,
    1）开始，并在到达单元格（n, n）时停止。'
- en: '[PRE0]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Maze game.** Develop a [maze game](maze.swf) like this one from [gamesolo.com](http://www.gamesolo.com/flash-game),
    where you traverse a maze, collecting prizes.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**迷宫游戏。** 开发一个[迷宫游戏](maze.swf)，就像来自[gamesolo.com](http://www.gamesolo.com/flash-game)的这个，您在其中穿过迷宫，收集奖品。'
- en: '**Actor graph.** An alternate (and perhaps more natural) way to compute Kevin
    Bacon numbers is to build a graph where each node is an actor. Two actors are
    connected by an edge if they appear in a movie together. Calculate Kevin Bacon
    numbers by running BFS on the actor graph. Compare the running time versus the
    algorithm described in the text. Explain why the approach in the text is preferable.
    *Answer*: it avoids multiple parallel edges. As a result, it''s faster and uses
    less memory. Moreover, it''s more convenient since you don''t have to label the
    edges with the movie names - all names get stored in the vertices.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**演员图。** 计算凯文·贝肯数的另一种（也许更自然）方法是构建一个图，其中每个节点都是一个演员。如果两个演员一起出现在一部电影中，则它们之间通过一条边连接。通过在演员图上运行BFS来计算凯文·贝肯数。比较与文本中描述的算法的运行时间。解释为什么文本中的方法更可取。*答案*：它避免了多个平行边。因此，它更快，使用的内存更少。此外，它更方便，因为您不必使用电影名称标记边缘-所有名称都存储在顶点中。'
- en: '**Center of the Hollywood universe.** We can measure how good of a center that
    Kevin Bacon is by computing their *Hollywood number*. The Hollywood number of
    Kevin Bacon is the average Bacon number of all the actors. The Hollywood number
    of another actor is computed the same way, but we make them be the source instead
    of Kevin Bacon. Compute Kevin Bacon''s Hollywood number and find an actor and
    actress with better Hollywood numbers.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**好莱坞宇宙的中心。** 我们可以通过计算他们的*好莱坞数*来衡量凯文·贝肯是一个多好的中心。凯文·贝肯的好莱坞数是所有演员的平均贝肯数。另一位演员的好莱坞数计算方式相同，但我们让他们成为源，而不是凯文·贝肯。计算凯文·贝肯的好莱坞数，并找到一个演员和一个女演员，他们的好莱坞数更好。'
- en: '**Fringe of the Hollywood universe.** Find the actor (who is connected to Kevin
    Bacon) that has the highest Hollywood number.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**好莱坞宇宙的边缘。** 找到（与凯文·贝肯相连的）具有最高好莱坞数的演员。'
- en: '**Word ladders.** Write a program [WordLadder.java](WordLadder.java.html) that
    takes two 5 letter strings from the command line, and reads in a list of [5 letter
    words](words5.txt) from standard input, and prints out a shortest [word ladder](http://www.wordplay.fsnet.co.uk/wl/ladders.htm)
    connecting the two strings (if it exists). Two words can be connected in a word
    ladder chain if they differ in exactly one letter. As an example, the following
    word ladder connects green and brown.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单词梯子。** 编写一个程序[WordLadder.java](WordLadder.java.html)，从命令行中获取两个5个字母的字符串，并从标准输入中读取一个[5个字母的单词列表](words5.txt)，然后打印出连接这两个字符串的最短[单词梯子](http://www.wordplay.fsnet.co.uk/wl/ladders.htm)（如果存在）。如果两个单词在一个字母上不同，那么它们可以在一个单词梯子链中连接起来。例如，以下单词梯子连接了green和brown。'
- en: '[PRE1]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also try out your program on this list of [6 letter words](words6.txt).
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以尝试在这个[6个字母单词列表](words6.txt)上运行你的程序。
- en: '**Faster word ladders.** To speed things up (if the word list is very large),
    don''t write a nested loop to try all pairs of words to see if they are adjacent.
    To handle 5 letter words, first sort the word list. Words that only differ in
    their last letter will appear consecutively in the sorted list. Sort 4 more times,
    but cyclically shift the letters one position to the right so that words that
    differ in the ith letter will appear consecutively in one of the sorted lists.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更快的单词梯子。** 为了加快速度（如果单词列表非常大），不要编写嵌套循环来尝试所有成对的单词是否相邻。对于5个字母的单词，首先对单词列表进行排序。只有最后一个字母不同的单词将在排序后的列表中连续出现。再排序4次，但将字母向右循环移动一个位置，以便在一个排序列表中连续出现在第i个字母上不同的单词。'
- en: Try out this approach using a [larger word list](/introcs/datafiles/words.txt)
    with words of different sizes. Two words of different lengths are neighbors if
    the smaller word is the same as the bigger word, minus the last letter, e.g.,
    brow and brown.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试使用一个[更大的单词列表](/introcs/datafiles/words.txt)来测试这种方法，其中包含不同长度的单词。如果两个长度不同的单词���有最后一个字母不同，则它们是相邻的。
- en: 'Suppose you delete all of the bridges in an undirected graph. Are the connected
    components of the resulting graph the biconnected components? *Answer*: no, two
    biconnected components can be connected through an articulation point.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你删除无向图中的所有桥梁。结果图的连通分量是否是双连通分量？*答案*：不是，两个双连通分量可以通过一个关节点连接。
- en: Bridges and articulation points.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥梁和关节点。
- en: 'A *bridge* (or cut edge) is an edge whose removal disconnects the graph. An
    *articulation point* (or cut vertex) is a vertex whose removal (and removal of
    all incident edges) disconnects the remaining graph. Bridges and articulations
    points are important because they represent a single point of failure in a network.
    Brute force: delete edge (or vertex) and check connectivity. Takes O(E(V + E))
    and O(V(V + E)) time, respectively. Can improve both to O(E + V) using clever
    extension to DFS.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*桥梁*（或割边）是一条移除后会断开图的边。*关节点*（或割点）是一个移除后（以及移除所有关联边后）会断开剩余图的顶点。桥梁和关节点很重要，因为它们代表网络中的单点故障。蛮力方法：删除边（或顶点）并检查连通性。分别需要O(E(V
    + E))和O(V(V + E))的时间。可以通过巧妙地扩展DFS将两者都改进为O(E + V)。'
- en: '**Biconnected components.** An undirected graph is *biconnected* if for every
    pair of vertices v and w, there are two vertex-disjoint paths between v and w.
    (Or equivalently a simple cycle through any two vertices.) We define a cocyclicity
    equivalence relation on the edges: two edges e1 and e2 are are in same biconnected
    component if e1 = e2 or there exists a cycle containing both e1 and e2. Two biconnected
    components share at most one vertex in common. A vertex is an articulation point
    if and only if it is common to more than one biconnected component. Program [Biconnected.java](Biconnected.java.html)
    identifies the bridges and articulation points.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双连通分量。** 一个无向图是*双连通*的，如果对于每一对顶点v和w，v和w之间有两条顶点不重叠的路径。（或者等价地，通过任意两个顶点的简单循环。）我们在边上定义一个共圆等价关系：如果e1
    = e2或者存在包含e1和e2的循环，则e1和e2在同一个双连通分量中。两个双连通分量最多共享一个公共顶点。一个顶点是关节点，当且仅当它是多于一个双连通分量的公共部分时。程序[Biconnected.java](Biconnected.java.html)标识出桥梁和关节点。'
- en: '**Biconnected components.** Modify `Biconnected` to print out the edges that
    constitute each biconnected component. Hint: each bridge is its own biconnected
    component; to compute the other biconnected components, mark each articulation
    point as visited, and then run DFS, keeping track of the edges discovered from
    each DFS start point.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双连通分量。** 修改`Biconnected`以打印构成每个双连通分量的边。提示：每个桥梁都是自己的双连通分量；要计算其他双连通分量，将每个关节点标记为已访问，然后运行DFS，跟踪从每个DFS起点发现的边。'
- en: Perform numerical experiments on the number of connected components for random
    undirected graphs. Phase change around 1/2 V ln V. (See Property 18.13 in Algs
    Java.)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对随机无向图的连通分量数量进行数值实验。在1/2 V ln V附近发生相变。（参见Algs Java中的属性18.13。）
- en: '**Rogue.** (Andrew Appel.) A monster and a player are each located at a distinct
    vertex in an undirected graph. In the role playing game Rogue, the player and
    the monster alternate turns. In each turn the player can move to an adjacent vertex
    or stays put. Determine all vertices that the player can reach before the monster.
    Assume the player gets the first move.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**流氓。**（安德鲁·阿普尔。）在一个无向图中，一个怪物和一个玩家分别位于不同的顶点。在角色扮演游戏Rogue中，玩家和怪物轮流行动。每轮中，玩家可以移动到相邻的顶点或原地不动。确定玩家在怪物之前可以到达的所有顶点。假设玩家先行动。'
- en: '**Rogue.** (Andrew Appel.) A monster and a player are each located at a distinct
    vertex in an undirected graph. The goal of the monster is to land on the same
    vertex as the player. Devise an optimal strategy for the monster.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**流氓。**（安德鲁·阿普尔。）在一个无向图中，一个怪物和一个玩家分别位于不同的顶点。怪物的目标是落在与玩家相同的顶点上。为怪物设计一个最佳策略。'
- en: '**Articulation point.** Let G be a connected, undirected graph. Consider a
    DFS tree for G. Prove that vertex v is an articulation point of G if and only
    if either (i) v is the root of the DFS tree and has more than one child or (ii)
    v is not the root of the DFS tree and for some child w of v there is no back edge
    between any descendant of w (including w) and a proper ancestor of v. In other
    words, v is an articulation point if and only if (i) v is the root and has more
    than one child or (ii) v has a child w such that low[w] >= pre[v].'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关节点。** 设G是一个连通的无向图。考虑G的DFS树。证明顶点v是G的关节点当且仅当（i）v是DFS树的根并且有多于一个子节点，或者（ii）v不是DFS树的根并且对于v的某个子节点w，w的任何后代（包括w）和v的某个祖先之间没有反向边。换句话说，v是关节点当且仅当（i）v是根并且有多于一个子节点，或者（ii）v有一个子节点w，使得low[w]
    >= pre[v]。'
- en: '**Sierpinski gasket.** Nice example of an Eulerian graph.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**谢尔宾斯基垫。** 一个优美的欧拉图的例子。'
- en: '**Preferential attachment graphs.** Create a random graph on V vertices and
    E edges as follows: start with V vertices v1, .., vn in any order. Pick an element
    of sequence uniformly at random and add to end of sequence. Repeat 2E times (using
    growing list of vertices). Pair up the last 2E vertices to form the graph.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优先连接图。** 如下创建一个具有V个顶点和E条边的随机图：以任意顺序开始具有V个顶点v1，..，vn。均匀随机选择序列的一个元素并添加到序列的末尾。重复2E次（使用不断增长的顶点列表）。将最后的2E个顶点配对以形成图。'
- en: Roughly speaking, it's equivalent to adding each edge one-by-one with probability
    proportional to the product of the degrees of the two endpoints. [Reference](http://research.microsoft.com/users/lovasz/hom-survey.pdf).
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大致来说，等价于按照两个端点的度数的乘积成比例的概率逐个添加每条边。[参考](http://research.microsoft.com/users/lovasz/hom-survey.pdf)。
- en: '**Wiener index.** The Wiener index of a vertex is the sum of the shortest path
    distances between v and all other vertices. The Wiener index of a graph G is the
    sum of the shortest path distances over all pairs of vertices. Used by mathematical
    chemists (vertices = atoms, edges = bonds).'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**维纳指数。** 一个顶点的维纳指数是该顶点与所有其他顶点之间的最短路径距离之和。图G的维纳指数是所有顶点对之间的最短路径距离之和。被数学化学家使用（顶点=原子，边=键）。'
- en: '**Random walk.** Easy algorithm for getting out of a maze (or st connectivity
    in a graph): at each step, take a step in a random direction. With complete graph,
    takes V log V time (coupon collector); for line graph or cycle, takes V^2 time
    (gambler''s ruin). In general the cover time is at most 2E(V-1), a classic result
    of Aleliunas, Karp, Lipton, Lovasz, and Rackoff.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**随机游走。** 从迷宫中走出（或图中的st连通性）的简单算法：每一步，朝一个随机方向迈出一步。对于完全图，需要V log V时间（收集优惠券）；对于线图或环，需要V^2时间（赌徒的失败）。一般来说，覆盖时间最多为2E(V-1)，这是Aleliunas、Karp、Lipton、Lovasz和Rackoff的经典结果。'
- en: '**Deletion order.** Given a connected graph, determine an order to delete the
    vertices such that each deletion leaves the (remaining) graph connected. Your
    algorithm should take time proportional to V + E in the worst case.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除顺序。** 给定一个连通图，确定一个顺序来删除顶点，使得每次删除后图仍然连通。你的算法在最坏情况下应该花费与V + E成比例的时间。'
- en: '**Center of a tree.** Given a graph that is a tree (connected and acyclic),
    find a vertex such that its maximum distance from any other vertex is minimized.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**树的中心。** 给定一个树（连通且无环）的图，找到一个顶点，使得它与任何其他顶点的最大距离最小化。'
- en: '*Hint*: find the diameter of the tree (the longest path between two vertices)
    and return a vertex in the middle.'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示*：找到树的直径（两个顶点之间的最长路径）并返回中间的一个顶点。'
- en: '**Diameter of a tree.** Given a graph that is a tree (connected and acyclic),
    find the longest path, i.e., a pair of vertices v and w that are as far apart
    as possible. Your algorithm should run in linear time.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**树的直径。** 给定一个树（连通且无环）的图，找到最长的路径，即一对顶点v和w，它们之间的距离最远。你的算法应该在线性时间内运行。'
- en: '*Hint.* Pick any vertex v. Compute the shortest path from v to every other
    vertex. Let w be the vertex with the largest shortest path distance. Compute the
    shortest path from w to every other vertex. Let x be the vertex with the largest
    shortest path distance. The path from w to x gives the diameter.'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示。* 选择任意顶点v。计算从v到每个其他顶点的最短路径。设w是最大最短路径距离的顶点。计算从w到每个其他顶点的最短路径。设x是最大最短路径距离的顶点。从w到x的路径给出直径。'
- en: '**Bridges with union-find.** Let T be a spanning tree of a connected graph
    G. Each non-tree edge e in G forms a fundamental cycle consisting of the edge
    e plus the unique path in the tree joining its endpoings. Show that an edge is
    a bridge if and only if it is not on some fundamental cycle. Thus, all bridges
    are edges of the spanning tree. Design an algorithm to find all of the bridges
    (and bridge components) using E + V time plus E + V union-find operations.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用并查集查找桥梁。** 设T是一个连通图G的生成树。图G中的每条非树边e形成一个由边e和树中连接其端点的唯一路径组成的基本环。证明一条边是桥梁当且仅当它不在某个基本环上。因此，所有桥梁都是生成树的边。设计一个算法，使用E
    + V时间加上E + V并查集操作，找到所有桥梁（和桥梁组件）。'
- en: '**Nonrecursive depth-first search.** Write a program [NonrecursiveDFS.java](NonrecursiveDFS.java.html)
    that implements depth-first search with an explicit stack instead of recursion.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非递归深度优先搜索。** 编写一个程序 [NonrecursiveDFS.java](NonrecursiveDFS.java.html)，使用显式堆栈而不是递归来实现深度优先搜索。'
- en: Here is an alternate implementation suggested by Bin Jiang in the early 1990s.
    The only extra memory is for a stack of vertices but that stack must support arbitrary
    deletion (or at least the movement of an arbitrary item to the top of the stack).
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 Bin Jiang 在 1990 年代初提出的另一种实现。唯一额外的内存是用于顶点堆栈，但该堆栈必须支持任意删除（或至少将任意项移动到堆栈顶部）。
- en: '[PRE2]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here is yet another implementation. It is, perhaps, the simplest nonrecursive
    implementation, but it uses space proportional to E + V in the worst case (because
    more than one copy of a vertex can be on the stack) and it explores the vertices
    adjacent to v in the reverse order of the standard recursive DFS. Also, an `edgeTo[v]`
    entry may be updated more than once, so it may not be suitable for backtracking
    applications.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是另一种实现。这可能是最简单的非递归实现，但在最坏情况下使用的空间与 E + V 成比例（因为一个顶点的多个副本可能在堆栈上），并且以标准递归 DFS
    的相反顺序探索与 v 相邻的顶点。此外，`edgeTo[v]` 条目可能被更新多次，因此可能不适用于回溯应用。
- en: '[PRE3]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Nonrecursive depth-first search.** Explan why the following nonrecursive
    method (analogous to BFS but using a stack instead of a queue) does *not* implement
    depth-first search.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非递归深度优先搜索。** 解释为什么以下非递归方法（类似于 BFS，但使用堆栈而不是队列）*不*实现深度优先搜索。'
- en: '[PRE4]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Solution:* Consider the graph consisting of the edges 0-1, 0-2, 1-2, and 2-1,
    with vertex 0 as the source.'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案：*考虑由边 0-1、0-2、1-2 和 2-1 组成的图，其中顶点 0 为源。'
- en: '**Matlab connected components.** bwlabel() or bwlabeln() in Matlab label the
    connected components in a 2D or kD binary image. bwconncomp() is newer version.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Matlab 连通分量。** 在 Matlab 中，bwlabel() 或 bwlabeln() 用于标记 2D 或 kD 二进制图像中的连通分量。bwconncomp()
    是更新版本。'
- en: '**Shortest path in complement graph.** Given a graph G, design an algorithm
    to find the shortest path (number of edges) between s and every other vertex in
    the complement graph G''. The *complement* graph contains the same vertices as
    G but includes an edge v-w if and only if the edge v-w is not in G. Can you do
    any better than explicitly computing the complement graph G'' and running BFS
    in G''?'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**互补图中的最短路径。** 给定一个图 G，设计一个算法来找到从 s 到互补图 G'' 中每个其他顶点的最短路径（边的数量）。*互补*图包含与 G
    相同的顶点，但只有当边 v-w 不在 G 中时才包含边 v-w。你能否比明确计算互补图 G'' 并在 G'' 中运行 BFS 做得更好？'
- en: '**Delete a vertex without disconnecting a graph.** Given a connected graph,
    design a linear-time algorithm to find a vertex whose removal (deleting the vertex
    and all incident edges) does not disconnect the graph.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除一个顶点而不断开图。** 给定一个连通图，设计一个线性时间算法来找到一个顶点，其移除（删除顶点和所有关联边）不会断开图。'
- en: '*Hint 1 (using DFS)*: run DFS from some vertex s and consider the first vertex
    in DFS that finishes.'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示 1（使用 DFS）*：从某个顶点 s 运行 DFS，并考虑 DFS 中完成的第一个顶点。'
- en: '*Hint 2 (using BFS)*: run BFS from some vertex s and consider any vertex with
    the highest distance.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*提示 2（使用 BFS）*：从某个顶点 s 运行 BFS，并考虑具有最大距离的任何顶点。'
- en: '**Spanning tree.** Design an algorithm that computes a spanning tree of a connected
    graph is time proportional to V + E. *Hint*: use either BFS or DFS.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成树。** 设计一个算法，以时间复杂度为 V + E 计算一个连通图的生成树。*提示*：使用 BFS 或 DFS。'
- en: '**All paths in a graph.** Write a program [AllPaths.java](AllPaths.java.html)
    that enumerates all simple paths in a graph between two specified vertices. *Hint*:
    use DFS and backtracking. *Warning*: there many be exponentially many simple paths
    in a graph, so no algorithm can run efficiently for large graphs.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图中的所有路径。** 编写一个程序 [AllPaths.java](AllPaths.java.html)，枚举图中两个指定顶点之间的所有简单路径。*提示*：使用
    DFS 和回溯。*警告*：图中可能存在指数多个简单路径，因此对于大型图，没有算法可以高效运行。'
