- en: 4.2 Sorting and Searching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 排序和搜索
- en: 原文：[https://introcs.cs.princeton.edu/python/42sort](https://introcs.cs.princeton.edu/python/42sort)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/42sort](https://introcs.cs.princeton.edu/python/42sort)
- en: <title>Sorting and Searching</title>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <title>排序和搜索</title>
- en: The sorting problem is to rearrange a set of items in ascending order. One reason
    that it is so useful is that it is much easier to search for something in a sorted
    list than an unsorted one. In this section, we will consider in detail two classical
    algorithms for sorting and searching, along with several applications where their
    efficiency plays a critical role.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 排序问题是将一组项目按升序重新排列。它如此有用的一个原因是在排序列表中搜索比在未排序列表中搜索要容易得多。在本节中，我们将详细讨论两种经典的排序和搜索算法，以及它们的效率在几个关键应用中发挥作用的情况。
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Binary Search
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分查找
- en: '![Finding a hidden number with binary search](../Images/051d8fd4810800a787a8d7165fedf39c.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![使用二分查找找到隐藏数字](../Images/051d8fd4810800a787a8d7165fedf39c.png)'
- en: In the game of "twenty questions", your task is to guess the value of a hidden
    number that is one of the *n* integers between 0 and *n*-1\. (For simplicity,
    we will assume that *n* is a power of two.) Each time that you make a guess, you
    are told whether your guess is too high or too low. An effective strategy is to
    maintain an interval [*lo*, *hi*) that contains the hidden number, guess the number
    in the middle of the interval, and then use the answer to halve the interval size.
    The program [questions.py](questions.py.html) implements this strategy, which
    is an example of the general problem-solving method known as *binary search*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在“二十个问题”游戏中，你的任务是猜测一个隐藏数字的值，该数字是0到*n*-1之间的*n*个整数之一。（为简单起见，我们假设*n*是2的幂。）每次猜测时，你会被告知你的猜测是太高还是太低。一种有效的策略是维护一个包含隐藏数字的区间[*lo*,
    *hi*)，猜测区间中间的数字，然后利用答案将区间大小减半。程序[questions.py](questions.py.html)实现了这种策略，这是已知的一般问题解决方法*二分查找*的一个示例。
- en: Correctness proof.
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确性证明。
- en: 'First, we have to convince ourselves that the approach is correct: that it
    always leads us to the hidden number. We do so by establishing the following facts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须确信这种方法是正确的：它总是引导我们找到隐藏数字。我们通过建立以下事实来做到这一点：
- en: The interval always contains the hidden number.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区间始终包含隐藏数字。
- en: The interval sizes are the powers of two, decreasing from *n*.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区间大小是2的幂，从*n*减小。
- en: The first of these facts is enforced by the code; the second follows by noting
    that if the interval size (*hi*-*lo*) is a power of two, then the next interval
    size is (*hi*-*lo*)/2, which is the next smaller power of two. These facts are
    the basis of an induction proof that the method operates as intended. Eventually,
    the interval size becomes 1, so we are guaranteed to find the number.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事实是归纳证明方法运行如预期的基础。最终，区间大小变为1，因此我们保证找到数字。
- en: Running time analysis.
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时间分析。
- en: Since the size of the interval decreases by a factor of 2 at each iteration
    (and the base case is reached when *n* = 1), the running time of binary search
    is lg *n*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次迭代间隔大小减少2倍（当*n*=1时达到基本情况），二分查找的运行时间为lg*n*。
- en: Linear-logarithm chasm.
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性对数鸿沟。
- en: 'The alternative to using binary search is to guess 0, then 1, then 2, then
    3, and so forth, until hitting the hidden number. We refer to such an algorithm
    as a *brute-force* algorithm: it seems to get the job done, but without much regard
    to the cost (which might prevent it from actually getting the job done for large
    problems). In this case, the running time of the brute-force algorithm is sensitive
    to the input value, but could be as much as *n* and has expected value *n*/2 if
    the input value is chosen at random. Meanwhile, binary search is guaranteed to
    use no more than lg *n* steps.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二分查找的替代方法是猜测0，然后1，然后2，然后3，依此类推，直到找到隐藏数字。我们将这样的算法称为*蛮力*算法：它似乎可以完成任务，但并不太关心成本（这可能会阻止它实际完成大问题的任务）。在这种情况下，蛮力算法的运行时间对输入值敏感，但如果输入值是随机选择的，则可能达到*n*，并且期望值为*n*/2。与此同时，二分查找保证不会超过lg*n*步。
- en: Binary representation.
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制表示。
- en: If you look back to [binary.py](../13flow/binary.py.html), you will recognize
    that binary search is nearly the same computation as converting a number to binary!
    Each guess determines one bit of the answer. In our example, the information that
    the number is between 0 and 127 says that the number of bits in its binary representation
    is 7, the answer to the first question (is the number greater than or equal to
    64?) tells us the value of the leading bit, the answer to the second question
    tells us the value of the next bit, and so forth. For example, if the number is
    77, the sequence of answers true false, false, true, true, false, true immediately
    yields 1001101, the binary representation of 77\.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下[binary.py](../13flow/binary.py.html)，你会发现二分查找几乎与将数字转换为二进制的计算相同！每次猜测确定答案的一个位。在我们的例子中，数字在0到127之间的信息表明其二进制表示中的位数为7，第一个问题的答案（数字是否大于或等于64？）告诉我们领先位的值，第二个问题的答案告诉我们下一个位的值，依此类推。例如，如果数字是77，答案序列true
    false, false, true, true, false, true立即得到77的二进制表示1001101。
- en: Inverting a function.
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反转函数。
- en: 'As an example of the utility of binary search in scientific computing, we revisit
    a problem that we first encountered in the exercises in Section 2.1: inverting
    an increasing function. Given an increasing function *f* and a value *y*, and
    an open interval [*lo*, *hi*), our task is to find a value *x* within the interval
    such that *f*(*x*) = *y*. In this situation, we use real numbers as the endpoints
    of our interval, not integers, but we use the same essential approach that we
    used for guessing a hidden integer with the "twenty questions" problem: we halve
    the length of the interval at each step, keeping *x* in the interval, until the
    interval is sufficiently small that we know the value of *x* to within a desired
    precision), which we take as an argument to the function. This figure illustrates
    the first step.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为科学计算中二分查找实用性的一个例子，我们重新讨论了在第2.1节练习中首次遇到的问题：反转一个递增函数。给定一个递增函数*f*和一个值*y*，以及一个开区间[*lo*,
    *hi*)，我们的任务是找到区间内的一个值*x*，使得*f*(*x*) = *y*。在这种情况下，我们使用实数作为区间的端点，而不是整数，但我们使用了与猜测“二十个问题”问题中相同的基本方法：在每一步中将区间长度减半，保持*x*在区间内，直到区间足够小，我们可以在所需精度内确定*x*的值，这个精度作为函数的参数。这个图示了第一步。
- en: '![Binary search to invert an increasing function](../Images/4883ba34b8fa360b57f12f67ffc22abf.png)'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![二分查找反转递增函数](../Images/4883ba34b8fa360b57f12f67ffc22abf.png)'
- en: 'The program [bisection.py](bisection.py.html) implements this strategy. We
    start with an interval (*lo*, *hi*) known to contain *x* and use the following
    recursive procedure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[bisection.py](bisection.py.html)实现了这个策略。我们从一个已知包含*x*的区间(*lo*, *hi*)开始，并使用以下递归过程：
- en: Compute *mid* = (*hi* + *lo*) / 2.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算*mid* = (*hi* + *lo*) / 2。
- en: '*Base case:* If *hi* - *lo* is less than δ, then return *mid* as an estimate
    of *x*.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本情况：*如果*hi* - *lo*小于δ，则将*mid*作为*x*的估计返回。'
- en: '*Recursive step*: Otherwise, test whether *f*(*mid*) > *y*. If so, look for
    *x* in (*lo*, *mid*); if not, look for *x* in (*mid*, *hi*).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*递归步骤：*否则，测试*f*(*mid*) > *y*。如果是，查找(*lo*, *mid*)中的*x*；如果不是，查找(*mid*, *hi*)中的*x*。'
- en: The key to this approach is the idea that the function is increasing — for any
    values *a* and *b*, knowing that *f*(*a*) < *f*(*b*) tells us that *a* < *b*,
    and vice versa. In this context, binary search is often called *bisection search*
    because we bisect the interval at each stage.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的关键在于函数是递增的——对于任意值*a*和*b*，知道*f*(*a*) < *f*(*b*)告诉我们*a* < *b*，反之亦然。在这种情况下，二分查找通常被称为*二分查找*，因为我们在每个阶段将区间二等分。
- en: Binary search in a sorted array.
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在有序数组中进行二分查找。
- en: 'During much of the last century people would use a publication known as a *dictionary*
    to look up the definition of a word. Entries appears in order, sorted by a key
    that identifies it (the word). Think about how you would look up a word in a dictionary.
    A brute-force solution would be to start at the beginning, examine each entry
    one at a time, and continue until you find the word. No one uses that approach:
    instead, you open the dictionary to some interior page and look for the word on
    that page. If it is there, you are done; otherwise, you eliminate either the part
    of the dictionary before the current page or the part of the dictionary after
    the current page from consideration and repeat.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上个世纪的大部分时间里，人们会使用一种称为*字典*的出版物来查找单词的定义。条目按照一个标识它的键（单词）排序，以顺序出现。想想你会如何在字典中查找一个单词。一种蛮力的解决方案是从头开始，逐个检查每个条目，直到找到单词。没有人会使用这种方法：相反，你会打开字典的某个内部页面，然后在该页面上查找单词。如果找到了，你就完成了；否则，你要么排除当前页面之前的部分，要么排除当前页面之后的部分，并重复这个过程。
- en: Exception filter.
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常过滤器。
- en: 'We now use binary search to solve the *existence problem*: is a given key in
    a sorted database of keys? For example, when checking the spelling of a word,
    you need only know whether your word is in the dictionary and are not interested
    in the definition. In a computer search, we keep the information in an array,
    sorted in order of the key. The binary search code in [binarysearch.py](binarysearch.py.html)
    differs from our other applications in two details. First, the array length *n*
    need not be a power of two. Second, it has to allow the possibility that the item
    sought is not in the array. The client program implements an *exception filter*:
    it reads a sorted list of strings from a file which we refer to as the *whitelist*
    (for example, [white.txt](white.txt)) and an arbitrary sequence of strings from
    standard input (for example, [emails.txt](emails.txt)) and writes those in the
    sequence that are *not* in the whitelist.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用二分查找来解决*存在问题*：给定键是否在已排序键的数据库中？例如，在检查单词拼写时，你只需要知道你的单词是否在字典中，而不关心定义。在计算机搜索中，我们将信息保存在一个数组中，按照键的顺序排序。[binarysearch.py](binarysearch.py.html)中的二分查找代码在两个细节上与我们的其他应用不同。首先，数组长度*n*不必是2的幂。其次，它必须允许所寻找的项不在数组中的可能性。客户程序实现了一个*异常过滤器*：它从文件中读取一个按照键排序的字符串列表，我们称之为*白名单*（例如，[white.txt](white.txt)），以及从标准输入读取一系列任意字符串（例如，[emails.txt](emails.txt)），并将那些不在白名单中的字符串按顺序写入。
- en: '* * *'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Insertion Sort
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入排序
- en: Binary search requires that the array be sorted, and sorting has many other
    direct applications, so we now turn to sorting algorithms. We consider first a
    brute-force algorithm, then a sophisticated algorithm that we can use for huge
    arrays.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找要求数组已排序，并且排序有许多其他直接应用，因此我们现在转向排序算法。我们首先考虑一个蛮力算法，然后考虑一个可以用于大型数组的复杂算法。
- en: The brute-force algorithm we consider is known as *insertion sort*. It is based
    on a simple approach that people often use to arrange hands of playing cards —
    that is, consider the cards one at a time and insert each into its proper place
    among those already considered (keeping them sorted).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的蛮力算法称为*插入排序*。它基于人们经常用来整理扑克牌的简单方法——也就是，逐个考虑卡片并将每张卡片插入到已考虑的卡片中的适当位置（保持它们排序）。
- en: The program [insertion.py](insertion.py.html) contains an implementation of
    a `sort()` function that mimics this process to sort elements in an array `a[]`
    of length `n`. The test client reads all the strings from standard input, puts
    them into the array, calls the `sort()` function to sort them, and then writes
    the sorted result to standard output. Try running it to sort the small [tiny.txt](tiny.txt)
    file. Also try running it to sort the much larger [tomsawyer.txt](tomsawyer.txt)
    file, but be prepared to wait a long time!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[insertion.py](insertion.py.html)包含一个`sort()`函数的实现，模拟这个过程来对长度为`n`的数组`a[]`中的元素进行排序。测试客户端从标准输入读取所有字符串，将它们放入数组中，调用`sort()`函数对它们进行排序，然后将排序后的结果写入标准输出。尝试运行它来对小型[tiny.txt](tiny.txt)文件进行排序。还尝试运行它来对更大的[tomsawyer.txt](tomsawyer.txt)文件进行排序，但要准备等待很长时间！
- en: The outer loop sorts the first `i` entries in the array; the inner loop can
    complete the sort by putting `a[i]` into its proper position in the array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 外部循环对数组中的前`i`个条目进行排序；内部循环可以通过将`a[i]`放入数组中的正确位置来完成排序。
- en: '![Insertion sort trace](../Images/ac2c281b9296338c09d1197549222d6a.png)'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![插入排序跟踪](../Images/ac2c281b9296338c09d1197549222d6a.png)'
- en: Mathematical analysis.
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学分析。
- en: The `sort()` function contains a `while` loop nested inside a `for` loop, which
    suggests that the running time is quadratic. However, we cannot immediately draw
    this conclusion because the `while` loop terminates as soon as `a[j]` is greater
    than or equal to `a[j-1]`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`函数包含一个嵌套在`for`循环中的`while`循环，这表明运行时间是二次的。然而，我们不能立即得出这个结论，因为`while`循环在`a[j]`大于或等于`a[j-1]`时终止。'
- en: '*Best case.* When the input array is already in sorted order, the inner loop
    amounts to nothing more than a comparison (to learn that `a[j-1]` is less than
    or equal to `a[j]`), so the total running time is linear.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳情况.* 当输入数组已经按顺序排序时，内部循环仅仅是一个比较（学习`a[j-1]`小于或等于`a[j]`），因此总运行时间是线性的。'
- en: '*Worst case.* When the input is reverse sorted, the inner loop does not terminate
    until *j* equals 0\. So, the frequency of execution of the instructions in the
    inner loop is 1 + 2 + ... + *n*-1 ~ *n*²/2.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最坏情况.* 当输入是逆序排序时，内部循环直到*j*等于0才终止。因此，内部循环中指令的执行频率为1 + 2 + ... + *n*-1 ~ *n*²/2。'
- en: '*Average case.* When the input is *randomly* ordered, we expect that each new
    element to be inserted is equally likely to fall into any position, so that element
    will move halfway to the left on average. Thus, we expect the running time to
    be 1/2 + 2/2 + ... + (*n*-1)/2 ~ *n*²/2.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平均情况.* 当输入是*随机*排序时，我们期望每个要插入的新元素等可能地落入任何位置，因此该元素平均向左移动一半。因此，我们期望运行时间为1/2 +
    2/2 + ... + (*n*-1)/2 ~ *n*²/2。'
- en: Empirical analysis.
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实证分析。
- en: 'Program [timesort.py](timesort.py.html) implements a doubling test for sorting
    functions. We can use it to confirm our hypothesis that insertion sort is quadratic
    for randomly ordered files:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[timesort.py](timesort.py.html)实现了对排序函数的倍增测试。我们可以使用它来确认我们的假设，即插入排序对随机排序的文件是二次的：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Sensitivity to input.
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对输入的敏感性。
- en: Note that the `doublingTest()` function in [timesort.py](timesort.py.html) takes
    parameter `m` and runs `m` experiments for each array size, not just one. One
    reason for doing so is that the running time of insertion sort is sensitive to
    its input values. It is not correct to flatly predict that the running time of
    insertion sort will be quadratic, because your application might involve input
    for which the running time is linear.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[timesort.py](timesort.py.html)中的`doublingTest()`函数接受参数`m`并为每个数组大小运行`m`个实验，而不仅仅是一个。这样做的一个原因是插入排序的运行时间对其输入值很敏感。直接预测插入排序的运行时间将是二次的是不正确的，因为您的应用可能涉及其运行时间为线性的输入。
- en: Comparable keys.
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可比较的键。
- en: We want to be able to sort any type of data that has a natural order. Happily,
    our insertion sort and binary search functions work not only with strings but
    also with any data type that is comparable. You can make a user-defined type comparable
    by implementing the six special methods corresponding to the `==`, `!=`, `<`,
    `<=`, `>`, and `>=` operators. In fact, our insertion sort and binary search functions
    rely on only the `<` operator, but it is better style to implement all six special
    methods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够对具有自然顺序的任何类型的数据进行排序。令人高兴的是，我们的插入排序和二分查找函数不仅适用于字符串，还适用于任何可比较的数据类型。您可以通过实现对应于`==`、`!=`、`<`、`<=`、`>`和`>=`运算符的六个特殊方法来使用户定义的类型可比较。实际上，我们的插入排序和二分查找函数仅依赖于`<`运算符，但最好实现所有六个特殊方法。
- en: '* * *'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Mergesort
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归并排序
- en: '![Mergesort overview](../Images/718429a1775f5209b487bb4041bf476e.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![归并排序概述](../Images/718429a1775f5209b487bb4041bf476e.png)'
- en: 'To develop a faster sorting algorithm, we use a *divide-and-conquer* approach
    to algorithm design that every programmer needs to understand. This nomenclature
    refers to the idea that one way to solve a problem is to *divide* it into independent
    parts, *conquer* them independently, and then use the solutions for the parts
    to develop a solution for the full problem. To sort an array with this strategy,
    we divide it into two halves, sort the two halves independently, and then merge
    the results to sort the full array. This method is known as *mergesort*.To sort
    a[lo, hi), we use the following recursive strategy:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发一个更快的排序算法，我们使用了*分而治之*的算法设计方法，每个程序员都需要理解这个术语。这个术语指的是解决问题的一种方法是*将*问题分解为独立的部分，独立*解决*它们，然后使用这些部分的解决方案来开发完整问题的解决方案。为了使用这种策略对数组进行排序，我们将其分成两半，独立对两半进行排序，然后合并结果以对整个数组进行排序。这种方法被称为*归并排序*。对于排序a[lo,
    hi)，我们使用以下递归策略：
- en: '*Base case*: If the subarray size is 0 or 1, it is already sorted.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本情况*: 如果子数组大小为0或1，则已经排序。'
- en: '*Recursive step*: Otherwise, compute *mid* = (*hi* + *lo*)/2, sort (recursively)
    the two subarrays *a*[*lo*, *mid*) and *a*[*mid*, *hi*), and merge them.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*递归步骤*: 否则，计算*mid* = (*hi* + *lo*)/2，对两个子数组*a*[*lo*, *mid*)和*a*[*mid*, *hi*)进行排序（递归），然后合并它们。'
- en: The program [merge.py](merge.py.html) is an implementation. As with [insert.py](insert.py.html),
    the test client reads all the strings from standard input, puts them into the
    array, calls the `sort()` function to sort them, and then writes the sorted result
    to standard output. Try running it to sort the small [tiny.txt](tiny.txt) file
    and the much larger [tomsawyer.txt](tomsawyer.txt) file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[merge.py](merge.py.html)是一个实现。与[insert.py](insert.py.html)一样，测试客户端从标准输入中读取所有字符串，将它们放入数组中，调用`sort()`函数对它们进行排序，然后将排序后的结果写入标准输出。尝试运行它来对小的[tiny.txt](tiny.txt)文件和更大的[tomsawyer.txt](tomsawyer.txt)文件进行排序。
- en: As usual, the easiest way to understand the merge process is to study a trace
    of the contents of the array during the merge.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，理解合并过程的最简单方法是研究合并过程中数组内容的跟踪。
- en: '![Trace of merging in mergesort](../Images/b170b94afcc10f67bb92b8209f91e26e.png)'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![归并排序中合并的跟踪](../Images/b170b94afcc10f67bb92b8209f91e26e.png)'
- en: Mathematical analysis.
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学分析。
- en: '![Mergesort analysis](../Images/6016900de468241f998a9f37a8e9e7ef.png) The inner
    loop of mergesort is centered on the auxiliary array. The `for` loop involves
    *n* iterations, so the frequency of execution of the instructions in the inner
    loop is proportional to the sum of the subarray lengths over all calls to the
    recursive function. The value of this quantity emerges when we arrange the calls
    on levels according to their size. For simplicity, suppose that *n* is a power
    of 2, with *n* = 2^(*k*). On the first level, we have one call for size *n*; on
    the second level, we have two calls for size *n*/2; on the third level, we have
    four calls for size *n*/4; and so forth, down to the last level with *n*/2 calls
    of size 2\. There are precisely *k* = lg *n* levels, giving the grand total *n*
    lg *n* for the frequency of execution of the instructions in the inner loop of
    mergesort. This equation justifies a hypothesis that the running time of mergesort
    is linearithmic.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![归并排序分析](../Images/6016900de468241f998a9f37a8e9e7ef.png) 归并排序的内部循环集中在辅助数组上。`for`循环涉及*n*次迭代，因此内部循环中指令的执行频率与递归函数的所有调用中子数组长度的总和成比例。当我们根据大小将调用排列在不同级别时，这个数量的值就出现了。为简单起见，假设*n*是2的幂，即*n*
    = 2^(*k*)。在第一级别上，我们有一个大小为*n*的调用；在第二级别上，我们有两个大小为*n*/2的调用；在第三级别上，我们有四个大小为*n*/4的调用；依此类推，直到最后一个大小为2的*n*/2调用的级别。总共有*k*
    = lg *n*个级别，使得归并排序内部循环中指令的执行频率总共为*n* lg *n*。这个方程证明了归并排序的运行时间是线性对数的假设。'
- en: When *n* is not a power of 2, the subarrays on each level are not necessarily
    all the same size, but the number of levels is still logarithmic, so the linearithmic
    hypothesis is justified for all *n*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当*n*不是2的幂时，每个级别上的子数组不一定都是相同大小，但级别的数量仍然是对数的，因此对于所有*n*，线性对数的假设都是合理的。
- en: Empirical analysis.
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实证分析。
- en: 'We can run program [timesort.py](timesort.py.html) to perform a doubling test
    to confirm our hypothesis that mergesort has running time *n* lg *n* for randomly
    ordered files:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行程序[timesort.py](timesort.py.html)进行一个加倍测试，以确认我们的假设，即归并排序对于随机排序的文件具有*n*
    lg *n*的运行时间：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Quadratic-linearithmic chasm.
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二次线性对数的鸿沟。
- en: The difference between *n*² and *n* lg *n* makes a huge difference in practical
    applications. Understanding the enormousness of this difference is another critical
    step to understanding the importance of the design and analysis of algorithms.
    For a great many important computational problems, a speedup from quadratic to
    linearithmic makes the difference between being able to solve a problem involving
    a huge amount of data and not being able to effectively address it at all.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*²和*n* lg *n*之间的差异在实际应用中有很大差别。理解这种巨大差异是理解算法设计和分析的重要性的另一个关键步骤。对于许多重要的计算问题，从二次到线性对数的加速使得能否解决涉及大量数据的问题成为可能，而不是根本无法有效解决。'
- en: '* * *'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Python System Sort
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python系统排序
- en: Python includes two operations for sorting. The method `sort()` in the built-in
    `list` data type rearranges the items in the underlying list into ascending order,
    much like `merge.sort()`. In contrast, the built-in function `sorted()` leaves
    the underlying list alone; instead, it returns a new list containing the items
    in ascending order. This interactive Python script at right illustrates both techniques.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python包括两种排序操作。内置`list`数据类型中的`sort()`方法将底层列表中的项目重新排列为升序，类似于`merge.sort()`。相比之下，内置函数`sorted()`不会改变底层列表；相反，它返回一个包含���升序排列的项目的新列表。右侧的这个交互式Python脚本演示了这两种技术。
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Python system sort uses a version of mergesort. It is likely to be substantially
    faster (10-20×) than [merge.py](merge.py.html) because it uses a low-level implementation
    that is not composed in Python, thereby avoiding the substantial overhead that
    Python imposes on itself. As with our sorting implementations, you can use the
    system sort with any comparable data type, such as Python's built-in `str`, `int`,
    and `float` data types.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python系统排序使用归并排序的一个版本。它可能比[merge.py](merge.py.html)快得多（10-20×），因为它使用了一个低级别的实现，而不是由Python组成的，从而避免了Python对自身施加的重大开销。与我们的排序实现一样，您可以使用系统排序与任何可比较的数据类型，例如Python的内置`str`、`int`和`float`数据类型。
- en: '* * *'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Application: Frequency Counts'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用：频率计数
- en: The program [frequencycount.py](frequencycount.py.html) reads a sequence of
    strings from standard input and then writes a table of the distinct values found
    and the number of times each was found, in decreasing order of the frequencies.
    We accomplish this by two sorts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[frequencycount.py](frequencycount.py.html)从标准输入读取一系列字符串，然后按照频率降序写入找到的不同值和每个值找到的次数的表格。我们通过两次排序来实现这一点。
- en: Computing the frequencies.
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算频率。
- en: Our first step is to sort the strings on standard input. In this case, we are
    not so much interested in the fact that the strings are put into sorted order,
    but in the fact that sorting brings equal strings together. If the input is
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是对标准输入中的字符串进行排序。在这种情况下，我们更感兴趣的不是字符串被排序，而是排序将相同的字符串放在一起。如果输入是
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: then the result of the sort is
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么排序的结果是
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: with equal strings like the three occurrences of `to` brought together in the
    array. Now, with equal strings all together in the array, we can make a single
    pass through the array to compute all the frequencies. The `Counter` class, as
    defined in [counter.py](../33design/counter.py.html) from Section 3.3, is the
    perfect tool for the job.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的字符串（如数组中的三个`to`出现）放在一起。现在，将所有相同的字符串放在数组中，我们可以通过数组进行单次遍历来计算所有频率。在第3.3节中定义的`Counter`类，是这项工作的完美工具。
- en: Sorting the frequencies.
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对频率进行排序。
- en: Next, we sort the `Counter` objects by frequency. We can do so in client code
    by augmenting the `Counter` data type to include the six comparison methods for
    comparing `Counter` objects by their count. Thus, we simply sort the array of
    `Counter` objects to rearrange them in ascending order of frequency! Next, we
    reverse the array so that the elements are in descending order of frequency. Finally,
    we write each `Counter` object to standard output.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按频率对`Counter`对象进行排序。我们可以通过在`Counter`数据类型中增加六个比较方法来在客户端代码中这样做，以比较`Counter`对象的计数。因此，我们只需对`Counter`对象数组进行排序，以按频率升序重新排列它们！接着，我们反转数组，使元素按频率降序排列。最后，我们将每个`Counter`对象写入标准输出。
- en: Zipf's law.
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 齐普夫定律。
- en: 'The application highlighted in [frequencycount.py](frequencycount.py.html)
    is elementary linguistic analysis: which words appear most frequently in a text?
    A phenomenon known as [Zipf''s law](http://en.wikipedia.org/wiki/Zipf''s_law)
    says that the frequency of the *i*th most frequent word in a text of *m* distinct
    words is proportional to 1/*i*. Try running [frequencycount.py](frequencycount.py.html)
    on the large [leipzig100k.txt](leipzig100k.txt), [leipzig200k.txt](leipzig200k.txt),
    and [leipzig1m.txt](leipzig1m.txt) files to observe that phenomenon.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[frequencycount.py](frequencycount.py.html)中突出显示的应用是基本的语言分析：文本中哪些单词出现频率最高？一种被称为[齐普夫定律](http://en.wikipedia.org/wiki/Zipf''s_law)的现象表明，文本中第*i*个最常见单词的频率与1/*i*成比例。尝试在大型文件[leipzig100k.txt](leipzig100k.txt)、[leipzig200k.txt](leipzig200k.txt)和[leipzig1m.txt](leipzig1m.txt)上运行[frequencycount.py](frequencycount.py.html)，观察这种现象。'
- en: '* * *'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问与答
- en: '**Q.** Why do we need to go to such lengths to prove a program correct?'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么我们需要如此费力地证明程序的正确性？'
- en: '**A.** To spare ourselves considerable pain. Binary search is a notable example.
    For example, you now understand binary search; a classic programming exercise
    is to compose a version that uses a `while` loop instead of recursion. Try solving
    the first three exercises in this section without looking back at the code in
    the book. In a famous experiment, Jon Bentley once asked several professional
    programmers to do so, and most of their solutions were not correct.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 为了避免自己遭受相当大的痛苦。二分查找是一个显著的例子。例如，现在你理解了二分查找；一个经典的编程练习是编写一个使用`while`循环而不是递归的版本。尝试在不回头查看书中代码的情况下解决本节的前三个练习。在一次著名的实验中，乔恩·本特利曾要求几位专业程序员这样做，他们大多数的解决方案都是不正确的。'
- en: '**Q.** Why introduce the mergesort algorithm when Python provides an efficient
    `sort()` method defined in the `list` data type?'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** Python提供了一个在`list`数据类型中定义的高效`sort()`方法，为什么要介绍归并排序算法？'
- en: '**A.** As with many topics we have studied, you will be able to use such tools
    more effectively if you understand the background behind them.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 和我们学习过的许多主题一样，如果你了解它们背后的背景，就能更有效地使用这些工具。'
- en: '**Q.** What is the running time of the following version of insertion sort
    on an array that is already sorted?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 在已经排序的数组上运行以下版本的插入排序的运行时间是多少？'
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**A.** Quadratic time in Python 2; linear time in Python 3\. The reason is
    that, in Python 2, `range()` is a function that returns an array of integers of
    length equal to the length of the range (which can be wasteful if the loop terminates
    early because of a `break` or `return` statement). In Python 3, `range()` returns
    an iterator, which generates only as many integers as needed.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 在 Python 2 中为二次时间；在 Python 3 中为线性时间。原因是，在 Python 2 中，`range()`是一个返回整数数组的函数，其长度等于范围的长度（如果循环因`break`或`return`语句而提前终止，可能会浪费）。在
    Python 3 中，`range()`返回一个迭代器，只生成所需的整数。'
- en: '**Q.** What happens if I try to sort an array of elements that are not all
    of the same type?'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 如果我尝试对不全是相同类型的元素数组进行排序会发生什么？'
- en: '**A.** If the elements are of compatible types (such as `int` and `float`),
    everything works fine. For example, mixed numeric types are compared according
    to their numeric value, so 0 and 0.0 are treated as equal. If the elements are
    of incompatible types (such as `str` and `int`), then Python 3 raises a `TypeError`
    at run time. Python 2 supports some mixed-type comparisons, using the name of
    the class to determine which object is smaller. For example, Python 2 treats all
    integers as less than all strings because `''int''` is lexicographically less
    than `''str''`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 如果元素是兼容类型（如`int`和`float`），一切都能正常工作。例如，混合数值类型根据其数值进行比较，因此0和0.0被视为相等。如果元素是不兼容类型（如`str`和`int`），那么
    Python 3 在运行时会引发`TypeError`。Python 2 支持一些混合类型比较，使用类名确定哪个对象较小。例如，Python 2 将所有整数视为小于所有字符串，因为`''int''`在字典顺序上小于`''str''`。'
- en: '**Q.** Which order is used when comparing strings with operators such as `==`
    and `<`?'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 在使用诸如`==`和`<`等运算符比较字符串时使用哪种顺序？'
- en: '**A.** Informally, Python uses *lexicographic order* to compare two strings,
    as words in a book index or dictionary. For example `''hello''` and `''hello''`
    are equal, `''hello''` and `''goodbye''` are unequal, and `''goodbye''` is less
    than `''hello''`. More formally, Python first compares the first character of
    each string. If those characters differ, then the strings as a whole compare as
    those two characters compare. Otherwise, Python compares the second character
    of each string. If those characters differ, then the strings as a whole compare
    as those two characters compare. Continuing in this manner, if Python reaches
    the ends of the two strings simultaneously, then it considers them to be equal.
    Otherwise, it considers the shorter string to be the smaller one. Python uses
    Unicode for character-by-character comparisons. We list a few of the most important
    properties:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '`''0''` is less than `''1''`, and so forth.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''A''` is less than `''B''`, and so forth.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''a''` is less than `''b''`, and so forth.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal digits (`'0'` to `'9'`) are less than the uppercase letters (`'A'` to
    `'Z'`).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uppercase letters (`'A'` to `'Z'`) are less than lowercase letters (`'a'` to
    `'z'`).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Develop an implementation of [questions.py](questions.py.html) that takes the
    maximum number `n` as command-line argument (it need not be a power of 2). Prove
    that your implementation is correct.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a nonrecursive version of [binarysearch.py](binarysearch.py.html).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify [binarysearch.py](binarysearch.py.html) so that if the search key is
    in the array, it returns the smallest index `i` for which `a[i]` is equal to `key`,
    and otherwise it returns the largest index `i` for which `a[i]` is smaller than
    `key` (or `-1` if no such index exists).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe what happens if you apply binary search to an unordered array. Why
    shouldn't you check whether the array is sorted before each call to binary search?
    Could you check that the elements binary search examines are in ascending order?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe why it is desirable to use immutable keys with binary search.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let *f*() be a monotonically increasing function with *f*(*a*) < 0 and *f*(*b*)
    > 0\. Compose a program that computes a value *x* such that *f*(*x*) = 0 (up to
    a given error tolerance).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to [insertion.py](insertion.py.html) to produce the trace given above.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to [merge.py](merge.py.html) to produce the trace given above.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give traces of insertion sort and mergesort in the style of the traces shown
    above, for the input `it was the best of times it was`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a program `dedup.py` that reads strings from standard input and writes
    them to standard output with all duplicates removed (and in sorted order).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a version of mergesort, as defined in [merge.py](merge.py.html), that
    creates an auxiliary array in each recursive call to `_merge()` instead of creating
    only one auxiliary array in `sort()` and passing it as an argument. What impact
    does this change have on performance?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose a nonrecursive version of mergesort, as defined in [merge.py](merge.py.html).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the frequency distribution of words in your favorite book. Does it obey
    Zipf's law?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Creative Exercises
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*The following exercises are intended to give you experience in developing
    fast solutions to typical problems. Think about using binary search, mergesort,
    or devising your own divide-and-conquer algorithm. Implement and test your algorithm.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Median**. Study the function `median()` in `stdstats.py`. It computes the
    median of a given array of numbers in linearithmic time. Note that it works by
    reducing the problem to sorting.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mode**. Add to `stdstats.py` a function `mode()` that computes in linearithmic
    time the mode (value that occurs most frequently) of a sequence of *n* integers.
    *Hint*: Reduce to sorting.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integer sort**. Compose a linear-time filter reads from standard input a
    sequence of integers that are between 0 and 99 and writes the integers in sorted
    order on standard output. For example, presented with the input sequence'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: your program should write the output sequence
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的程序应该输出序列
- en: '[PRE7]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Floor and ceiling**. Given a sorted array of n comparable keys, compose functions
    `floor()` and `ceiling()` that returns the index of the largest (or smallest)
    key not larger (or smaller) than an argument key in logarithmic time.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下界和上界**。给定一个已排序的n个可比较键的数组，编写`floor()`和`ceiling()`函数，以对数时间返回不大于（或不小于）参数键的最大（或最小）键的索引。'
- en: '**Bitonic maximum**. An array is bitonic if it consists of an increasing sequence
    of keys followed immediately by a decreasing sequence of keys. Given a bitonic
    array, design a logarithmic algorithm to find the index of a maximum key.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双峰最大值**。如果一个数组由一个递增序列的键紧接着一个递减序列的键组成，则该数组是双峰的。给定一个双峰数组，设计一个对数时间的算法来找到最大键的索引。'
- en: '**Search in a bitonic array**. Given a bitonic array of *n* distinct integers,
    design a logarithmic-time algorithm to determine whether a given integer is in
    the array.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在双峰数组中搜索**。给定一个包含*n*个不同整数的双峰数组，设计一个对数时间的算法来确定给定整数是否在数组中。'
- en: '**Closest pair**. Given an array of *n* floats, compose a function to find
    in linearithmic time the pair of floats that are closest in value.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最接近的一对**。给定一个*n*个浮点数的数组，编写一个函数，在线性对数时间内找到数值最接近的一对浮点数。'
- en: '**Furthest pair**. Given an array of *n* floats, compose a function to find
    in linear time the pair of integers that are farthest apart in value.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最远的一对**。给定一个*n*个浮点数的数组，编写一个函数，在线性时间内找到数值上最远的一对整数。'
- en: '**Two sum**. Compose a function that takes as argument an array of *n* integers
    and determines in linearithmic time whether any *two* of them sum to 0.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**两数之和**。编写一个函数，该函数以*n*个整数数组作为参数，并在线性对数时间内确定是否有*两个*数相加等于0。'
- en: '**Three sum**. Compose a function that takes as argument an array of *n* integers
    and determines whether any *three* of them sum to 0\. Your program should run
    in time proportional to *n*² log *n*. *Extra credit*: Develop a program that solves
    the problem in quadratic time.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**三数之和**。编写一个函数，以*n*个整数数组作为参数，并确定是否有*三个*数相加等于0。你的程序应该在时间上与*n*² log *n*成比例。*额外加分*：开发一个能在二次时间内解决问题的程序。'
- en: '**Majority**. Given an array of *n* elements, an element is a *majority* if
    it appears more than *n*/2 times. Compose a function that takes an array of *n*
    strings as an argument and identifies a majority (if it exists) in linear time.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多数派**。给定一个包含*n*个元素的数组，如果一个元素出现超过*n*/2次，则该元素是*多数派*。编写一个函数，将一个包含*n*个字符串的数组作为参数，并在线性时间内识别多数派（如果存在）。'
- en: '**Common element**. Compose a function that takes as argument three arrays
    of strings, determines whether there is any string common to all three arrays,
    and if so, returns one such string. The running time of your function should be
    linearithmic in the total number of strings.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**公共元素**。编写一个函数，该函数以三个字符串数组作为参数，确定是否有任何一个字符串在这三个数组中都存在，并如果有，则返回其中一个字符串。你的函数的运行时间应该与字符串的总数成线性对数关系。'
- en: '**Largest empty interval**. Given *n* timestamps for when a file is requested
    from web server, find the largest interval of time in which no file is requested.
    Compose a program to solve this problem in linearithmic time.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大空闲区间**。给定*n*个请求文件的时间戳，找到在没有请求文件的最长时间间隔。编写一个程序，在线性对数时间内解决这个问题。'
- en: '**Prefix-free codes**. In data compression, a set of strings is *prefix-free*
    if no string is a prefix of another. For example, the set of strings `01`, `10`,
    `0010`, and `1111` is prefix-free, but the set of strings `01`, `10`, `0010`,
    `1010` is not prefix-free because `10` is a prefix of `1010`. Compose a program
    that reads in a set of strings from standard input and determines whether the
    set is prefix-free.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**前缀自由编码**。在数据压缩中，如果一组字符串是*前缀自由*的，那么没有一个字符串是另一个字符串的前缀。例如，字符串集合`01`、`10`、`0010`和`1111`是前缀自由的，但字符串集合`01`、`10`、`0010`、`1010`不是前缀自由的，因为`10`是`1010`的前缀。编写一个程序，从标准输入中读取一组字符串，并确定该集合是否是前缀自由的。'
- en: '**Partitioning**. Compose a function that sorts an array that is known to have
    at most two different values. *Hint*: Maintain two pointers, one starting at the
    left end and moving right, the other starting at the right end and moving left.
    Maintain the invariant that all elements to the left of the left pointer are equal
    to the smaller of the two values and all elements to the right of the right pointer
    are equal to the larger of the two values.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分区**。编写一个函数，对已知最多有两个不同值的数组进行排序。*提示*：保持两个指针，一个从左端开始向右移动，另一个从右端开始向左移动。保持不变的是，左指针左侧的所有元素都等于两个值中较小的值，右指针右侧的所有元素都等于两个值中较大的值。'
- en: '**Dutch national flag**. Compose a function that sorts an array that is known
    to have at most three different values. (Edsgar Dijkstra named this the *Dutch-national-flag*
    problem because the result is three "stripes" of values like the three stripes
    in the flag.) *Hint*: Reduce to the previous problem, by first partitioning the
    array into two parts with all elements having the smallest value in the first
    part and all other elements in the second part, then partition the second part.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**荷兰国旗**。编写一个函数，对已知最多有三个不同值的数组进行排序。（Edsgar Dijkstra将这称为*荷兰国旗*问题，因为结果是三个值的“条纹”，就像国旗中的三条条纹一样。）*提示*：通过首先将数组分成两部分，第一部分中的所有元素具有最小值，第二部分中的所有其他元素，然后对第二部分进行分区，将问题简化为前一个问题。'
- en: '**Quicksort**. Compose a recursive program that sorts an array of randomly
    ordered distinct elements. *Hint*: Use a method like the one described in the
    previous exercise. First, partition the array into a left part with all elements
    less than *v*, followed by *v*, followed by a right part with all elements greater
    than *v*. Then, recursively sort the two parts. *Extra credit*: Modify your method
    (if necessary) to work properly when the elements are not necessarily distinct.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**快速排序**。编写一个递归程序，对一个随机排序的不同元素数组进行排序。*提示*：使用类似前一个练习中描述的方法。首先，将数组分成一个左部分，其中所有元素都小于*v*，然后是*v*，然后是一个右部分，其中所有元素都大于*v*。然后，递归地对这两部分进行排序。*额外加分*：修改你的方法（如果需要），使其在元素不一定不同的情况下也能正常工作。'
- en: '**Reverse domain**. Compose a program to read in a list of domain names from
    standard input and write the reverse domain names in sorted order. For example,
    the reverse domain of `cs.princeton.edu` is `edu.princeton.cs`. This computation
    is useful for web log analysis. To do so, create a data type `Domain` that implements
    the special comparison methods, using reverse domain name order.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反向域名**。编写一个程序，从标准输入中读取域名列表，并按排序顺序写出反向域名。例如，`cs.princeton.edu`的反向域名是`edu.princeton.cs`。这种计算对于网络日志分析很有用。为此，创建一个实现特殊比较方法的数据类型`Domain`，使用反向域名顺序。'
- en: '**Local minimum in an array**. Given an array of *n* floats, compose a function
    to find in logarithmic time a *local minimum* (an index `i` such that `a[i] <
    a[i-1]` and `a[i] < a[i+1]`).'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数组中的局部最小值**。给定一个包含*n*个浮点数的数组，编写一个函数以对数时间找到一个*局部最小值*（一个索引`i`，满足`a[i] < a[i-1]`且`a[i]
    < a[i+1]`）。'
- en: '**Discrete distribution**. Design a fast algorithm to repeatedly generate numbers
    from the discrete distribution. Given an array `p[]` of nonnegative floats that
    sum to 1, the goal is to return index `i` with probability `p[i]`. Form an array
    `s[]` of cumulated sums such that `s[i]` is the sum of the first `i` elements
    of `p[]`. Now, generate a random float `r` between 0 and 1, and use binary search
    to return the index `i` for which `s[i] ≤ r < s[i+1]`.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**离散分布**。设计一个快速算法，重复地从离散分布中生成数字。给定一个非负浮点数数组`p[]`，其总和为1，目标是以概率`p[i]`返回索引`i`。形成一个累积和数组`s[]`，使得`s[i]`是`p[]`的前`i`个元素的和。现在，生成一个介于0和1之间的随机浮点数`r`，并使用二分查找返回索引`i`，满足`s[i]
    ≤ r < s[i+1]`。'
- en: '**Rhyming words**. Tabulate a list that you can use to find words that rhyme.
    Use the following approach:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**押韵单词**。制表一个列表，您可以使用它来查找押韵的单词。使用以下方法：'
- en: Read in a dictionary of words into an array of strings.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单词字典读入字符串数组中。
- en: Reverse the letters in each word (`confound` becomes `dnuofnoc`, for example).
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转每个单词中的字母（例如，`confound`变为`dnuofnoc`）。
- en: Sort the resulting array.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对结果数组进行排序。
- en: Reverse the letters in each word back to their original order.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个单词中的字母恢复到原始顺序。
- en: For example, `confound` is adjacent to words such as `astound` and `surround`
    in the resulting list.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，`confound`在结果列表中与`astound`和`surround`等单词相邻。
