- en: Lecture 0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲座 0
- en: 原文：[https://cs50.harvard.edu/ai/notes/0/](https://cs50.harvard.edu/ai/notes/0/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/ai/notes/0/](https://cs50.harvard.edu/ai/notes/0/)
- en: Artificial Intelligence
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能
- en: Artificial Intelligence (AI) covers a range of techniques that appear as sentient
    behavior by the computer. For example, AI is used to recognize faces in photographs
    on your social media, beat the World’s Champion in chess, and process your speech
    when you speak to Siri or Alexa on your phone.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能（AI）涵盖了一系列技术，这些技术使计算机表现出有感知的行为。例如，AI 用于识别社交媒体上的照片中的面孔，击败世界象棋冠军，以及处理你用手机上的
    Siri 或 Alexa 说话时的语音。
- en: 'In this course, we will explore some of the ideas that make AI possible:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中，我们将探讨使人工智能成为可能的一些想法：
- en: '**Search**'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**搜索**'
- en: Finding a solution to a problem, like a navigator app that finds the best route
    from your origin to the destination, or like playing a game and figuring out the
    next move.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个问题的解决方案，比如一个导航应用找到从起点到目的地的最佳路线，或者像玩游戏并找出下一步棋。
- en: '**Knowledge**'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**知识**'
- en: Representing information and drawing inferences from it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从信息中提取信息并得出推论。
- en: '**Uncertainty**'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不确定性**'
- en: Dealing with uncertain events using probability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用概率处理不确定事件。
- en: '**Optimization**'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优化**'
- en: Finding not only a correct way to solve a problem, but a better—or the best—way
    to solve it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个正确解决问题的方法，但也是一个更好或最好的方法。
- en: '**Learning**'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**学习**'
- en: Improving performance based on access to data and experience. For example, your
    email is able to distinguish spam from non-spam mail based on past experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据访问和经验改进性能。例如，你的电子邮件能够根据以往的经验区分垃圾邮件和非垃圾邮件。
- en: '**Neural Networks**'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**神经网络**'
- en: A program structure inspired by the human brain that is able to perform tasks
    effectively.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一种受人类大脑启发的程序结构，能够有效地执行任务。
- en: '**Language**'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**语言**'
- en: Processing natural language, which is produced and understood by humans.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 处理自然语言，这是人类产生和理解的。
- en: Search
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: Search problems involve an agent that is given an initial state and a goal state,
    and it returns a solution of how to get from the former to the latter. A navigator
    app uses a typical search process, where the agent (the thinking part of the program)
    receives as input your current location and your desired destination, and, based
    on a search algorithm, returns a suggested path. However, there are many other
    forms of search problems, like puzzles or mazes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索问题涉及一个给定初始状态和目标状态的代理，并返回从前者到后者的解决方案。导航应用使用典型的搜索过程，其中代理（程序的思考部分）接收你的当前位置和你的目标位置作为输入，并根据搜索算法返回建议的路径。然而，还有许多其他形式的搜索问题，如谜题或迷宫。
- en: '![15 puzzle](../Images/e6423c8db31a8f1cb13be0699cbdb4a7.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![15 拼图](../Images/e6423c8db31a8f1cb13be0699cbdb4a7.png)'
- en: Finding a solution to a 15 puzzle would require the use of a search algorithm.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 15 拼图问题需要使用搜索算法。
- en: '**Agent**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**'
- en: An entity that perceives its environment and acts upon that environment. In
    a navigator app, for example, the agent would be a representation of a car that
    needs to decide on which actions to take to arrive at the destination.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个感知其环境并对该环境采取行动的实体。例如，在一个导航应用中，代理将是一个需要决定采取哪些行动才能到达目的地的汽车的表示。
- en: '**State**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**'
- en: A configuration of an agent in its environment. For example, in a [15 puzzle](https://en.wikipedia.org/wiki/15_puzzle),
    a state is any one way that all the numbers are arranged on the board.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代理在其环境中的配置。例如，在 [15 拼图](https://en.wikipedia.org/wiki/15_puzzle) 中，任何一种所有数字在棋盘上排列的方式都是一个状态。
- en: '**Initial State**'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始状态**'
- en: The state from which the search algorithm starts. In a navigator app, that would
    be the current location.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 搜索算法开始的状态。在导航应用中，那将是当前位置。
- en: '**Actions**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**'
- en: Choices that can be made in a state. More precisely, actions can be defined
    as a function. Upon receiving state `s` as input, `Actions(s)` returns as output
    the set of actions that can be executed in state `s`. For example, in a *15 puzzle*,
    the actions of a given state are the ways you can slide squares in the current
    configuration (4 if the empty square is in the middle, 3 if next to a side, 2
    if in the corner).
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在一个状态下可以做出的选择。更精确地说，动作可以被定义为函数。当接收到状态 `s` 作为输入时，`Actions(s)` 返回在状态 `s` 中可以执行的动作集合。例如，在
    *15 拼图* 中，给定状态的动作是你可以在当前配置中滑动方块的方式（如果空白方块在中间，有 4 种方式，如果靠近边缘，有 3 种方式，如果位于角落，有 2
    种方式）。
- en: '**Transition Model**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换模型**'
- en: A description of what state results from performing any applicable action in
    any state. More precisely, the transition model can be defined as a function.
    Upon receiving state `s` and action `a` as input, `Results(s, a)` returns the
    state resulting from performing action `a` in state `s`. For example, given a
    certain configuration of a *15 puzzle* (state `s`), moving a square in any direction
    (action `a`) will bring to a new configuration of the puzzle (the new state).
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对任何状态执行任何适用动作的结果的描述。更精确地说，转换模型可以定义为函数。当接收到状态`s`和动作`a`作为输入时，`Results(s, a)`返回在状态`s`中执行动作`a`后的状态。例如，给定某个*15个拼图*的配置（状态`s`），将一个方块向任何方向移动（动作`a`）将导致拼图的新配置（新状态）。
- en: '**State Space**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态空间**'
- en: The set of all states reachable from the initial state by any sequence of actions.
    For example, in a 15 puzzle, the state space consists of all the 16!/2 configurations
    on the board that can be reached from any initial state. The state space can be
    visualized as a directed graph with states, represented as nodes, and actions,
    represented as arrows between nodes.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过任何动作序列从初始状态可达的所有状态的集合。例如，在15个拼图游戏中，状态空间由所有16!/2个可以在任何初始状态下到达的棋盘配置组成。状态空间可以可视化为一个有向图，其中状态由节点表示，动作由节点之间的箭头表示。
- en: '![State Space](../Images/f329d4ee4d7362394eec81371b7513d0.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![状态空间](../Images/f329d4ee4d7362394eec81371b7513d0.png)'
- en: '**Goal Test**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标测试**'
- en: The condition that determines whether a given state is a goal state. For example,
    in a navigator app, the goal test would be whether the current location of the
    agent (the representation of the car) is at the destination. If it is — problem
    solved. If it’s not — we continue searching.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定给定状态是否为目标状态的条件。例如，在导航应用中，目标测试将是代理的当前位置（汽车的表示）是否在目的地。如果是——问题解决。如果不是——我们继续搜索。
- en: '**Path Cost**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径成本**'
- en: A numerical cost associated with a given path. For example, a navigator app
    does not simply bring you to your goal; it does so while minimizing the path cost,
    finding the fastest way possible for you to get to your goal state.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与给定路径相关的数值成本。例如，导航应用不仅将您带到目的地；它这样做的同时最小化路径成本，找到您到达目标状态的最快方式。
- en: Solving Search Problems
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决搜索问题
- en: '**Solution**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解**'
- en: A sequence of actions that leads from the initial state to the goal state.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从初始状态到目标状态的一系列动作。
- en: '**Optimal Solution**'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最优解**'
- en: A solution that has the lowest path cost among all solutions.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有解中具有最低路径成本的解。
- en: 'In a search process, data is often stored in a ***node***, a data structure
    that contains the following data:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索过程中，数据通常存储在**节点**中，这是一种包含以下数据的数据结构：
- en: A *state*
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*状态*
- en: Its *parent node*, through which the current node was generated
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的*父节点*，通过它生成了当前节点
- en: The *action* that was applied to the state of the parent to get to the current
    node
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用到父节点状态以到达当前节点的*动作*
- en: The *path cost* from the initial state to this node
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从初始状态到该节点的*路径成本*
- en: '*Nodes* contain information that makes them very useful for the purposes of
    search algorithms. They contain a *state*, which can be checked using the *goal
    test* to see if it is the final state. If it is, the node’s *path cost* can be
    compared to other nodes’ *path costs*, which allows choosing the *optimal solution*.
    Once the node is chosen, by virtue of storing the *parent node* and the *action*
    that led from the *parent* to the current node, it is possible to trace back every
    step of the way from the *initial state* to this node, and this sequence of actions
    is the *solution*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点*包含使它们在搜索算法目的上非常有用的信息。它们包含一个*状态*，可以使用*目标测试*来检查它是否是最终状态。如果是，节点 的*路径成本*可以与其他节点的*路径成本*进行比较，从而选择*最优解*。一旦选择了节点，由于存储了*父节点*和从*父节点*到当前节点所采取的*动作*，就可以从*初始状态*追踪到这个节点的每一步，而这个动作序列就是*解*。'
- en: 'However, *nodes* are simply a data structure — they don’t search, they hold
    information. To actually search, we use the **frontier**, the mechanism that “manages”
    the *nodes*. The *frontier* starts by containing an initial state and an empty
    set of explored items, and then repeats the following actions until a solution
    is reached:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*节点*只是一个数据结构——它们不搜索，它们只保存信息。为了实际搜索，我们使用**边界**，这是“管理”*节点*的机制。*边界*最初包含一个初始状态和一个空的已探索项集合，然后重复以下操作，直到找到解决方案：
- en: 'Repeat:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重复：
- en: If the frontier is empty,
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果边界为空，
- en: '*Stop.* There is no solution to the problem.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*停止*。该问题没有解。'
- en: Remove a node from the frontier. This is the node that will be considered.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前沿移除一个节点。这是将要考虑的节点。
- en: If the node contains the goal state,
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点包含目标状态，
- en: Return the solution. *Stop*.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回解决方案。*停止*。
- en: Else,
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，
- en: '[PRE0]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Depth-First Search
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: In the previous description of the *frontier*, one thing went unmentioned. At
    stage 2 in the pseudocode above, which node should be removed? This choice has
    implications on the quality of the solution and how fast it is achieved. There
    are multiple ways to go about the question of which nodes should be considered
    first, two of which can be represented by the data structures of **stack** (in
    *depth-first* search) and **queue** (in *breadth-first search*; and [here is a
    cute cartoon demonstration](https://www.youtube.com/watch?v=2wM6_PuBIxY) of the
    difference between the two).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述对*前沿*的描述中，有一件事没有被提及。在上述伪代码的第2阶段，应该移除哪个节点？这个选择对解决方案的质量和实现速度有影响。有几种方法可以处理哪个节点应该首先考虑的问题，其中两种可以通过*栈*（在*深度优先搜索*中）和*队列*（在*广度优先搜索*中）的数据结构来表示；[这里有一个可爱的卡通演示](https://www.youtube.com/watch?v=2wM6_PuBIxY)说明了这两种方法之间的区别）。
- en: We start with the *depth-first* search (*DFS*) approach.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从*深度优先搜索*（*DFS*）方法开始。
- en: A *depth-first* search algorithm exhausts each one direction before trying another
    direction. In these cases, the frontier is managed as a *stack* data structure.
    The catchphrase you need to remember here is “*last-in first-out*.” After nodes
    are being added to the frontier, the first node to remove and consider is the
    last one to be added. This results in a search algorithm that goes as deep as
    possible in the first direction that gets in its way while leaving all other directions
    for later.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*深度优先搜索*算法在尝试另一个方向之前会先耗尽每一个方向。在这些情况下，前沿被管理为一个*栈*数据结构。你需要记住的口号是“*后进先出*。”在节点被添加到前沿后，首先移除并考虑的是最后添加的节点。这导致了一个搜索算法，它在遇到障碍的第一个方向上尽可能深入，同时将所有其他方向留待以后。'
- en: '(An example from outside lecture: Take a situation where you are looking for
    your keys. In a *depth-first* search approach, if you choose to start with searching
    in your pants, you’d first go through every single pocket, emptying each pocket
    and going through the contents carefully. You will stop searching in your pants
    and start searching elsewhere only once you will have completely exhausted the
    search in every single pocket of your pants.)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: （来自课堂外的例子：假设你在找你的钥匙。在*深度优先搜索*方法中，如果你选择从你的裤子开始搜索，你将首先检查每一个口袋，清空每一个口袋并仔细检查里面的东西。你只有在完全检查完裤子的每一个口袋后，才会停止在裤子中搜索并开始在其他地方搜索。）
- en: 'Pros:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：
- en: At best, this algorithm is the fastest. If it “lucks out” and always chooses
    the right path to the solution (by chance), then *depth-first* search takes the
    least possible time to get to a solution.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好的情况是，这个算法是最快的。如果它“运气好”并且总是选择正确的路径到达解决方案（偶然），那么*深度优先搜索*将花费最短的时间到达解决方案。
- en: 'Cons:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：
- en: It is possible that the found solution is not optimal.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能找到的解决方案并非最优。
- en: At worst, this algorithm will explore every possible path before finding the
    solution, thus taking the longest possible time before reaching the solution.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最坏的情况是，这个算法在找到解决方案之前将探索所有可能的路径，因此到达解决方案之前将花费可能的最长时间。
- en: 'Code example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Breadth-First Search
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: The opposite of *depth-first* search would be *breadth-first* search (*BFS*).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*深度优先搜索*的对立面是*广度优先搜索*（*BFS*）。'
- en: A *breadth-first* search algorithm will follow multiple directions at the same
    time, taking one step in each possible direction before taking the second step
    in each direction. In this case, the frontier is managed as a *queue* data structure.
    The catchphrase you need to remember here is “*first-in first-out*.” In this case,
    all the new nodes add up in line, and nodes are being considered based on which
    one was added first (first come first served!). This results in a search algorithm
    that takes one step in each possible direction before taking a second step in
    any one direction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*广度优先搜索*算法将同时遵循多个方向，在每个可能的方向上先迈出一小步，然后再在每个方向上迈出第二步。在这种情况下，前沿被管理为一个*队列*数据结构。你需要记住的口号是“*先进先出*。”在这种情况下，所有新的节点都按顺序添加，节点是根据哪个先添加的来考虑的（先来先服务！）。这导致了一个搜索算法，它在每个可能的方向上迈出一小步，然后再在任何方向上迈出第二步。
- en: '(An example from outside lecture: suppose you are in a situation where you
    are looking for your keys. In this case, if you start with your pants, you will
    look in your right pocket. After this, instead of looking at your left pocket,
    you will take a look in one drawer. Then on the table. And so on, in every location
    you can think of. Only after you will have exhausted all the locations will you
    go back to your pants and search in the next pocket.)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: （来自课堂外的例子：假设你处于寻找钥匙的情况。在这种情况下，如果你从裤子开始，你会检查右边的口袋。之后，你不会检查左边的口袋，而是会查看一个抽屉。然后是桌子。等等，在每个你能想到的地方。只有在你用尽所有地方之后，你才会回到裤子并检查下一个口袋。）
- en: 'Pros:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：
- en: This algorithm is guaranteed to find the optimal solution.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个算法保证能找到最优解。
- en: 'Cons:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：
- en: This algorithm is almost guaranteed to take longer than the minimal time to
    run.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个算法几乎可以保证运行时间会比最短运行时间更长。
- en: At worst, this algorithm takes the longest possible time to run.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最坏的情况下，这个算法的运行时间是最长的。
- en: 'Code example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Greedy Best-First Search
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 贪婪最佳优先搜索
- en: Breadth-first and depth-first are both **uninformed** search algorithms. That
    is, these algorithms do not utilize any knowledge about the problem that they
    did not acquire through their own exploration. However, most often is the case
    that some knowledge about the problem is, in fact, available. For example, when
    a human maze-solver enters a junction, the human can see which way goes in the
    general direction of the solution and which way does not. AI can do the same.
    A type of algorithm that considers additional knowledge to try to improve its
    performance is called an **informed** search algorithm.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先和深度优先都是**无信息**搜索算法。也就是说，这些算法没有利用它们通过自己的探索获得的问题知识。然而，大多数情况下，确实存在一些关于问题的知识。例如，当人类迷宫解决者在进入一个交汇点时，人类可以看到哪个方向通向解决方案的一般方向，哪个方向则不行。人工智能也可以做到这一点。一种考虑额外知识以尝试提高其性能的算法称为**有信息**搜索算法。
- en: '**Greedy best-first** search expands the node that is the closest to the goal,
    as determined by a **heuristic function** *h(n)*. As its name suggests, the function
    estimates how close to the goal the next node is, but it can be mistaken. The
    efficiency of the *greedy best-first* algorithm depends on how good the heuristic
    function is. For example, in a maze, an algorithm can use a heuristic function
    that relies on the **Manhattan distance** between the possible nodes and the end
    of the maze. The *Manhattan distance* ignores walls and counts how many steps
    up, down, or to the sides it would take to get from one location to the goal location.
    This is an easy estimation that can be derived based on the (x, y) coordinates
    of the current location and the goal location.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪婪最佳优先**搜索扩展的是离目标最近的节点，这是通过**启发式函数** *h(n)* 确定的。正如其名所示，该函数估计下一个节点离目标有多近，但它可能会出错。贪婪最佳优先算法的效率取决于启发式函数的好坏。例如，在一个迷宫中，算法可以使用一个依赖于可能节点和迷宫终点之间**曼哈顿距离**的启发式函数。曼哈顿距离忽略了墙壁，并计算从当前位置到目标位置需要向上、向下或向侧面走多少步。这是一个基于当前位置和目标位置的
    (x, y) 坐标可以推导出的简单估计。'
- en: '![Manhattan Distance](../Images/9dc7b26e9d875c8a80ced3eb479552d7.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![曼哈顿距离](../Images/9dc7b26e9d875c8a80ced3eb479552d7.png)'
- en: Manhattan Distance
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 曼哈顿距离
- en: However, it is important to emphasize that, as with any heuristic, it can go
    wrong and lead the algorithm down a slower path than it would have gone otherwise.
    It is possible that an *uninformed* search algorithm will provide a better solution
    faster, but it is less likely to do so than an *informed* algorithm.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要强调，就像任何启发式方法一样，它可能会出错，并导致算法走上一条比其他情况下更慢的路径。有可能一个**无信息**搜索算法会更快地提供一个更好的解决方案，但这种情况发生的可能性比**有信息**算法要小。
- en: A* Search
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A* 搜索
- en: A development of the *greedy best-first* algorithm, *A* search* considers not
    only *h(n)*, the estimated cost from the current location to the goal, but also
    *g(n)*, the cost that was accrued until the current location. By combining both
    these values, the algorithm has a more accurate way of determining the cost of
    the solution and optimizing its choices on the go. The algorithm keeps track of
    (*cost of path until now* + *estimated cost to the goal*), and once it exceeds
    the estimated cost of some previous option, the algorithm will ditch the current
    path and go back to the previous option, thus preventing itself from going down
    a long, inefficient path that *h(n)* erroneously marked as best.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*贪婪最佳优先搜索*算法的发展，*A*搜索*不仅考虑 *h(n)*，从当前位置到目标的估计成本，还考虑 *g(n)*，到达当前位置的成本。通过结合这两个值，算法有更准确的方式来确定解决方案的成本并优化其选择。算法跟踪（*到目前为止的路径成本*
    + *到目标的估计成本*），一旦它超过某些先前选项的估计成本，算法将放弃当前路径并回到先前选项，从而防止自己沿着一个长而低效的路径走下去，而 *h(n)*
    错误地将它标记为最佳。'
- en: 'Yet again, since this algorithm, too, relies on a heuristic, it is as good
    as the heuristic that it employs. It is possible that in some situations it will
    be less efficient than *greedy best-first* search or even the *uninformed* algorithms.
    For *A* search* to be optimal, the heuristic function, *h(n)*, should be:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于这个算法也依赖于启发式方法，因此它的效果取决于所采用的启发式方法。在某些情况下，它可能不如*贪婪最佳优先搜索*甚至*无信息*算法高效。为了使*A*搜索*成为最优的，启发式函数
    *h(n)* 应该是：
- en: '*Admissible*, or never *overestimating* the true cost, and'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*可接受*，或者从不*高估*真实成本，'
- en: '*Consistent*, which means that the estimated path cost to the goal of a new
    node in addition to the cost of transitioning to it from the previous node is
    greater or equal to the estimated path cost to the goal of the previous node.
    To put it in an equation form, *h(n)* is consistent if for every node *n* and
    successor node *n’* with step cost *c*, *h(n) ≤ h(n’) + c*.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*一致*，这意味着新节点到目标路径成本的估计，加上从先前节点转换到它的成本，大于或等于先前节点到目标路径成本的估计。用方程式表示，如果对于每个节点 *n*
    和具有步长成本 *c* 的后续节点 *n’*，*h(n)* ≤ *h(n’)* + *c*，则 *h(n)* 是一致的。'
- en: Adversarial Search
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对抗搜索
- en: Whereas, previously, we have discussed algorithms that need to find an answer
    to a question, in **adversarial search** the algorithm faces an opponent that
    tries to achieve the opposite goal. Often, AI that uses adversarial search is
    encountered in games, such as tic tac toe.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 而之前，我们讨论了需要找到问题答案的算法，在**对抗搜索**中，算法面对一个试图实现相反目标的对手。通常，使用对抗搜索的AI在游戏中遇到，例如井字棋。
- en: Minimax
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Minimax
- en: A type of algorithm in adversarial search, **Minimax** represents winning conditions
    as (-1) for one side and (+1) for the other side. Further actions will be driven
    by these conditions, with the minimizing side trying to get the lowest score,
    and the maximizer trying to get the highest score.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗搜索算法中的一种类型，**Minimax** 将胜利条件表示为一方的（-1）和另一方的（+1）。后续动作将由这些条件驱动，最小化方试图获得最低分数，而最大化方试图获得最高分数。
- en: '**Representing a Tic-Tac-Toe AI**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示井字棋AI**：'
- en: '*S₀*: Initial state (in our case, an empty 3X3 board)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S₀*：初始状态（在我们的例子中，一个空的3X3棋盘）'
- en: '*Players(s)*: a function that, given a state *s*, returns which player’s turn
    it is (X or O).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*玩家(s)*：一个函数，给定一个状态 *s*，返回当前轮到哪个玩家（X或O）。'
- en: '*Actions(s)*: a function that, given a state *s*, return all the legal moves
    in this state (what spots are free on the board).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动作(s)*：一个函数，给定一个状态 *s*，返回在这个状态下所有合法的移动（棋盘上哪些位置是空的）。'
- en: '*Result(s, a)*: a function that, given a state *s* and action *a*, returns
    a new state. This is the board that resulted from performing the action *a* on
    state *s* (making a move in the game).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结果(s, a)*：一个函数，给定一个状态 *s* 和动作 *a*，返回一个新的状态。这是在状态 *s* 上执行动作 *a* 后得到的棋盘（在游戏中进行一步移动）。'
- en: '*Terminal(s)*: a function that, given a state *s*, checks whether this is the
    last step in the game, i.e. if someone won or there is a tie. Returns *True* if
    the game has ended, *False* otherwise.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*终端(s)*：一个函数，给定一个状态 *s*，检查这是否是游戏的最后一步，即是否有人获胜或有平局。如果游戏结束，则返回 *True*，否则返回 *False*。'
- en: '*Utility(s)*: a function that, given a terminal state *s*, returns the utility
    value of the state: -1, 0, or 1.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*效用(s)*：一个函数，给定一个终端状态 *s*，返回该状态的有效值：-1，0或1。'
- en: '**How the algorithm works**:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法的工作原理**：'
- en: Recursively, the algorithm simulates all possible games that can take place
    beginning at the current state and until a terminal state is reached. Each terminal
    state is valued as either (-1), 0, or (+1).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 递归地，算法模拟从当前状态开始的所有可能的游戏，直到达到终端状态。每个终端状态的价值被评估为 (-1)、0 或 (+1)。
- en: '![Minimax in Tic Tac Toe](../Images/90898339aa19687a21c66f4c787b462e.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Minimax in Tic Tac Toe](../Images/90898339aa19687a21c66f4c787b462e.png)'
- en: Minimax Algorithm in Tic Tac Toe
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Minimax 算法在井字棋中的应用
- en: 'Knowing based on the state whose turn it is, the algorithm can know whether
    the current player, when playing optimally, will pick the action that leads to
    a state with a lower or a higher value. This way, alternating between minimizing
    and maximizing, the algorithm creates values for the state that would result from
    each possible action. To give a more concrete example, we can imagine that the
    maximizing player asks at every turn: “if I take this action, a new state will
    result. If the minimizing player plays optimally, what action can that player
    take to bring to the lowest value?” However, to answer this question, the maximizing
    player has to ask: “To know what the minimizing player will do, I need to simulate
    the same process in the minimizer’s mind: the minimizing player will try to ask:
    ‘if I take this action, what action can the maximizing player take to bring to
    the highest value?’” This is a recursive process, and it could be hard to wrap
    your head around it; looking at the pseudo code below can help. Eventually, through
    this recursive reasoning process, the maximizing player generates values for each
    state that could result from all the possible actions at the current state. After
    having these values, the maximizing player chooses the highest one.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前轮到哪个状态，算法可以知道当前玩家在最优策略下，会选择导致状态值更低或更高的动作。这样，通过交替进行最小化和最大化，算法为每个可能动作的结果状态创建值。为了更具体地说明，我们可以想象最大化玩家在每一轮都会问：“如果我采取这个动作，将产生一个新的状态。如果最小化玩家采取最优策略，该玩家可以采取什么动作将值降到最低？”然而，为了回答这个问题，最大化玩家必须问：“为了知道最小化玩家会做什么，我需要在最小化玩家的思维中模拟相同的过程：最小化玩家会试图问：‘如果我采取这个动作，最大化玩家可以采取什么动作将值提高到最高？’”这是一个递归过程，可能很难理解；查看下面的伪代码可能会有所帮助。最终，通过这个递归推理过程，最大化玩家为当前状态下所有可能的动作结果状态生成值。在得到这些值之后，最大化玩家选择其中最高的一个。
- en: '![Minimax Algorithm](../Images/f54a65ee34065a79190f37dcb0886cc5.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Minimax Algorithm](../Images/f54a65ee34065a79190f37dcb0886cc5.png)'
- en: The Maximizer Considers the Possible Values of Future States.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化玩家考虑未来状态的潜在值。
- en: 'To put it in pseudocode, the Minimax algorithm works the following way:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 用伪代码来说，Minimax 算法的工作方式如下：
- en: Given a state *s*
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个状态 *s*
- en: The maximizing player picks action *a* in *Actions(s)* that produces the highest
    value of *Min-Value(Result(s, a))*.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化玩家在 *Actions(s)* 中选择动作 *a*，该动作产生 *Min-Value(Result(s, a))* 的最高值。
- en: The minimizing player picks action *a* in *Actions(s)* that produces the lowest
    value of *Max-Value(Result(s, a))*.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化玩家在 *Actions(s)* 中选择动作 *a*，该动作产生 *Max-Value(Result(s, a))* 的最低值。
- en: Function *Max-Value(state)*
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数 *Max-Value(state)*
- en: '*v = -∞*'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*v = -∞*'
- en: 'if *Terminal(state)*:'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'if *Terminal(state)*:'
- en: ​ return *Utility(state)*
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 *Utility(state)*
- en: 'for *action* in *Actions(state)*:'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'for *action* in *Actions(state)*:'
- en: ​ *v = Max(v, Min-Value(Result(state, action)))*
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*v = Max(v, Min-Value(Result(state, action)))*'
- en: return *v*
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 *v*
- en: 'Function *Min-Value(state)*:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '函数 *Min-Value(state)*:'
- en: '*v = ∞*'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*v = ∞*'
- en: 'if *Terminal(state)*:'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'if *Terminal(state)*:'
- en: ​ return *Utility(state)*
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 *Utility(state)*
- en: 'for *action* in *Actions(state)*:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'for *action* in *Actions(state)*:'
- en: ​ *v = Min(v, Max-Value(Result(state, action)))*
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*v = Min(v, Max-Value(Result(state, action)))*'
- en: return *v*
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return *v*
- en: Alpha-Beta Pruning
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Alpha-Beta Pruning
- en: A way to optimize *Minimax*, **Alpha-Beta Pruning** skips some of the recursive
    computations that are decidedly unfavorable. After establishing the value of one
    action, if there is initial evidence that the following action can bring the opponent
    to get to a better score than the already established action, there is no need
    to further investigate this action because it will decidedly be less favorable
    than the previously established one.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一种优化 Minimax 的方法是 **Alpha-Beta 剪枝**，它跳过了一些明显不利的递归计算。在确定一个动作的价值后，如果最初有证据表明接下来的动作可以使对手得到比已确定的动作更好的分数，就没有必要进一步调查这个动作，因为它将明显不如之前确定的动作有利。
- en: 'This is most easily shown with an example: a maximizing player knows that,
    at the next step, the minimizing player will try to achieve the lowest score.
    Suppose the maximizing player has three possible actions, and the first one is
    valued at 4\. Then the player starts generating the value for the next action.
    To do this, the player generates the values of the minimizer’s actions if the
    current player makes this action, knowing that the minimizer will choose the lowest
    one. However, before finishing the computation for all the possible actions of
    the minimizer, the player sees that one of the options has a value of three. This
    means that there is no reason to keep on exploring the other possible actions
    for the minimizing player. The value of the not-yet-valued action doesn’t matter,
    be it 10 or (-10). If the value is 10, the minimizer will choose the lowest option,
    3, which is already worse than the preestablished 4\. If the not-yet-valued action
    would turn out to be (-10), the minimizer will this option, (-10), which is even
    more unfavorable to the maximizer. Therefore, computing additional possible actions
    for the minimizer at this point is irrelevant to the maximizer, because the maximizing
    player already has an unequivocally better choice whose value is 4.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点最容易被一个例子所说明：一个最大化玩家知道，在下一步，最小化玩家将试图获得最低的分数。假设最大化玩家有三个可能的行为，第一个行为的价值是4。然后玩家开始为下一步生成价值。为了做到这一点，玩家在当前玩家采取这个行为的情况下，生成最小化玩家行为的值，知道最小化玩家将选择最低的一个。然而，在完成所有可能的最小化玩家行为的计算之前，玩家看到其中一个选项的价值是三。这意味着没有必要继续探索其他可能的最小化玩家行为。尚未评估的行为的价值并不重要，无论是10还是(-10)。如果价值是10，最小化玩家将选择最低的选项，3，这已经比预先设定的4更差。如果尚未评估的行为最终是(-10)，最小化玩家将选择这个选项，(-10)，这对最大化玩家来说更加不利。因此，在这一点上计算最小化玩家的额外可能行为对最大化玩家来说是不相关的，因为最大化玩家已经有一个明确更好的选择，其价值是4。
- en: '![Alpha Beta Pruning](../Images/f70a9ca3ea995ccf986e12fae24cca15.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Alpha Beta 剪枝](../Images/f70a9ca3ea995ccf986e12fae24cca15.png)'
- en: Depth-Limited Minimax
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深度限制最小-最大
- en: There is a total of 255,168 possible Tic Tac Toe games, and 10²⁹⁰⁰⁰ possible
    games in Chess. The minimax algorithm, as presented so far, requires generating
    all hypothetical games from a certain point to the terminal condition. While computing
    all the Tic-Tac-Toe games doesn’t pose a challenge for a modern computer, doing
    so with chess is currently impossible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有255,168种可能的井字棋游戏，以及10²⁹⁰⁰⁰种可能的国际象棋游戏。到目前为止所展示的最小-最大算法需要从某个点生成所有假设游戏到终端状态。虽然计算所有井字棋游戏对现代计算机来说并不构成挑战，但用国际象棋来做这一点目前是不可能的。
- en: '**Depth-limited Minimax** considers only a pre-defined number of moves before
    it stops, without ever getting to a terminal state. However, this doesn’t allow
    for getting a precise value for each action, since the end of the hypothetical
    games has not been reached. To deal with this problem, *Depth-limited Minimax*
    relies on an **evaluation function** that estimates the expected utility of the
    game from a given state, or, in other words, assigns values to states. For example,
    in a chess game, a utility function would take as input a current configuration
    of the board, try to assess its expected utility (based on what pieces each player
    has and their locations on the board), and then return a positive or a negative
    value that represents how favorable the board is for one player versus the other.
    These values can be used to decide on the right action, and the better the evaluation
    function, the better the Minimax algorithm that relies on it.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度限制最小-最大**只考虑在停止之前预先定义的移动数，而不会达到终端状态。然而，这并不允许为每个行为获得精确的价值，因为假设游戏并没有达到终端。为了解决这个问题，*深度限制最小-最大*依赖于一个**评估函数**，该函数估计从给定状态的游戏预期效用，换句话说，为状态分配值。例如，在国际象棋游戏中，效用函数将当前棋盘配置作为输入，尝试评估其预期效用（基于每个玩家拥有的棋子和它们在棋盘上的位置），然后返回一个正或负值，表示棋盘对一方玩家相对于另一方的有利程度。这些值可以用来决定正确的行动，评估函数越好，依赖它的最小-最大算法就越好。'
