- en: Lecture 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/x/notes/5/](https://cs50.harvard.edu/x/notes/5/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Welcome!](#welcome)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Data Structures](#data-structures)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Queues](#queues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stacks](#stacks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Jack Learns the Facts](#jack-learns-the-facts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Resizing Arrays](#resizing-arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Arrays](#arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linked Lists](#linked-lists)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Trees](#trees)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dictionaries](#dictionaries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hashing and Hash Tables](#hashing-and-hash-tables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tries](#tries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summing Up](#summing-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the prior weeks have presented you with the fundamental building blocks
    of programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All you have learned in C will enable you to implement these building blocks
    in higher-level programming languages such as Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each week, concepts have become more and more challenging, like a hill becoming
    more and more steep. This week, the challenge evens off as we explore data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To date, you have learned about how an array can organize data in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, we are going to talk about organizing data in memory and design possibilities
    that emerge from your growing knowledge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Data structures* essentially are forms of organization in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many ways to organize data in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Abstract data types* are those that we can conceptually imagine. When learning
    about computer science, it’s often useful to begin with these conceptual data
    structures. Learning these will make it easier later to understand how to implement
    more concrete data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Queues* are one form of abstract data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues have specific properties. Namely, they are *FIFO* or “first in first
    out.” You can imagine yourself in a line for a ride at an amusement park. The
    first person in the line gets to go on the ride first. The last person gets to
    go on the ride last.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues have specific actions associated with them. For example, an item can
    be *enqueued*; that is, the item can join the line or queue. Further, an item
    can be *dequeued* or leave the queue once it reaches the front of the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In code, you can imagine a queue as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that an array called people is of type `person`. The `CAPACITY` is how
    high the stack could be. The integer `size` is how full the queue actually is,
    regardless of how much it *can* hold.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Queues contrast a *stack*. Fundamentally, the properties of a stack are different
    than those of a queue. Specifically, it is *LIFO* or “last in first out.” Just
    like stacking trays in a dining hall, a tray that is placed in a stack last is
    the first that may be picked up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks have specific actions associated with them. For example, *push* places
    something on top of a stack. *Pop* is removing something from the top of the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In code, you might imagine a stack as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that an array called people is of type `person`. The `CAPACITY` is how
    high the stack could be. The integer `size` is how full the stack actually is,
    regardless of how much it *could* hold. Notice that this code is the same as the
    code from the queue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You might imagine that the above code has a limitation. Since the capacity of
    the array is always predetermined in this code. Therefore, the stack may always
    be oversized. You might imagine only using one place in the stack out of 5000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would be nice for our stack to be dynamic – able to grow as items are added
    to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jack Learns the Facts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We watched a video called [Jack Learns the Facts](https://www.youtube.com/watch?v=ItAG3s6KIEI)
    by Professor Shannon Duvall of Elon University.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rewinding to Week 2, we introduced you to your first data structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array is a block of contiguous memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might imagine an array as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![three boxes with 1 2 3](../Images/d34bcecbdc52271932744b2f38e3e0f7.png "array")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In memory, there are other values being stored by other programs, functions,
    and variables. Many of these may be unused garbage values that were utilized at
    one point but are available now for use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![three boxes with 1 2 3 among lots of other memory elements](../Images/04c9648958e03e6f1c3c581b0f374622.png
    "array inside memory")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Imagine you wanted to store a fourth value `4` in our array. What would be needed
    is to allocate a new area of memory and move the old array to a new one? Initially,
    this new area of memory would be populated with garbage values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Three boxes with 1 2 3 above four boxes with garbage values](../Images/761276944f2e9967835141ff0848123e.png
    "two arrays with garbage values")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As values are added to this new area of memory, old garbage values would be
    overwritten.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Three boxes with 1 2 3 above four boxes with 1 2 3 and a garbage value](../Images/548ba88fa2d99885a541c50521a62f70.png
    "two arrays with garbage value")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Eventually, all old garbage values would be overwritten with our new data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Three boxes with 1 2 3 above four boxes with 1 2 3 4](../Images/ea2d1c42c57d7b834229dd9609b6cdab.png
    "two arrays with garbage value")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'One of the drawbacks of this approach is that it’s bad design: Every time we
    add a number, we have to copy the array item by item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wouldn’t it be nice if we were able to put the `4` somewhere else in memory?
    By definition, this would no longer be an array because `4` would no longer be
    in contiguous memory. How could we connect different locations in memory?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your terminal, type `code list.c` and write code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the above is very much like what we learned earlier in this course.
    Memory is preallocated for three items.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Building upon our knowledge obtained more recently, we can leverage our understanding
    of pointers to create a better design in this code. Modify your code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that a list of size three integers is created. Then, three memory addresses
    can be assigned the values `1`, `2`, and `3`. Then, a list of size four is created.
    Next, the list is copied from the first to the second. The value for the `4` is
    added to the `tmp` list. Since the block of memory that `list` points to is no
    longer used, it is freed using the command `free(list)`. Finally, the compiler
    is told to point `list` pointer now to the block of memory that `tmp` points to.
    The contents of `list` are printed and then freed. Further, notice the inclusion
    of `stdlib.h`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s useful to think about `list` and `tmp` as both signs that point to a chunk
    of memory. As in the example above, `list` at one point *pointed* to an array
    of size 3\. By the end, `list` was told to point to a chunk of memory of size
    4\. Technically, by the end of the above code, `tmp` and `list` both pointed to
    the same block of memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One way by which we can copy the array without a for loop is by using `realloc`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the list is reallocated to a new array via `realloc`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One may be tempted to allocate way more memory than required for the list, such
    as 30 items instead of the required 3 or 4\. However, this is bad design as it
    taxes system resources when they are not potentially needed. Further, there is
    little guarantee that memory for more than 30 items will be needed eventually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent weeks, you have learned about three useful primitives. A `struct`
    is a data type that you can define yourself. A `.` in *dot notation* allows you
    to access variables inside that structure. The `*` operator is used to declare
    a pointer or dereference a variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, you are introduced to the `->` operator. It is an arrow. This operator
    goes to an address and looks inside a structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *linked list* is one of the most powerful data structures within C. A linked
    list allows you to include values that are located in varying areas of memory.
    Further, they allow you to dynamically grow and shrink the list as you desire.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might imagine three values stored in three different areas of memory as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Three boxes with 1 2 3 in separate areas of memory](../Images/778e15e3a97408dde5c9183912b0a0a4.png
    "three values in memory")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How could one stitch together these values in a list?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could imagine the data pictured above as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Three boxes with 1 2 3 in separate areas of memory with smaller boxes attached](../Images/b07c28da45ed734f9469681811b1a789.png
    "three values in memory")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We could utilize more memory to keep track of where the next item using a pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Three boxes with 1 2 3 in separate areas of memory with smaller boxes attached
    where memory addresses are in those attached boxes](../Images/22dd31970ae9929d55e15d92de091c85.png
    "three values in memory")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that NULL is utilized to indicate that nothing else is *next* in the
    list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By convention, we would keep one more element in memory, a pointer, that keeps
    track of the first item in the list, called the *head* of the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Three boxes with 1 2 3 in separate areas of memory with smaller boxes attached
    where memory addresses are in those attached boxes now with a final box with the
    memory address of the first box](../Images/5c91f35f98339346e7e797670973617c.png
    "three values in memory with pointer")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Abstracting away the memory addresses, the list would appear as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Three boxes with in separate areas of memory with smaller boxes with a final
    box where the one box points to another and another until the end of the boxes](../Images/de5d348bca1d7fe280064c56108281f8.png
    "three values in memory with pointer")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'These boxes are called *nodes*. A *node* contains both an *item* and a pointer
    called *next*. In code, you can imagine a node as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the item contained within this node is an integer called `number`.
    Second, a pointer to a node called `next` is included, which will point to another
    node somewhere in memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can recreate `list.c` to utilize a linked list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, a `node` is defined as a `struct`. For each element of the list, memory
    for a `node` is allocated via `malloc` to the size of a node. `n->number` (or
    `n`’s number field) is assigned an integer. `n->next` (or `n`’s next field) is
    assigned `null`. Then, the node is placed at the start of the list at memory location
    `list`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Conceptually, we can imagine the process of creating a linked list. First, `node
    *list` is declared, but it is of a garbage value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![One garbage value](../Images/b6d39804d8ad476803c5424ab7a67ced.png "linked
    list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, a node called `n` is allocated in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![One garbage value called n with another pointer called list](../Images/cc8488193d41cb930a2c7d468ad964e8.png
    "linked list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, the `number` of node is assigned the value `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![n pointing to a node with 1 as the number and garbage value as the next](../Images/d114de09528bf567bf1e0109531aabeb.png
    "linked list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, the node’s `next` field is assigned `NULL`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![n pointing to a node with 1 as the number and null as the value of next](../Images/5d8e17eee341c7731473bb6b1c0b1ffd.png
    "linked list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, `list` is pointed at the memory location to where `n` points. `n` and
    `list` now point to the same place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![n and list both pointing to a node with 1 as the number and null as the value
    of next](../Images/7fec0d8902e51dee56555a8198859bf7.png "linked list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: A new node is then created. Both the `number` and `next` field are filled with
    garbage values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![list pointing to a node with 1 as the number and null as the value of next
    and n pointing to a new node with garbage values](../Images/1ca5619a4434079950fcb951de63523b.png
    "linked list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The `number` value of `n`’s node (the new node) is updated to `2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![list pointing to a node with 1 as the number and null as the value of next
    and n pointing to a new node with 2 as the number and garbage as the next](../Images/68832f3dba6377d090d013ff705434ef.png
    "linked list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Also, the `next` field is updated as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![list pointing to a node with 1 as the number and null as the value of next
    and n pointing to a new node with 2 as the number and null as the next](../Images/fb7f5bd791741fafeaa38e51b56cc9b9.png
    "linked list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Most importantly, we do not want to lose our connection to any of these nodes
    lest they be lost forever. Accordingly, `n`’s `next` field is pointed to the same
    memory location as `list`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![list pointing to a node with 1 as the number and null as the value of next
    and n pointing to a new node with 2 as the number and null as the next](../Images/0dc8276fd04b08b3e1265e55c003f870.png
    "linked list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Finally, `list` is updated to point at `n`. We now have a linked list of two
    items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![list pointing to a node with 1 as the number and next pointing to a node
    with an n pointing the same place the node with one points to a node with 2 as
    the number and null as the next](../Images/68fba35035561d4d0a30b32d1b9af319.png
    "linked list")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Looking at our diagram of the list, we can see that the last number added is
    the first number that appears in the list. Accordingly, if we print the list in
    order, starting with the first node, the list will appear out of order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can print the list in the correct order as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `node *ptr = list` creates a temporary variable that points at the
    same spot that `list` points to. The `while` prints what at the node `ptr` points
    to, and then updates `ptr` to point to the `next` node in the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, inserting into the list is always in the order of \(O(1)\),
    as it only takes a very small number of steps to insert at the front of a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the amount of time required to search this list, it is in the order
    of \(O(n)\), because in the worst case the entire list must always be searched
    to find an item. The time complexity for adding a new element to the list will
    depend on where that element is added. This is illustrated in the examples below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists are not stored in a contiguous block of memory. They can grow as
    large as you wish, provided that enough system resources exist. The downside,
    however, is that more memory is required to keep track of the list instead of
    an array. For each element you must store not just the value of the element, but
    also a pointer to the next node. Further, linked lists cannot be indexed into
    like is possible in an array because we need to pass through the first \(n - 1\)
    elements to find the location of the \(n\)th element. Because of this, the list
    pictured above must be linearly searched. Binary search, therefore, is not possible
    in a list constructed as above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Further, you could place numbers at the end of the list as illustrated in this
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this code *walks down* this list to find the end. When appending
    an element (adding to the end of the list) our code will run in \(O(n)\), as we
    have to go through our entire list before we can add the final element. Further,
    notice that a temporary variable called `next` is used to track `ptr->next`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Further, you could sort your list as items are added:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this list is sorted as it is built. To insert an element in this
    specific order, our code will still run in \(O(n)\) for each insertion, as in
    the worst case we will have to look through all current elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This code may seem complicated. However, notice that with pointers and the syntax
    above, we can stitch data together in different places in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays offer contiguous memory that can be searched quickly. Arrays also offered
    the opportunity to engage in binary search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could we combine the best of both arrays and linked lists?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binary search trees* are another data structure that can be used to store
    data more efficiently so that it can be searched and retrieved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can imagine a sorted sequence of numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![1 2 3 4 5 6 7 in boxes next to each other](../Images/4f4a50b0fa906dd640e7d1e2beda073d.png
    "tree")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Imagine then that the center value becomes the top of a tree. Those that are
    less than this value are placed to the left. Those values that are more than this
    value are to the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![1 2 3 4 5 6 7 in boxes arranged in a hierarchy 4 is at the top 3 and 5 are
    below that and 1 2 6 7 are below those](../Images/7ad7e3efe6b11ff81034b24b6f752802.png
    "tree")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Pointers can then be used to point to the correct location of each area of memory
    such that each of these nodes can be connected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![1 2 3 4 5 6 7 in boxes arranged in a hierarchy 4 is at the top 3 and 5 are
    below that and 1 2 6 7 are below those arrows connect them in a tree formation](../Images/6879c95a0b436bd34b2f7c1748ca5ad8.png
    "tree")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In code, this can be implemented as follows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice this search function begins by going to the location of `tree`. Then,
    it uses recursion to search for `number`. The `free_tree` function recursively
    frees the tree. `print_tree` recursively prints the tree.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A tree like the above offers dynamism that an array does not offer. It can grow
    and shrink as we wish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, this structure offers a search time of \(O(log n)\) when the tree is
    balanced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Dictionaries* are another data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries, like actual book-form dictionaries that have a word and a definition,
    have a *key* and a *value*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *holy grail* of algorithmic time complexity is \(O(1)\) or *constant time*.
    That is, the ultimate is for access to be instantaneous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![a graph of various time complexities where O of log n is second best and
    O of 1 is best](../Images/be842bae9176b8c123def3e311e235e9.png "time complexity")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Dictionaries can offer this speed of access through hashing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing and Hash Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Hashing* is the idea of taking a value and being able to output a value that
    becomes a shortcut to it later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, hashing *apple* may hash as a value of `1`, and *berry* may be
    hashed as `2`. Therefore, finding *apple* is as easy as asking the *hash* algorithm
    where *apple* is stored. While not ideal in terms of design, ultimately, putting
    all *a*’s in one bucket and *b*’s in another, this concept of *bucketizing* hashed
    values illustrates how you can use this concept: a hashed value can be used to
    shortcut finding such a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *hash function* is an algorithm that reduces a larger value to something small
    and predictable. Generally, this function takes in an item you wish to add to
    your hash table, and returns an integer representing the array index in which
    the item should be placed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *hash table* is a fantastic combination of both arrays and linked lists. When
    implemented in code, a hash table is an *array* of *pointers* to *node*s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A hash table could be imagined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![a vertical column of 26 boxes one for each letter of the alphabet](../Images/fab363539963a53f25e01cb4eeb1b422.png
    "alphabet")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice that this is an array that is assigned each value of the alphabet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, at each location of the array, a linked list is used to track each value
    being stored there:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![a vertical column of 26 boxes one for each letter of the alphabet with various
    names from the mario universe emerging to the right luigi is with l and mario
    is with m](../Images/3b7dd601e46bc05746e82d7ffc9b5b61.png "alphabet")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Collisions* are when you add values to the hash table, and something already
    exists at the hashed location. In the above, collisions are simply appended to
    the end of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collisions can be reduced by better programming your hash table and hash algorithm.
    You can imagine an improvement upon the above as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![a vertical column of various boxes arranged by L A K and L I N with Lakitu
    emerging from L A K and link emerging from L I N](../Images/e51a60f34aa7b92a1cc29b25c0a7f981.png
    "alphabet")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Consider the following example of a hash algorithm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![luigi being given to a hash algorithm outputting 11](../Images/0696a8d8e7d78370dcbaf5c00100a9d1.png
    "hashing")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'This could be implemented in code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the hash function returns the value of `toupper(word[0]) - 'A'`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You, as the programmer, have to make a decision about the advantages of using
    more memory to have a large hash table and potentially reducing search time or
    using less memory and potentially increasing search time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This structure offers a search time of \(O(n)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Tries* are another form of data structure. Tries are trees of arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tries* are always searchable in constant time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One downside to *Tries* is that they tend to take up a large amount of memory.
    Notice that we need \(26 \times 4 = 104\) `node`s just to store *Toad*!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Toad* would be stored as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![toad being spelled with one letter at a time where one letter is associated
    with one list T from one list O from another and so on ](../Images/dde5f80eef85bf6c2a0effa25843996d.png
    "tries")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Tom* would then be stored as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![toad being spelled with one letter at a time where one letter is associated
    with one list T from one list O from another and so on and tom being spelled similarly
    where toad and tom share a two common letters T and O](../Images/d87c3fc3a156b4abe5e23b86af845b89.png
    "tries")'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This structure offers a search time of \(O(1)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The downside of this structure is how many resources are required to use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, you learned about using pointers to build new data structures.
    Specifically, we delved into…
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks and queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See you next time!
  prefs: []
  type: TYPE_NORMAL
