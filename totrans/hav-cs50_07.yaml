- en: Lecture 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五讲
- en: 原文：[https://cs50.harvard.edu/x/notes/5/](https://cs50.harvard.edu/x/notes/5/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/x/notes/5/](https://cs50.harvard.edu/x/notes/5/)
- en: '[Welcome!](#welcome)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[欢迎！](#welcome)'
- en: '[Data Structures](#data-structures)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据结构](#data-structures)'
- en: '[Queues](#queues)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[队列](#queues)'
- en: '[Stacks](#stacks)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[栈](#stacks)'
- en: '[Jack Learns the Facts](#jack-learns-the-facts)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[杰克学习事实](#jack-learns-the-facts)'
- en: '[Resizing Arrays](#resizing-arrays)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[调整数组大小](#resizing-arrays)'
- en: '[Arrays](#arrays)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数组](#arrays)'
- en: '[Linked Lists](#linked-lists)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[链表](#linked-lists)'
- en: '[Trees](#trees)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[树](#trees)'
- en: '[Dictionaries](#dictionaries)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字典](#dictionaries)'
- en: '[Hashing and Hash Tables](#hashing-and-hash-tables)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[哈希和哈希表](#hashing-and-hash-tables)'
- en: '[Tries](#tries)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字典树](#tries)'
- en: '[Summing Up](#summing-up)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summing-up)'
- en: Welcome!
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎光临！
- en: All the prior weeks have presented you with the fundamental building blocks
    of programming.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前几周已经向你介绍了编程的基本构建块。
- en: All you have learned in C will enable you to implement these building blocks
    in higher-level programming languages such as Python.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在 C 语言中学到的所有知识都将使你能够在 Python 等高级编程语言中实现这些构建块。
- en: Each week, concepts have become more and more challenging, like a hill becoming
    more and more steep. This week, the challenge evens off as we explore data structures.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周，概念变得越来越具有挑战性，就像一座山变得越来越陡峭。本周，随着我们探索数据结构，挑战变得平缓。
- en: To date, you have learned about how an array can organize data in memory.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迄今为止，你已经学习了如何使用数组在内存中组织数据。
- en: Today, we are going to talk about organizing data in memory and design possibilities
    that emerge from your growing knowledge.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，我们将讨论如何在内存中组织数据以及从你不断增长的知识中出现的可能性。
- en: Data Structures
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构
- en: '*Data structures* essentially are forms of organization in memory.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据结构* 实质上是内存中的组织形式。'
- en: There are many ways to organize data in memory.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中组织数据有许多方法。
- en: '*Abstract data types* are those that we can conceptually imagine. When learning
    about computer science, it’s often useful to begin with these conceptual data
    structures. Learning these will make it easier later to understand how to implement
    more concrete data structures.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽象数据类型* 是我们可以概念上想象的数据类型。在了解计算机科学时，通常从这些概念数据结构开始学习是有用的。学习这些将使以后理解如何实现更具体的数据结构变得更加容易。'
- en: Queues
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列
- en: '*Queues* are one form of abstract data structure.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*队列* 是一种抽象数据结构的形式。'
- en: Queues have specific properties. Namely, they are *FIFO* or “first in first
    out.” You can imagine yourself in a line for a ride at an amusement park. The
    first person in the line gets to go on the ride first. The last person gets to
    go on the ride last.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列具有特定的属性。具体来说，它们是 *FIFO* 或“先进先出”。你可以想象自己在游乐园排队等待游乐设施。第一个排队的会先玩，最后一个排队的会后玩。
- en: Queues have specific actions associated with them. For example, an item can
    be *enqueued*; that is, the item can join the line or queue. Further, an item
    can be *dequeued* or leave the queue once it reaches the front of the line.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列与特定的动作相关联。例如，一个项目可以被 *enqueued*；也就是说，项目可以加入队伍或队列。此外，一个项目可以被 *dequeued* 或者在到达队伍前端时离开队列。
- en: 'In code, you can imagine a queue as follows:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中，你可以这样想象一个队列：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that an array called people is of type `person`. The `CAPACITY` is how
    high the stack could be. The integer `size` is how full the queue actually is,
    regardless of how much it *can* hold.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，名为 `people` 的数组是 `person` 类型。`CAPACITY` 表示栈可能达到的高度。整数 `size` 表示队列实际填充的程度，无论它可以容纳多少。
- en: Stacks
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈
- en: Queues contrast a *stack*. Fundamentally, the properties of a stack are different
    than those of a queue. Specifically, it is *LIFO* or “last in first out.” Just
    like stacking trays in a dining hall, a tray that is placed in a stack last is
    the first that may be picked up.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列与栈相对。从根本上讲，栈的性质与队列的性质不同。具体来说，它是 *LIFO* 或“后进先出”。就像在餐厅里堆叠盘子一样，最后放入堆叠中的盘子可能是第一个被取走的。
- en: Stacks have specific actions associated with them. For example, *push* places
    something on top of a stack. *Pop* is removing something from the top of the stack.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈与特定的动作相关联。例如，*push* 将某物放置在栈顶。*Pop* 是从栈顶移除某物。
- en: 'In code, you might imagine a stack as follows:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中，你可能可以这样想象一个栈：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that an array called people is of type `person`. The `CAPACITY` is how
    high the stack could be. The integer `size` is how full the stack actually is,
    regardless of how much it *could* hold. Notice that this code is the same as the
    code from the queue.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，名为 `people` 的数组是 `person` 类型。`CAPACITY` 表示栈可能达到的高度。整数 `size` 表示栈实际填充的程度，无论它可以容纳多少。注意，这段代码与队列中的代码相同。
- en: You might imagine that the above code has a limitation. Since the capacity of
    the array is always predetermined in this code. Therefore, the stack may always
    be oversized. You might imagine only using one place in the stack out of 5000.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能会想象，上面的代码有一个限制。因为在这个代码中，数组的容量总是预先确定的。因此，栈可能总是过大。您可能会想象只使用栈中的5000个位置中的一个。
- en: It would be nice for our stack to be dynamic – able to grow as items are added
    to it.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的栈是动态的——能够随着添加到其中的项目而增长，那就太好了。
- en: Jack Learns the Facts
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jack Learns the Facts
- en: We watched a video called [Jack Learns the Facts](https://www.youtube.com/watch?v=ItAG3s6KIEI)
    by Professor Shannon Duvall of Elon University.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们观看了由Elon大学的Shannon Duvall教授制作的名为[Jack Learns the Facts](https://www.youtube.com/watch?v=ItAG3s6KIEI)的视频。
- en: Resizing Arrays
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整数组大小
- en: Rewinding to Week 2, we introduced you to your first data structure.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾到第2周，我们向您介绍了您的第一个数据结构。
- en: An array is a block of contiguous memory.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是一块连续的内存。
- en: 'You might imagine an array as follows:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能会想象数组如下所示：
- en: '![three boxes with 1 2 3](../Images/d34bcecbdc52271932744b2f38e3e0f7.png "array")'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个带有1 2 3的箱子](../Images/d34bcecbdc52271932744b2f38e3e0f7.png "数组")'
- en: In memory, there are other values being stored by other programs, functions,
    and variables. Many of these may be unused garbage values that were utilized at
    one point but are available now for use.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中，还有其他程序、函数和变量存储的值。其中许多可能是曾经被使用但现在可供使用的未使用垃圾值。
- en: '![three boxes with 1 2 3 among lots of other memory elements](../Images/04c9648958e03e6f1c3c581b0f374622.png
    "array inside memory")'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个带有1 2 3的箱子以及其他许多内存元素](../Images/04c9648958e03e6f1c3c581b0f374622.png "内存中的数组")'
- en: Imagine you wanted to store a fourth value `4` in our array. What would be needed
    is to allocate a new area of memory and move the old array to a new one? Initially,
    this new area of memory would be populated with garbage values.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设您想在我们的数组中存储第四个值`4`。需要做的是分配一个新的内存区域并将旧数组移动到新区域？最初，这个新的内存区域将填充垃圾值。
- en: '![Three boxes with 1 2 3 above four boxes with garbage values](../Images/761276944f2e9967835141ff0848123e.png
    "two arrays with garbage values")'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个带有1 2 3的箱子在四个带有垃圾值的箱子上方](../Images/761276944f2e9967835141ff0848123e.png
    "两个带有垃圾值的数组")'
- en: As values are added to this new area of memory, old garbage values would be
    overwritten.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当向这个新的内存区域添加值时，旧的垃圾值会被覆盖。
- en: '![Three boxes with 1 2 3 above four boxes with 1 2 3 and a garbage value](../Images/548ba88fa2d99885a541c50521a62f70.png
    "two arrays with garbage value")'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个带有1 2 3的箱子在四个带有1 2 3和一个垃圾值的箱子上方](../Images/548ba88fa2d99885a541c50521a62f70.png
    "带有垃圾值的两个数组")'
- en: Eventually, all old garbage values would be overwritten with our new data.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，所有旧的垃圾值都会被新的数据覆盖。
- en: '![Three boxes with 1 2 3 above four boxes with 1 2 3 4](../Images/ea2d1c42c57d7b834229dd9609b6cdab.png
    "two arrays with garbage value")'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个带有1 2 3的箱子在四个带有1 2 3 4的箱子上方](../Images/ea2d1c42c57d7b834229dd9609b6cdab.png
    "带有垃圾值的两个数组")'
- en: 'One of the drawbacks of this approach is that it’s bad design: Every time we
    add a number, we have to copy the array item by item.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法的缺点之一是设计不佳：每次我们添加一个数字，我们都必须逐个复制数组项。
- en: Arrays
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Wouldn’t it be nice if we were able to put the `4` somewhere else in memory?
    By definition, this would no longer be an array because `4` would no longer be
    in contiguous memory. How could we connect different locations in memory?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们能够将`4`存储在内存的另一个地方会怎么样？根据定义，这将不再是一个数组，因为`4`将不再在连续的内存中。我们如何连接内存中的不同位置？
- en: 'In your terminal, type `code list.c` and write code as follows:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的终端中，键入`code list.c`并编写以下代码：
- en: '[PRE2]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the above is very much like what we learned earlier in this course.
    Memory is preallocated for three items.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，上面的代码与我们在本课程中早期学到的非常相似。内存为三个项目预先分配。
- en: 'Building upon our knowledge obtained more recently, we can leverage our understanding
    of pointers to create a better design in this code. Modify your code as follows:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立在最近获得的知识基础上，我们可以利用我们对指针的理解来改进这段代码的设计。按照以下方式修改您的代码：
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that a list of size three integers is created. Then, three memory addresses
    can be assigned the values `1`, `2`, and `3`. Then, a list of size four is created.
    Next, the list is copied from the first to the second. The value for the `4` is
    added to the `tmp` list. Since the block of memory that `list` points to is no
    longer used, it is freed using the command `free(list)`. Finally, the compiler
    is told to point `list` pointer now to the block of memory that `tmp` points to.
    The contents of `list` are printed and then freed. Further, notice the inclusion
    of `stdlib.h`.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，创建了一个包含三个整数的列表。然后，可以将三个内存地址分配给值 `1`、`2` 和 `3`。接着，创建了一个大小为四的列表。接下来，列表从第一个复制到第二个。将值
    `4` 添加到 `tmp` 列表中。由于 `list` 指向的内存块不再使用，使用命令 `free(list)` 释放它。最后，编译器被指示将 `list`
    指针现在指向 `tmp` 指向的内存块。打印 `list` 的内容，然后释放。此外，请注意包含了 `stdlib.h`。
- en: It’s useful to think about `list` and `tmp` as both signs that point to a chunk
    of memory. As in the example above, `list` at one point *pointed* to an array
    of size 3\. By the end, `list` was told to point to a chunk of memory of size
    4\. Technically, by the end of the above code, `tmp` and `list` both pointed to
    the same block of memory.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的是将 `list` 和 `tmp` 都视为指向一块内存的指针。正如上面的例子所示，`list` 在某个时刻 *指向* 一个大小为 3 的数组。到结束时，`list`
    被指示指向一个大小为 4 的内存块。技术上讲，在上述代码结束时，`tmp` 和 `list` 都指向了同一块内存。
- en: 'One way by which we can copy the array without a for loop is by using `realloc`:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种不使用 for 循环复制数组的方法是使用 `realloc`：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the list is reallocated to a new array via `realloc`.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，列表通过 `realloc` 调整大小到新的数组。
- en: One may be tempted to allocate way more memory than required for the list, such
    as 30 items instead of the required 3 or 4\. However, this is bad design as it
    taxes system resources when they are not potentially needed. Further, there is
    little guarantee that memory for more than 30 items will be needed eventually.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会有人想为列表分配比所需更多的内存，比如 30 项而不是所需的 3 或 4 项。然而，这并不是一个好的设计，因为它在不需要时也会消耗系统资源。此外，几乎没有保证最终需要超过
    30 项内存。
- en: Linked Lists
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表
- en: In recent weeks, you have learned about three useful primitives. A `struct`
    is a data type that you can define yourself. A `.` in *dot notation* allows you
    to access variables inside that structure. The `*` operator is used to declare
    a pointer or dereference a variable.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最近几周，你学习了三个有用的原语。`struct` 是你可以自己定义的数据类型。点号（`.`）在点表示法中允许你访问该结构体内部的变量。`*` 操作符用于声明指针或取消引用变量。
- en: Today, you are introduced to the `->` operator. It is an arrow. This operator
    goes to an address and looks inside a structure.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，你将介绍 `->` 操作符。它是一个箭头。此操作符指向一个地址并在结构体内部查找。
- en: A *linked list* is one of the most powerful data structures within C. A linked
    list allows you to include values that are located in varying areas of memory.
    Further, they allow you to dynamically grow and shrink the list as you desire.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表是 C 中最强大的数据结构之一。链表允许你包含位于不同内存区域的值。此外，它们允许你根据需要动态地扩展和缩小列表。
- en: 'You might imagine three values stored in three different areas of memory as
    follows:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会想象三个值存储在三个不同的内存区域，如下所示：
- en: '![Three boxes with 1 2 3 in separate areas of memory](../Images/778e15e3a97408dde5c9183912b0a0a4.png
    "three values in memory")'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个内存中分别有 1 2 3 的三个盒子](../Images/778e15e3a97408dde5c9183912b0a0a4.png "内存中的三个值")'
- en: How could one stitch together these values in a list?
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将这些值在列表中拼接起来？
- en: 'We could imagine the data pictured above as follows:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以想象上面的数据如下所示：
- en: '![Three boxes with 1 2 3 in separate areas of memory with smaller boxes attached](../Images/b07c28da45ed734f9469681811b1a789.png
    "three values in memory")'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个内存中分别有 1 2 3 的三个盒子，每个盒子上附有较小的盒子](../Images/b07c28da45ed734f9469681811b1a789.png
    "内存中的三个值")'
- en: We could utilize more memory to keep track of where the next item using a pointer.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用更多的内存来跟踪下一个项目使用指针的位置。
- en: '![Three boxes with 1 2 3 in separate areas of memory with smaller boxes attached
    where memory addresses are in those attached boxes](../Images/22dd31970ae9929d55e15d92de091c85.png
    "three values in memory")'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个内存中分别有 1 2 3 的三个盒子，每个盒子上附有较小的盒子，其中包含内存地址](../Images/22dd31970ae9929d55e15d92de091c85.png
    "内存中的三个值")'
- en: Notice that NULL is utilized to indicate that nothing else is *next* in the
    list.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，NULL 被用来表示列表中没有其他内容。
- en: By convention, we would keep one more element in memory, a pointer, that keeps
    track of the first item in the list, called the *head* of the list.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照惯例，我们会在内存中保留一个额外的元素，一个指针，它跟踪列表中的第一个项目，称为列表的*头*。
- en: '![Three boxes with 1 2 3 in separate areas of memory with smaller boxes attached
    where memory addresses are in those attached boxes now with a final box with the
    memory address of the first box](../Images/5c91f35f98339346e7e797670973617c.png
    "three values in memory with pointer")'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个分别位于内存不同区域的盒子，其中较小的盒子附着在内存地址上，现在有一个最终盒子，其中包含第一个盒子的内存地址](../Images/5c91f35f98339346e7e797670973617c.png
    "内存中的三个值与指针")'
- en: 'Abstracting away the memory addresses, the list would appear as follows:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象掉内存地址，列表将如下所示：
- en: '![Three boxes with in separate areas of memory with smaller boxes with a final
    box where the one box points to another and another until the end of the boxes](../Images/de5d348bca1d7fe280064c56108281f8.png
    "three values in memory with pointer")'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![三个分别位于内存不同区域的盒子，其中较小的盒子指向一个最终盒子，其中一个盒子指向另一个盒子，直到盒子的末端](../Images/de5d348bca1d7fe280064c56108281f8.png
    "内存中的三个值与指针")'
- en: 'These boxes are called *nodes*. A *node* contains both an *item* and a pointer
    called *next*. In code, you can imagine a node as follows:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些盒子被称为*节点*。一个*节点*包含一个*项*和一个称为*next*的指针。在代码中，你可以想象一个节点如下：
- en: '[PRE5]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the item contained within this node is an integer called `number`.
    Second, a pointer to a node called `next` is included, which will point to another
    node somewhere in memory.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个节点包含的项是一个名为`number`的整数。其次，包含一个指向节点`next`的指针，它将指向内存中的另一个节点。
- en: 'We can recreate `list.c` to utilize a linked list:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以重新创建`list.c`以利用链表：
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, a `node` is defined as a `struct`. For each element of the list, memory
    for a `node` is allocated via `malloc` to the size of a node. `n->number` (or
    `n`’s number field) is assigned an integer. `n->next` (or `n`’s next field) is
    assigned `null`. Then, the node is placed at the start of the list at memory location
    `list`.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，将`node`定义为`struct`。对于列表的每个元素，通过`malloc`为节点分配内存，大小为一个节点的大小。将`n->number`（或`n`的数字字段）赋值为一个整数。将`n->next`（或`n`的`next`字段）赋值为`null`。然后，将节点放置在列表的起始位置，内存位置为`list`。
- en: Conceptually, we can imagine the process of creating a linked list. First, `node
    *list` is declared, but it is of a garbage value.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从概念上讲，我们可以想象创建链表的过程。首先，声明`node *list`，但它的值是垃圾值。
- en: '![One garbage value](../Images/b6d39804d8ad476803c5424ab7a67ced.png "linked
    list")'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![一个垃圾值](../Images/b6d39804d8ad476803c5424ab7a67ced.png "链表")'
- en: Next, a node called `n` is allocated in memory.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在内存中分配一个名为`n`的节点。
- en: '![One garbage value called n with another pointer called list](../Images/cc8488193d41cb930a2c7d468ad964e8.png
    "linked list")'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![一个名为n的垃圾值和一个名为list的指针](../Images/cc8488193d41cb930a2c7d468ad964e8.png "链表")'
- en: Next, the `number` of node is assigned the value `1`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将节点的`number`赋值为`1`。
- en: '![n pointing to a node with 1 as the number and garbage value as the next](../Images/d114de09528bf567bf1e0109531aabeb.png
    "linked list")'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![n指向一个数字为1且next值为垃圾值的节点](../Images/d114de09528bf567bf1e0109531aabeb.png "链表")'
- en: Next, the node’s `next` field is assigned `NULL`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将节点的`next`字段赋值为`NULL`。
- en: '![n pointing to a node with 1 as the number and null as the value of next](../Images/5d8e17eee341c7731473bb6b1c0b1ffd.png
    "linked list")'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![n指向一个数字为1且next值为null的节点](../Images/5d8e17eee341c7731473bb6b1c0b1ffd.png "链表")'
- en: Next, `list` is pointed at the memory location to where `n` points. `n` and
    `list` now point to the same place.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将`list`指向`n`指向的内存位置。现在`n`和`list`指向同一个地方。
- en: '![n and list both pointing to a node with 1 as the number and null as the value
    of next](../Images/7fec0d8902e51dee56555a8198859bf7.png "linked list")'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![n和list都指向一个数字为1且next值为null的节点](../Images/7fec0d8902e51dee56555a8198859bf7.png
    "链表")'
- en: A new node is then created. Both the `number` and `next` field are filled with
    garbage values.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后创建一个新的节点。`number`和`next`字段都填充了垃圾值。
- en: '![list pointing to a node with 1 as the number and null as the value of next
    and n pointing to a new node with garbage values](../Images/1ca5619a4434079950fcb951de63523b.png
    "linked list")'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![list指向一个数字为1且next值为null的节点，n指向一个具有垃圾值的新的节点](../Images/1ca5619a4434079950fcb951de63523b.png
    "链表")'
- en: The `number` value of `n`’s node (the new node) is updated to `2`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`的节点（新节点）的`number`值更新为`2`。'
- en: '![list pointing to a node with 1 as the number and null as the value of next
    and n pointing to a new node with 2 as the number and garbage as the next](../Images/68832f3dba6377d090d013ff705434ef.png
    "linked list")'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Also, the `next` field is updated as well.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![list pointing to a node with 1 as the number and null as the value of next
    and n pointing to a new node with 2 as the number and null as the next](../Images/fb7f5bd791741fafeaa38e51b56cc9b9.png
    "linked list")'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Most importantly, we do not want to lose our connection to any of these nodes
    lest they be lost forever. Accordingly, `n`’s `next` field is pointed to the same
    memory location as `list`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![list pointing to a node with 1 as the number and null as the value of next
    and n pointing to a new node with 2 as the number and null as the next](../Images/0dc8276fd04b08b3e1265e55c003f870.png
    "linked list")'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Finally, `list` is updated to point at `n`. We now have a linked list of two
    items.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![list pointing to a node with 1 as the number and next pointing to a node
    with an n pointing the same place the node with one points to a node with 2 as
    the number and null as the next](../Images/68fba35035561d4d0a30b32d1b9af319.png
    "linked list")'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Looking at our diagram of the list, we can see that the last number added is
    the first number that appears in the list. Accordingly, if we print the list in
    order, starting with the first node, the list will appear out of order.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can print the list in the correct order as follows:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that `node *ptr = list` creates a temporary variable that points at the
    same spot that `list` points to. The `while` prints what at the node `ptr` points
    to, and then updates `ptr` to point to the `next` node in the list.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, inserting into the list is always in the order of \(O(1)\),
    as it only takes a very small number of steps to insert at the front of a list.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the amount of time required to search this list, it is in the order
    of \(O(n)\), because in the worst case the entire list must always be searched
    to find an item. The time complexity for adding a new element to the list will
    depend on where that element is added. This is illustrated in the examples below.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists are not stored in a contiguous block of memory. They can grow as
    large as you wish, provided that enough system resources exist. The downside,
    however, is that more memory is required to keep track of the list instead of
    an array. For each element you must store not just the value of the element, but
    also a pointer to the next node. Further, linked lists cannot be indexed into
    like is possible in an array because we need to pass through the first \(n - 1\)
    elements to find the location of the \(n\)th element. Because of this, the list
    pictured above must be linearly searched. Binary search, therefore, is not possible
    in a list constructed as above.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Further, you could place numbers at the end of the list as illustrated in this
    code:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how this code *walks down* this list to find the end. When appending
    an element (adding to the end of the list) our code will run in \(O(n)\), as we
    have to go through our entire list before we can add the final element. Further,
    notice that a temporary variable called `next` is used to track `ptr->next`.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意代码是如何 *遍历* 这个列表来找到末尾的。当追加一个元素（添加到列表的末尾）时，我们的代码将以 \(O(n)\) 的时间复杂度运行，因为我们必须遍历整个列表才能添加最后一个元素。此外，注意使用了一个名为
    `next` 的临时变量来跟踪 `ptr->next`。
- en: 'Further, you could sort your list as items are added:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，你可以在添加项目时对列表进行排序：
- en: '[PRE9]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how this list is sorted as it is built. To insert an element in this
    specific order, our code will still run in \(O(n)\) for each insertion, as in
    the worst case we will have to look through all current elements.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这个列表是如何在构建过程中排序的。为了以这种特定顺序插入元素，我们的代码在每次插入时仍将以 \(O(n)\) 的时间复杂度运行，因为在最坏的情况下，我们可能需要查看所有当前元素。
- en: This code may seem complicated. However, notice that with pointers and the syntax
    above, we can stitch data together in different places in memory.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码可能看起来很复杂。然而，请注意，使用指针和上面的语法，我们可以在内存的不同位置拼接数据。
- en: Trees
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树
- en: Arrays offer contiguous memory that can be searched quickly. Arrays also offered
    the opportunity to engage in binary search.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组提供连续的内存，可以快速搜索。数组还提供了进行二分搜索的机会。
- en: Could we combine the best of both arrays and linked lists?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否结合数组和链表的最佳之处？
- en: '*Binary search trees* are another data structure that can be used to store
    data more efficiently so that it can be searched and retrieved.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二叉搜索树* 是另一种数据结构，可以更有效地存储数据，以便进行搜索和检索。'
- en: You can imagine a sorted sequence of numbers.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以想象一个有序的数字序列。
- en: '![1 2 3 4 5 6 7 in boxes next to each other](../Images/4f4a50b0fa906dd640e7d1e2beda073d.png
    "tree")'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![1 2 3 4 5 6 7 在相邻的框中](../Images/4f4a50b0fa906dd640e7d1e2beda073d.png "树")'
- en: Imagine then that the center value becomes the top of a tree. Those that are
    less than this value are placed to the left. Those values that are more than this
    value are to the right.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下，中心值成为树的顶部。那些小于这个值的放在左边。那些大于这个值的放在右边。
- en: '![1 2 3 4 5 6 7 in boxes arranged in a hierarchy 4 is at the top 3 and 5 are
    below that and 1 2 6 7 are below those](../Images/7ad7e3efe6b11ff81034b24b6f752802.png
    "tree")'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![1 2 3 4 5 6 7 在按层次排列的框中，4 在顶部，3 和 5 在其下方，1、2、6 和 7 在这些箭头下方](../Images/7ad7e3efe6b11ff81034b24b6f752802.png
    "树")'
- en: Pointers can then be used to point to the correct location of each area of memory
    such that each of these nodes can be connected.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后可以使用指针指向每个内存区域的正确位置，这样每个节点都可以连接起来。
- en: '![1 2 3 4 5 6 7 in boxes arranged in a hierarchy 4 is at the top 3 and 5 are
    below that and 1 2 6 7 are below those arrows connect them in a tree formation](../Images/6879c95a0b436bd34b2f7c1748ca5ad8.png
    "tree")'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![1 2 3 4 5 6 7 在按层次排列的框中，4 在顶部，3 和 5 在其下方，1、2、6 和 7 在这些箭头下方，它们以树状结构连接](../Images/6879c95a0b436bd34b2f7c1748ca5ad8.png
    "树")'
- en: In code, this can be implemented as follows.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中，可以这样实现。
- en: '[PRE10]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice this search function begins by going to the location of `tree`. Then,
    it uses recursion to search for `number`. The `free_tree` function recursively
    frees the tree. `print_tree` recursively prints the tree.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这个搜索功能首先会去 `tree` 的位置。然后，它使用递归来搜索 `number`。`free_tree` 函数递归地释放树。`print_tree`
    函数递归地打印树。
- en: A tree like the above offers dynamism that an array does not offer. It can grow
    and shrink as we wish.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如上所示的树提供了一种数组不具备的动态性。它可以按我们的意愿增长和缩小。
- en: Further, this structure offers a search time of \(O(log n)\) when the tree is
    balanced.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，当树平衡时，这个结构提供 \(O(log n)\) 的搜索时间。
- en: Dictionaries
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 词典
- en: '*Dictionaries* are another data structure.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*词典* 是另一种数据结构。'
- en: Dictionaries, like actual book-form dictionaries that have a word and a definition,
    have a *key* and a *value*.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词典，就像实际的书本形式的词典，有单词和定义，有 *键* 和 *值*。
- en: The *holy grail* of algorithmic time complexity is \(O(1)\) or *constant time*.
    That is, the ultimate is for access to be instantaneous.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法时间复杂度的 *圣杯* 是 \(O(1)\) 或 *常数时间*。也就是说，最终目标是访问能够瞬间完成。
- en: '![a graph of various time complexities where O of log n is second best and
    O of 1 is best](../Images/be842bae9176b8c123def3e311e235e9.png "time complexity")'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![各种时间复杂性的图表，其中 O(log n) 是次优，O(1) 是最佳](../Images/be842bae9176b8c123def3e311e235e9.png
    "时间复杂度")'
- en: Dictionaries can offer this speed of access through hashing.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词典可以通过散列提供这种访问速度。
- en: Hashing and Hash Tables
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散列和散列表
- en: '*Hashing* is the idea of taking a value and being able to output a value that
    becomes a shortcut to it later.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*散列*的想法是取一个值并能够输出一个值，这个值可以成为以后访问它的快捷方式。'
- en: 'For example, hashing *apple* may hash as a value of `1`, and *berry* may be
    hashed as `2`. Therefore, finding *apple* is as easy as asking the *hash* algorithm
    where *apple* is stored. While not ideal in terms of design, ultimately, putting
    all *a*’s in one bucket and *b*’s in another, this concept of *bucketizing* hashed
    values illustrates how you can use this concept: a hashed value can be used to
    shortcut finding such a value.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，散列*苹果*可能散列为一个值为`1`，而*浆果*可能散列为`2`。因此，找到*苹果*就像询问*哈希*算法*苹果*存储在哪里一样简单。虽然在设计上不是理想的，但最终，将所有*a*放在一个桶中，将*b*放在另一个桶中，这种*桶化*散列值的理念说明了你可以如何使用这个概念：散列值可以用来简化查找这样的值。
- en: A *hash function* is an algorithm that reduces a larger value to something small
    and predictable. Generally, this function takes in an item you wish to add to
    your hash table, and returns an integer representing the array index in which
    the item should be placed.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*散列函数*是一种将较大值减少到较小且可预测的值的算法。通常，这个函数接收一个你希望添加到你的哈希表中的项目，并返回一个表示该项目应放置的数组索引的整数。'
- en: A *hash table* is a fantastic combination of both arrays and linked lists. When
    implemented in code, a hash table is an *array* of *pointers* to *node*s.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈希表*是数组和链表的绝佳组合。在代码实现中，哈希表是一个指向*节点*的*指针*数组。'
- en: 'A hash table could be imagined as follows:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以这样想象哈希表：
- en: '![a vertical column of 26 boxes one for each letter of the alphabet](../Images/fab363539963a53f25e01cb4eeb1b422.png
    "alphabet")'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![一个垂直的26个盒子组成的列，每个盒子代表字母表中的一个字母](../Images/fab363539963a53f25e01cb4eeb1b422.png
    "字母表")'
- en: Notice that this is an array that is assigned each value of the alphabet.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这是一个分配给字母表每个值的数组。
- en: 'Then, at each location of the array, a linked list is used to track each value
    being stored there:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在数组的每个位置，使用链表来跟踪存储在该位置的每个值：
- en: '![a vertical column of 26 boxes one for each letter of the alphabet with various
    names from the mario universe emerging to the right luigi is with l and mario
    is with m](../Images/3b7dd601e46bc05746e82d7ffc9b5b61.png "alphabet")'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![一个垂直的26个盒子组成的列，每个盒子代表字母表中的一个字母，来自马里奥宇宙的各种名称从右边出现，路易吉与l一起，马里奥与m一起](../Images/3b7dd601e46bc05746e82d7ffc9b5b61.png
    "字母表")'
- en: '*Collisions* are when you add values to the hash table, and something already
    exists at the hashed location. In the above, collisions are simply appended to
    the end of the list.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冲突*是在你向哈希表中添加值时，已经存在散列位置上的值。在上面的例子中，冲突只是简单地附加到列表的末尾。'
- en: 'Collisions can be reduced by better programming your hash table and hash algorithm.
    You can imagine an improvement upon the above as follows:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更好地编程你的哈希表和哈希算法可以减少冲突。你可以想象对上面的改进如下：
- en: '![a vertical column of various boxes arranged by L A K and L I N with Lakitu
    emerging from L A K and link emerging from L I N](../Images/e51a60f34aa7b92a1cc29b25c0a7f981.png
    "alphabet")'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![由 L A K 和 L I N 安排的各种盒子组成的垂直列，Lakitu 从 L A K 中出现，链接从 L I N 中出现](../Images/e51a60f34aa7b92a1cc29b25c0a7f981.png
    "字母表")'
- en: 'Consider the following example of a hash algorithm:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑以下哈希算法的示例：
- en: '![luigi being given to a hash algorithm outputting 11](../Images/0696a8d8e7d78370dcbaf5c00100a9d1.png
    "hashing")'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![路易吉被输入到一个哈希算法中，输出为11](../Images/0696a8d8e7d78370dcbaf5c00100a9d1.png "散列")'
- en: 'This could be implemented in code as follows:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可以在代码中如下实现：
- en: '[PRE11]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how the hash function returns the value of `toupper(word[0]) - 'A'`.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意哈希函数返回`toupper(word[0]) - 'A'`的值。
- en: You, as the programmer, have to make a decision about the advantages of using
    more memory to have a large hash table and potentially reducing search time or
    using less memory and potentially increasing search time.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为程序员，你必须决定使用更多内存以拥有大哈希表并可能减少搜索时间，还是使用更少的内存并可能增加搜索时间的好处。
- en: This structure offers a search time of \(O(n)\).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种结构提供了 \(O(n)\) 的搜索时间。
- en: Tries
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Trie
- en: '*Tries* are another form of data structure. Tries are trees of arrays.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Trie*是另一种数据结构。Trie是数组的树。'
- en: '*Tries* are always searchable in constant time.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Trie*总是可以在常数时间内进行搜索。'
- en: One downside to *Tries* is that they tend to take up a large amount of memory.
    Notice that we need \(26 \times 4 = 104\) `node`s just to store *Toad*!
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Trie*的一个缺点是它们往往需要占用大量的内存。注意，我们只需要 \(26 \times 4 = 104\) 个`节点`来存储*青蛙*！'
- en: '*Toad* would be stored as follows:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*青蛙*将如下存储：'
- en: '![toad being spelled with one letter at a time where one letter is associated
    with one list T from one list O from another and so on ](../Images/dde5f80eef85bf6c2a0effa25843996d.png
    "tries")'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![逐个字母拼写青蛙，每个字母与一个列表 T 从另一个列表 O 中关联，依此类推](../Images/dde5f80eef85bf6c2a0effa25843996d.png
    "tries")'
- en: '*Tom* would then be stored as follows:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*汤姆* 将按以下方式存储：'
- en: '![toad being spelled with one letter at a time where one letter is associated
    with one list T from one list O from another and so on and tom being spelled similarly
    where toad and tom share a two common letters T and O](../Images/d87c3fc3a156b4abe5e23b86af845b89.png
    "tries")'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![逐个字母拼写青蛙，每个字母与一个列表 T 从另一个列表 O 中关联，依此类推，以及类似地拼写汤姆，其中青蛙和汤姆共享两个共同字母 T 和 O](../Images/d87c3fc3a156b4abe5e23b86af845b89.png
    "tries")'
- en: This structure offers a search time of \(O(1)\).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种结构提供了 \(O(1)\) 的搜索时间。
- en: The downside of this structure is how many resources are required to use it.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种结构的缺点在于使用它需要多少资源。
- en: Summing Up
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, you learned about using pointers to build new data structures.
    Specifically, we delved into…
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何使用指针构建新的数据结构。具体来说，我们深入探讨了...
- en: Data structures
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构
- en: Stacks and queues
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和队列
- en: Resizing arrays
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整数组大小
- en: Linked lists
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表
- en: Dictionaries
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Tries
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tries
- en: See you next time!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 次次见！
