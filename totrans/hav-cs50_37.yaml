- en: Lecture 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cs50.harvard.edu/python/notes/9/](https://cs50.harvard.edu/python/notes/9/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Et Cetera](#et-cetera)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`set`](#set)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Global Variables](#global-variables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Constants](#constants)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type Hints](#type-hints)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Docstrings](#docstrings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`argparse`](#argparse)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unpacking](#unpacking)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`args` and `kwargs`](#args-and-kwargs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`map`](#map)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List Comprehensions](#list-comprehensions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`filter`](#filter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dictionary Comprehensions](#dictionary-comprehensions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`enumerate`](#enumerate)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Generators and Iterators](#generators-and-iterators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Congratulations!](#congratulations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[This was CS50!](#this-was-cs50)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Et Cetera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the many past lessons, we have covered so much related to Python!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this lesson, we will be focusing upon many of the “et cetera” items not previously
    discussed. “Et cetera” literally means “and the rest”!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indeed, if you look at the Python documentation, you will find quite “the rest”
    of other features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In math, a set would be considered a set of numbers without any duplicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we have a list of dictionaries, each being a student. An empty list
    called `houses` is created. We iterate through each `student` in `students`. If
    a student’s `house` is not in `houses`, we append to our list of `houses`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It turns out we can use the built-in `set` features to eliminate duplicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how no checking needs to be included to ensure there are no duplicates.
    The `set` object takes care of this for us automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [`set`](https://docs.python.org/3/library/stdtypes.html#set).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In other programming languages, there is the notion of global variables that
    are accessible to any function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can leverage this ability within Python. In the text editor window, code
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we create a global variable called `balance`, outside of any function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since no errors are presented by executing the code above, you’d think all
    is well. However, it is not! In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we now add the functionality to add and withdraw funds to and from
    `balance`. However, executing this code, we are presented with an error! We see
    an error called `UnboundLocalError`. You might be able to guess that, at least
    in the way we’ve currently coded `balance` and our `deposit` and `withdraw` functions,
    we can’t reassign it a new value inside a function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To interact with a global variable inside a function, the solution is to use
    the `global` keyword. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice how the `global` keyword tells each function that `balance` does not
    refer to a local variable: instead, it refers to the global variable we originally
    placed at the top of our code. Now, our code functions!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Utilizing our powers from our experience with object-oriented programming,
    we can modify our code to use a class instead of a global variable. In the text
    editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we use `account = Account()` to create an account. Classes allow
    us to solve this issue of needing a global variable more cleanly because these
    instance variables are accessible to all the methods of this class utilizing `self`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Generally speaking, global variables should be used quite sparingly, if at all!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some languages allow you to create variables that are unchangeable, called “constants”.
    Constants allow one to program defensively and reduce the opportunities for important
    values to be altered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice `MEOWS` is our constant in this case. Constants are typically denoted
    by capital variable names and are placed at the top of our code. Though this *looks*
    like a constant, in reality, Python actually has no mechanism to prevent us from
    changing that value within our code! Instead, you’re on the honor system: if a
    variable name is written in all caps, just don’t change it!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'One can create a class “constant”, now in quotes because we know Python doesn’t
    quite support “constants”. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because `MEOWS` is defined outside of any particular class method, all of them
    have access to that value via `Cat.MEOWS`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type Hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In other programming languages, one expresses explicitly what variable type
    you want to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw earlier in the course, Python does not require the explicit declaration
    of types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nevertheless, it’s good practice need to ensure all of your variables are of
    the right type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mypy` is a program that can help you test to make sure all your variables
    are of the right type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can install `mypy` by executing in your terminal window: `pip install mypy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You may already see that `number = input("Number: )"` returns a `string`, not
    an `int`. But `meow` will likely want an `int`!'
  prefs: []
  type: TYPE_NORMAL
- en: 'A type hint can be added to give Python a hint of what type of variable `meow`
    should expect. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice, though, that our program still throws an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After installing `mypy`, execute `mypy meows.py` in the terminal window. `mypy`
    will provide some guidance about how to fix this error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can annotate all your variables. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `number` is now provided a type hint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Again, executing `mypy meows.py` in the terminal window provides much more specific
    feedback to you, the programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can fix our final error by coding as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how running `mypy` now produces no errors because we cast our input to
    an integer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s introduce a new error by assuming that `meow` will return to us a string,
    or `str`. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the `meow` function has only a side effect. Because we only attempt
    to print “meow”, not return a value, an error is thrown when we try to store the
    return value of `meow` in `meows`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can further use type hints to check for errors, this time annotating the
    return values of functions. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the notation `-> None` tells `mypy` that there is no return value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can modify our code to return a string if we wish:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we store in `meows` multiple `str`s. Running `mypy` produces no errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [Type Hints](https://docs.python.org/3/library/typing.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about [`mypy`](https://mypy.readthedocs.io/) through the
    program’s own documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docstrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A standard way of commenting your function’s purpose is to use a docstring.
    In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the three double quotes designate what the function does.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can use docstrings to standardize how you document the features of a function.
    In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how multiple docstring arguments are included. For example, it describes
    the parameters taken by the function and what is returned by the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Established tools, such as [Sphinx](https://www.sphinx-doc.org/en/master/index.html),
    can be used to parse docstrings and automatically create documentation for us
    in the form of web pages and PDF files such that you can publish and share with
    others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [docstrings](https://peps.python.org/pep-0257/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argparse`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we want to use command-line arguments in our program. In the text editor
    window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `sys` is imported, from which we get access to `sys.argv`, an array
    of command-line arguments given to our program when run. We can use several `if`
    statements to check whether the user has run our program properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s assume that this program will be getting much more complicated. How could
    we check all the arguments that could be inserted by the user? We might give up
    if we have more than a few command-line arguments!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Luckily, `argparse` is a library that handles all the parsing of complicated
    strings of command-line arguments. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `argparse` is imported instead of `sys`. An object called `parser`
    is created from an `ArgumentParser` class. That class’s `add_argument` method
    is used to tell `argparse` what arguments we should expect from the user when
    they run our program. Finally, running the parser’s `parse_args` method ensures
    that all of the arguments have been included properly by the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also program more cleanly, such that our user can get some information
    about the proper usage of our code when they fail to use the program correctly.
    In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the user is provided some documentation. Specifically, a `help` argument
    is provided. Now, if the user executes `python meows.py --help` or `-h`, the user
    will be presented with some clues about how to use this program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can further improve this program. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how not only is help documentation included, but you can provide a `default`
    value when no arguments are provided by the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [`argparse`](https://docs.python.org/3/library/argparse.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unpacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Would it not be nice to be able to split a single variable into two variables?
    In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this program tries to get a user’s first name by naively splitting
    on a single space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It turns out there are other ways to unpack variables. You can write more powerful
    and elegant code by understanding how to unpack variables in seemingly more advanced
    ways. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this returns the total value of Knuts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'What if we wanted to store our coins in a list? In the text editor window,
    code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how a list called `coins` is created. We can pass each value in by indexing
    using `0`, `1`, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is getting quite verbose. Wouldn’t it be nice if we could simply pass the
    list of coins to our function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable the possibility of passing the entire list, we can use unpacking.
    In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how a `*` unpacks the sequence of the list of coins and passes in each
    of its individual elements to `total`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Suppose that we could pass in the names of the currency in any order? In the
    text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this still calculates correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you start talking about “names” and “values,” dictionaries might start
    coming to mind! You can implement this as a dictionary. In the text editor window,
    code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how a dictionary called `coins` is provided. We can index into it using
    keys, such as “galleons” or “sickles”.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since the `total` function expects three arguments, we cannot pass in a dictionary.
    We can use unpacking to help with this. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `**` allows you to unpack a dictionary. When unpacking a dictionary,
    it provides both the keys and values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`args` and `kwargs`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall the `print` documentation we looked at earlier in this course:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`args` are positional arguments, such as those we provide to print like `print("Hello",
    "World")`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kwargs` are named arguments, or “keyword arguments”, such as those we provide
    to print like `print(end="")`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we see in the prototype for the `print` function above, we can tell our
    function to expect a presently unknown number positional arguments. We can also
    tell it to expect a presently unknown number of keyword arguments. In the text
    editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how executing this code will be printed as positional arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can even pass in named arguments. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the named values are provided in the form of a dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Thinking about the `print` function above, you can see how `*objects` takes
    any number of positional arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [`print`](https://docs.python.org/3/library/functions.html#print).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Early on, we began with procedural programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We later revealed Python is an object oriented programming language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We saw hints of functional programming, where functions have side effects without
    a return value. We can illustrate this in the text editor window, type `code yell.py`
    and code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the `yell` function is simply yelled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Wouldn’t it be nice to yell a list of unlimited words? Modify your code as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice we accumulate the uppercase words, iterating over each of the words and
    “uppercasing” them. The uppercase list is printed utilizing the `*` to unpack
    it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Removing the brackets, we can pass the words in as arguments. In the text editor
    window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `*words` allows for many arguments to be taken by the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`map` allows you to map a function to a sequence of values. In practice, we
    can code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `map` takes two arguments. First, it takes a function we want applied
    to every element of a list. Second, it takes that list itself, to which we’ll
    apply the aforementioned function. Hence, all words in `words` will be handed
    to the `str.upper` function and returned to `uppercased`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [`map`](https://docs.python.org/3/library/functions.html#map).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: List comprehensions allow you to create a list on the fly in one elegant one-liner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can implement this in our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how instead of using `map`, we write a Python expression within square
    brackets. For each argument, `.upper` is applied to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Taking this concept further, let’s pivot toward another program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, type `code gryffindors.py` and code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice we have a conditional while we’re creating our list. *If* the student’s
    house is Gryffindor, we append the student to the list of names. Finally, we print
    all the names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'More elegantly, we can simplify this code with a list comprehension as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the list comprehension is on a single line!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`filter`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Python’s `filter` function allows us to return a subset of a sequence
    for which a certain condition is true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how a function called `is_gryffindor` is created. This is our filtering
    function that will take a student `s`, and return `True` or `False` depending
    on whether the student’s house is Gryffindor. You can see the new `filter` function
    takes two arguments. First, it takes the function that will be applied to each
    element in a sequence—in this case, `is_gryffindor`. Second, it takes the sequence
    to which it will apply the filtering function—in this case, `students`. In `gryffindors`,
    we should see only those students who are in Gryffindor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`filter` can also use lambda functions as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the same list of students is provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [`filter`](https://docs.python.org/3/library/functions.html#filter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can apply the same idea behind list comprehensions to dictionaries. In the
    text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this code doesn’t (yet!) use any comprehensions. Instead, it follows
    the same paradigms we have seen before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now apply dictionary comprehensions by modifying our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how all the prior code is simplified into a single line where the structure
    of the dictionary is provided for each `student` in `students`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can even simplify further as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the dictionary will be constructed with key-value pairs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`enumerate`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We may wish to provide some ranking of each student. In the text editor window,
    code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how each student is enumerated when running this code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Utilizing enumeration, we can do the same:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how enumerate presents the index and the value of each `student`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [`enumerate`](https://docs.python.org/3/library/functions.html#enumerate).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators and Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, there is a way to protect against your system running out of resources
    the problems they are addressing become too large.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the United States, it’s customary to “count sheep” in one’s mind when one
    is having a hard time falling asleep.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, type `code sleep.py` and code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how this program will count the number of sheep you ask of it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can make our program more sophisticated by adding a `main` function by coding
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how a `main` function is provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have been getting into the habit of abstracting away parts of our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can call a sheep function by modifying our code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the `main` function does the iteration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can provide the `sheep` function more abilities. In the text editor window,
    code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we create a flock of sheep and return the `flock`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Executing our code, you might try different numbers of sheep such as `10`, `1000`,
    and `10000`. What if you asked for `1000000` sheep, your program might completely
    hang or crash. Because you have attempted to generate a massive list of sheep,
    your computer may be struggling to complete the computation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `yield` generator can solve this problem by returning a small bit of the
    results at a time. In the text editor window, code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `yield` provides only one value at a time while the `for` loop keeps
    working.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [generators](https://docs.python.org/3/howto/functional.html#generators).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [iterators](https://docs.python.org/3/howto/functional.html#iterators).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you exit from this course, you have more of a mental model and toolbox to
    address programming-related problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, you learned about functions and variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, you learned about conditionals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, you learned about loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourth, you learned about exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fifth, you learned about libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sixth, you learned about unit tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seventh, you learned about file I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eighth, you learned about regular expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most recently, you learned about object-oriented programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today, you learned about many other tools you can use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This was CS50!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a final program together, type `code say.py` in your terminal window
    and code as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how running this program provides you with a spirited send-off.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our great hope is that you will use what you learned in this course to address
    real problems in the world, making our globe a better place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This was CS50!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
