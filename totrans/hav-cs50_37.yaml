- en: Lecture 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲座 9
- en: 原文：[https://cs50.harvard.edu/python/notes/9/](https://cs50.harvard.edu/python/notes/9/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cs50.harvard.edu/python/notes/9/](https://cs50.harvard.edu/python/notes/9/)
- en: '[Et Cetera](#et-cetera)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[等等](#et-cetera)'
- en: '[`set`](#set)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`set`](#set)'
- en: '[Global Variables](#global-variables)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[全局变量](#global-variables)'
- en: '[Constants](#constants)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[常量](#constants)'
- en: '[Type Hints](#type-hints)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型提示](#type-hints)'
- en: '[Docstrings](#docstrings)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文档字符串](#docstrings)'
- en: '[`argparse`](#argparse)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`argparse`](#argparse)'
- en: '[Unpacking](#unpacking)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解包](#unpacking)'
- en: '[`args` and `kwargs`](#args-and-kwargs)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`args` 和 `kwargs`](#args-and-kwargs)'
- en: '[`map`](#map)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`map`](#map)'
- en: '[List Comprehensions](#list-comprehensions)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列表推导式](#list-comprehensions)'
- en: '[`filter`](#filter)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`filter`](#filter)'
- en: '[Dictionary Comprehensions](#dictionary-comprehensions)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字典推导式](#dictionary-comprehensions)'
- en: '[`enumerate`](#enumerate)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`enumerate`](#enumerate)'
- en: '[Generators and Iterators](#generators-and-iterators)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[生成器和迭代器](#generators-and-iterators)'
- en: '[Congratulations!](#congratulations)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[恭喜！](#congratulations)'
- en: '[This was CS50!](#this-was-cs50)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[这是 CS50！](#this-was-cs50)'
- en: Et Cetera
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等等
- en: Over the many past lessons, we have covered so much related to Python!
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过去的许多课程中，我们已经涵盖了与 Python 相关的许多内容！
- en: In this lesson, we will be focusing upon many of the “et cetera” items not previously
    discussed. “Et cetera” literally means “and the rest”!
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本课中，我们将关注许多之前未讨论的“等等”项目。“Et cetera”字面意思是“等等”。
- en: Indeed, if you look at the Python documentation, you will find quite “the rest”
    of other features.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 的确，如果你查看 Python 文档，你会找到许多其他功能。
- en: '`set`'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`set`'
- en: In math, a set would be considered a set of numbers without any duplicates.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数学中，一个集合会被认为是一个没有重复数字的数字集合。
- en: 'In the text editor window, code as follows:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本编辑器窗口中，按照以下方式编写代码：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how we have a list of dictionaries, each being a student. An empty list
    called `houses` is created. We iterate through each `student` in `students`. If
    a student’s `house` is not in `houses`, we append to our list of `houses`.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们有一个字典列表，每个字典代表一个学生。创建了一个名为 `houses` 的空列表。我们遍历 `students` 中的每个 `student`。如果一个学生的
    `house` 不在 `houses` 中，我们就将其添加到我们的 `houses` 列表中。
- en: It turns out we can use the built-in `set` features to eliminate duplicates.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果表明，我们可以使用内置的 `set` 功能来消除重复项。
- en: 'In the text editor window, code as follows:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本编辑器窗口中，按照以下方式编写代码：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how no checking needs to be included to ensure there are no duplicates.
    The `set` object takes care of this for us automatically.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们不需要包含任何检查来确保没有重复项。`set` 对象会自动为我们处理这个问题。
- en: You can learn more in Python’s documentation of [`set`](https://docs.python.org/3/library/stdtypes.html#set).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 Python 的文档中了解更多关于 `set` 的信息：[Python 的 `set` 文档](https://docs.python.org/3/library/stdtypes.html#set)。
- en: Global Variables
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: In other programming languages, there is the notion of global variables that
    are accessible to any function.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他编程语言中，存在全局变量的概念，这些变量可以被任何函数访问。
- en: 'We can leverage this ability within Python. In the text editor window, code
    as follows:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用 Python 中的这一功能。在文本编辑器窗口中，按照以下方式编写代码：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how we create a global variable called `balance`, outside of any function.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们如何在任何函数之外创建一个名为 `balance` 的全局变量。
- en: 'Since no errors are presented by executing the code above, you’d think all
    is well. However, it is not! In the text editor window, code as follows:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于执行上述代码没有出现错误，你可能会认为一切正常。然而，事实并非如此！在文本编辑器窗口中，按照以下方式编写代码：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how we now add the functionality to add and withdraw funds to and from
    `balance`. However, executing this code, we are presented with an error! We see
    an error called `UnboundLocalError`. You might be able to guess that, at least
    in the way we’ve currently coded `balance` and our `deposit` and `withdraw` functions,
    we can’t reassign it a new value inside a function.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们现在添加了向 `balance` 添加和提取资金的功能。然而，执行此代码时，我们遇到了一个错误！我们看到一个名为 `UnboundLocalError`
    的错误。你可能能够猜到，至少在我们当前编写的 `balance` 和 `deposit` 以及 `withdraw` 函数的方式中，我们无法在函数内部重新分配它的新值。
- en: 'To interact with a global variable inside a function, the solution is to use
    the `global` keyword. In the text editor window, code as follows:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在函数内部与全局变量交互，解决方案是使用 `global` 关键字。在文本编辑器窗口中，按照以下方式编写代码：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice how the `global` keyword tells each function that `balance` does not
    refer to a local variable: instead, it refers to the global variable we originally
    placed at the top of our code. Now, our code functions!'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `global` 关键字告诉每个函数，`balance` 并不指向一个局部变量：相反，它指向我们在代码顶部最初放置的全局变量。现在，我们的代码可以正常工作了！
- en: 'Utilizing our powers from our experience with object-oriented programming,
    we can modify our code to use a class instead of a global variable. In the text
    editor window, code as follows:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用我们从面向对象编程中获得的经验，我们可以修改我们的代码，使用类而不是全局变量。在文本编辑器窗口中，编写以下代码：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how we use `account = Account()` to create an account. Classes allow
    us to solve this issue of needing a global variable more cleanly because these
    instance variables are accessible to all the methods of this class utilizing `self`.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们如何使用 `account = Account()` 来创建一个账户。类允许我们更干净地解决需要全局变量的这个问题，因为这些实例变量可以通过
    `self` 访问本类的所有方法。
- en: Generally speaking, global variables should be used quite sparingly, if at all!
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般而言，全局变量应该非常谨慎地使用，如果必须使用的话！
- en: Constants
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: Some languages allow you to create variables that are unchangeable, called “constants”.
    Constants allow one to program defensively and reduce the opportunities for important
    values to be altered.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些语言允许您创建不可更改的变量，称为“常量”。常量允许程序员进行防御性编程，并减少重要值被更改的机会。
- en: 'In the text editor window, code as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本编辑器窗口中，编写以下代码：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice `MEOWS` is our constant in this case. Constants are typically denoted
    by capital variable names and are placed at the top of our code. Though this *looks*
    like a constant, in reality, Python actually has no mechanism to prevent us from
    changing that value within our code! Instead, you’re on the honor system: if a
    variable name is written in all caps, just don’t change it!'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，`MEOWS` 是我们的常量。常量通常用大写变量名表示，并放置在代码的顶部。尽管这 *看起来* 像一个常量，但实际上，Python
    实际上没有机制来阻止我们在代码中更改该值！相反，您需要遵守诚信原则：如果变量名全部大写，就请不要更改它！
- en: 'One can create a class “constant”, now in quotes because we know Python doesn’t
    quite support “constants”. In the text editor window, code as follows:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以创建一个名为“常量”的类，现在我们用引号括起来，因为我们知道 Python 并不完全支持“常量”。在文本编辑器窗口中，编写以下代码：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because `MEOWS` is defined outside of any particular class method, all of them
    have access to that value via `Cat.MEOWS`.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为 `MEOWS` 是在任何一个特定类方法之外定义的，所以所有这些方法都可以通过 `Cat.MEOWS` 访问该值。
- en: Type Hints
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提示
- en: In other programming languages, one expresses explicitly what variable type
    you want to use.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他编程语言中，您需要明确表达您想要使用的变量类型。
- en: As we saw earlier in the course, Python does not require the explicit declaration
    of types.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们在课程中较早看到的，Python 不需要显式声明类型。
- en: Nevertheless, it’s good practice need to ensure all of your variables are of
    the right type.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，确保所有变量都是正确的类型是一个好的实践。
- en: '`mypy` is a program that can help you test to make sure all your variables
    are of the right type.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mypy` 是一个程序，可以帮助您测试以确保所有变量都是正确的类型。'
- en: 'You can install `mypy` by executing in your terminal window: `pip install mypy`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过在终端窗口中执行以下命令来安装 `mypy`：`pip install mypy`。
- en: 'In the text editor window, code as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器窗口中，编写以下代码：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You may already see that `number = input("Number: )"` returns a `string`, not
    an `int`. But `meow` will likely want an `int`!'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '您可能已经看到，`number = input("Number: )"` 返回了一个 `string`，而不是 `int`。但 `meow` 很可能需要一个
    `int`！'
- en: 'A type hint can be added to give Python a hint of what type of variable `meow`
    should expect. In the text editor window, code as follows:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以添加类型提示来给 Python 提示 `meow` 应该期望的变量类型。在文本编辑器窗口中，编写以下代码：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice, though, that our program still throws an error.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，尽管如此，我们的程序仍然会抛出错误。
- en: After installing `mypy`, execute `mypy meows.py` in the terminal window. `mypy`
    will provide some guidance about how to fix this error.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 `mypy` 后，在终端窗口中执行 `mypy meows.py`。`mypy` 将提供一些关于如何修复此错误的指导。
- en: 'You can annotate all your variables. In the text editor window, code as follows:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以对所有变量进行注释。在文本编辑器窗口中，编写以下代码：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how `number` is now provided a type hint.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，现在 `number` 被提供了一个类型提示。
- en: Again, executing `mypy meows.py` in the terminal window provides much more specific
    feedback to you, the programmer.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，在终端窗口中执行 `mypy meows.py` 可以为您提供更具体的反馈。
- en: 'We can fix our final error by coding as follows:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式修复我们的最终错误：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how running `mypy` now produces no errors because we cast our input to
    an integer.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，现在运行 `mypy` 没有错误，因为我们已经将输入转换为整数。
- en: 'Let’s introduce a new error by assuming that `meow` will return to us a string,
    or `str`. In the text editor window, code as follows:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们通过假设 `meow` 将返回一个字符串，或 `str`，来引入一个新的错误。在文本编辑器窗口中，编写以下代码：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how the `meow` function has only a side effect. Because we only attempt
    to print “meow”, not return a value, an error is thrown when we try to store the
    return value of `meow` in `meows`.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`meow`函数只有一个副作用。因为我们只尝试打印“meow”，而不是返回一个值，所以当我们尝试将`meow`的返回值存储在`meows`中时，会抛出一个错误。
- en: 'We can further use type hints to check for errors, this time annotating the
    return values of functions. In the text editor window, code as follows:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以进一步使用类型提示来检查错误，这次注释函数的返回值。在文本编辑器窗口中，代码如下：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how the notation `-> None` tells `mypy` that there is no return value.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`-> None`的表示法告诉`mypy`没有返回值。
- en: 'We can modify our code to return a string if we wish:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们希望返回一个字符串，我们可以修改我们的代码：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how we store in `meows` multiple `str`s. Running `mypy` produces no errors.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何在`meows`中存储多个`str`。运行`mypy`不会产生错误。
- en: You can learn more in Python’s documentation of [Type Hints](https://docs.python.org/3/library/typing.html).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的[Type Hints](https://docs.python.org/3/library/typing.html)文档中了解更多信息。
- en: You can learn more about [`mypy`](https://mypy.readthedocs.io/) through the
    program’s own documentation.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过程序的自身文档了解更多关于[`mypy`](https://mypy.readthedocs.io/)的信息。
- en: Docstrings
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docstrings
- en: 'A standard way of commenting your function’s purpose is to use a docstring.
    In the text editor window, code as follows:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用docstring来注释函数的目的是一种标准做法。在文本编辑器窗口中，代码如下：
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice how the three double quotes designate what the function does.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意三个双引号指定了函数的功能。
- en: 'You can use docstrings to standardize how you document the features of a function.
    In the text editor window, code as follows:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用docstrings来标准化你如何记录函数的特性。在文本编辑器窗口中，代码如下：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how multiple docstring arguments are included. For example, it describes
    the parameters taken by the function and what is returned by the function.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到包含了多个docstring参数。例如，它描述了函数接受的参数以及函数返回的内容。
- en: Established tools, such as [Sphinx](https://www.sphinx-doc.org/en/master/index.html),
    can be used to parse docstrings and automatically create documentation for us
    in the form of web pages and PDF files such that you can publish and share with
    others.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立的标准工具，如[Sphinx](https://www.sphinx-doc.org/en/master/index.html)，可以用来解析docstrings，并自动以网页和PDF文件的形式为我们创建文档，这样你就可以发布和与他人分享。
- en: You can learn more in Python’s documentation of [docstrings](https://peps.python.org/pep-0257/).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的[docstrings](https://peps.python.org/pep-0257/)文档中了解更多信息。
- en: '`argparse`'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`argparse`'
- en: 'Suppose we want to use command-line arguments in our program. In the text editor
    window, code as follows:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们想在程序中使用命令行参数。在文本编辑器窗口中，代码如下：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how `sys` is imported, from which we get access to `sys.argv`, an array
    of command-line arguments given to our program when run. We can use several `if`
    statements to check whether the user has run our program properly.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`sys`是如何被导入的，通过它我们可以访问到`sys.argv`，这是一个数组，包含了运行程序时提供给我们的命令行参数。我们可以使用多个`if`语句来检查用户是否正确地运行了我们的程序。
- en: Let’s assume that this program will be getting much more complicated. How could
    we check all the arguments that could be inserted by the user? We might give up
    if we have more than a few command-line arguments!
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设这个程序将会变得更加复杂。我们该如何检查用户可能插入的所有参数呢？如果我们有超过几个命令行参数，我们可能会放弃！
- en: 'Luckily, `argparse` is a library that handles all the parsing of complicated
    strings of command-line arguments. In the text editor window, code as follows:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸运的是，`argparse`是一个处理复杂命令行参数字符串解析的库。在文本编辑器窗口中，代码如下：
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how `argparse` is imported instead of `sys`. An object called `parser`
    is created from an `ArgumentParser` class. That class’s `add_argument` method
    is used to tell `argparse` what arguments we should expect from the user when
    they run our program. Finally, running the parser’s `parse_args` method ensures
    that all of the arguments have been included properly by the user.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何导入`argparse`而不是`sys`的。从`ArgumentParser`类创建了一个名为`parser`的对象。该类的`add_argument`方法用于告诉`argparse`，当用户运行我们的程序时，我们应该期望从用户那里得到哪些参数。最后，运行解析器的`parse_args`方法确保用户已经正确地包括了所有参数。
- en: 'We can also program more cleanly, such that our user can get some information
    about the proper usage of our code when they fail to use the program correctly.
    In the text editor window, code as follows:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以编写更干净的代码，这样当用户未能正确使用程序时，他们可以获取一些关于我们代码正确使用方法的信息。在文本编辑器窗口中，代码如下：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how the user is provided some documentation. Specifically, a `help` argument
    is provided. Now, if the user executes `python meows.py --help` or `-h`, the user
    will be presented with some clues about how to use this program.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到用户提供了一些文档。具体来说，提供了一个`help`参数。现在，如果用户执行`python meows.py --help`或`-h`，用户将看到一些关于如何使用此程序的提示。
- en: 'We can further improve this program. In the text editor window, code as follows:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以进一步改进这个程序。在文本编辑器窗口中，代码如下：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how not only is help documentation included, but you can provide a `default`
    value when no arguments are provided by the user.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到不仅包含了帮助文档，而且当用户没有提供任何参数时，你还可以提供一个`默认`值。
- en: You can learn more in Python’s documentation of [`argparse`](https://docs.python.org/3/library/argparse.html).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的`argparse`文档中了解更多信息。[`argparse`](https://docs.python.org/3/library/argparse.html)。
- en: Unpacking
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包
- en: 'Would it not be nice to be able to split a single variable into two variables?
    In the text editor window, code as follows:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不想能够将一个变量分割成两个变量不是很好吗？在文本编辑器窗口中，代码如下：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how this program tries to get a user’s first name by naively splitting
    on a single space.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这个程序尝试通过简单地在一个空格上进行分割来获取用户的名字。
- en: 'It turns out there are other ways to unpack variables. You can write more powerful
    and elegant code by understanding how to unpack variables in seemingly more advanced
    ways. In the text editor window, code as follows:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果表明，还有其他方法可以解包变量。通过理解如何以看似更高级的方式解包变量，你可以编写更强大、更优雅的代码。在文本编辑器窗口中，代码如下：
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how this returns the total value of Knuts.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这返回了Knuts的总价值。
- en: 'What if we wanted to store our coins in a list? In the text editor window,
    code as follows:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要将硬币存储在一个列表中？在文本编辑器窗口中，代码如下：
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how a list called `coins` is created. We can pass each value in by indexing
    using `0`, `1`, and so on.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到创建了一个名为`coins`的列表。我们可以通过索引使用`0`、`1`等来传递每个值。
- en: This is getting quite verbose. Wouldn’t it be nice if we could simply pass the
    list of coins to our function?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这变得相当冗长。如果我们能够简单地将硬币列表传递给我们的函数，不是很好吗？
- en: 'To enable the possibility of passing the entire list, we can use unpacking.
    In the text editor window, code as follows:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使传递整个列表成为可能，我们可以使用解包。在文本编辑器窗口中，代码如下：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how a `*` unpacks the sequence of the list of coins and passes in each
    of its individual elements to `total`.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`*`如何解包列表的序列，并将每个单独的元素传递给`total`。
- en: 'Suppose that we could pass in the names of the currency in any order? In the
    text editor window, code as follows:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们可以以任何顺序传递货币的名称？在文本编辑器窗口中，代码如下：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how this still calculates correctly.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这仍然计算正确。
- en: 'When you start talking about “names” and “values,” dictionaries might start
    coming to mind! You can implement this as a dictionary. In the text editor window,
    code as follows:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你开始谈论“名称”和“值”时，字典可能会浮现在你的脑海中！你可以将其实现为一个字典。在文本编辑器窗口中，代码如下：
- en: '[PRE26]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how a dictionary called `coins` is provided. We can index into it using
    keys, such as “galleons” or “sickles”.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到提供了一个名为`coins`的字典。我们可以使用键，如“galleons”或“sickles”来索引它。
- en: 'Since the `total` function expects three arguments, we cannot pass in a dictionary.
    We can use unpacking to help with this. In the text editor window, code as follows:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`total`函数期望三个参数，我们不能传递一个字典。我们可以使用解包来帮助解决这个问题。在文本编辑器窗口中，代码如下：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice how `**` allows you to unpack a dictionary. When unpacking a dictionary,
    it provides both the keys and values.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`**`允许你解包一个字典。在解包字典时，它提供了键和值。
- en: '`args` and `kwargs`'
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`args`和`kwargs`'
- en: 'Recall the `print` documentation we looked at earlier in this course:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下我们在这门课程中之前看到的`print`文档：
- en: '[PRE28]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`args` are positional arguments, such as those we provide to print like `print("Hello",
    "World")`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`是位置参数，例如我们提供给`print`的`print("Hello", "World")`。'
- en: '`kwargs` are named arguments, or “keyword arguments”, such as those we provide
    to print like `print(end="")`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kwargs`是命名参数，或称为“关键字参数”，例如我们提供给`print`的`print(end="")`。'
- en: 'As we see in the prototype for the `print` function above, we can tell our
    function to expect a presently unknown number positional arguments. We can also
    tell it to expect a presently unknown number of keyword arguments. In the text
    editor window, code as follows:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在上面`print`函数的原型中看到的，我们可以告诉我们的函数期望一个目前未知数量的位置参数。我们也可以告诉它期望一个目前未知数量的关键字参数。在文本编辑器窗口中，代码如下：
- en: '[PRE29]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how executing this code will be printed as positional arguments.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到执行此代码将打印为位置参数。
- en: 'We can even pass in named arguments. In the text editor window, code as follows:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice how the named values are provided in the form of a dictionary.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Thinking about the `print` function above, you can see how `*objects` takes
    any number of positional arguments.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [`print`](https://docs.python.org/3/library/functions.html#print).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Early on, we began with procedural programming.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We later revealed Python is an object oriented programming language.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We saw hints of functional programming, where functions have side effects without
    a return value. We can illustrate this in the text editor window, type `code yell.py`
    and code as follows:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how the `yell` function is simply yelled.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Wouldn’t it be nice to yell a list of unlimited words? Modify your code as
    follows:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice we accumulate the uppercase words, iterating over each of the words and
    “uppercasing” them. The uppercase list is printed utilizing the `*` to unpack
    it.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Removing the brackets, we can pass the words in as arguments. In the text editor
    window, code as follows:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice how `*words` allows for many arguments to be taken by the function.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`map` allows you to map a function to a sequence of values. In practice, we
    can code as follows:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice how `map` takes two arguments. First, it takes a function we want applied
    to every element of a list. Second, it takes that list itself, to which we’ll
    apply the aforementioned function. Hence, all words in `words` will be handed
    to the `str.upper` function and returned to `uppercased`.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can learn more in Python’s documentation of [`map`](https://docs.python.org/3/library/functions.html#map).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List Comprehensions
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: List comprehensions allow you to create a list on the fly in one elegant one-liner.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can implement this in our code as follows:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice how instead of using `map`, we write a Python expression within square
    brackets. For each argument, `.upper` is applied to it.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Taking this concept further, let’s pivot toward another program.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, type `code gryffindors.py` and code as follows:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice we have a conditional while we’re creating our list. *If* the student’s
    house is Gryffindor, we append the student to the list of names. Finally, we print
    all the names.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'More elegantly, we can simplify this code with a list comprehension as follows:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how the list comprehension is on a single line!
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`filter`'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using Python’s `filter` function allows us to return a subset of a sequence
    for which a certain condition is true.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text editor window, code as follows:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice how a function called `is_gryffindor` is created. This is our filtering
    function that will take a student `s`, and return `True` or `False` depending
    on whether the student’s house is Gryffindor. You can see the new `filter` function
    takes two arguments. First, it takes the function that will be applied to each
    element in a sequence—in this case, `is_gryffindor`. Second, it takes the sequence
    to which it will apply the filtering function—in this case, `students`. In `gryffindors`,
    we should see only those students who are in Gryffindor.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意如何创建一个名为`is_gryffindor`的函数。这是我们用于筛选学生的函数，它将根据学生的学院是否为格兰芬多返回`True`或`False`。你可以看到新的`filter`函数接受两个参数。首先，它接受应用于序列中每个元素的函数——在这个例子中是`is_gryffindor`。其次，它接受要应用筛选函数的序列——在这个例子中是`students`。在`gryffindors`中，我们应该只看到那些在格兰芬多的学生。
- en: '`filter` can also use lambda functions as follows:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`也可以使用lambda函数如下：'
- en: '[PRE39]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice how the same list of students is provided.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意提供了相同的学生的列表。
- en: You can learn more in Python’s documentation of [`filter`](https://docs.python.org/3/library/functions.html#filter).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的`filter`函数文档中了解更多信息[《filter》](https://docs.python.org/3/library/functions.html#filter)。
- en: Dictionary Comprehensions
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典推导式
- en: 'We can apply the same idea behind list comprehensions to dictionaries. In the
    text editor window, code as follows:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将列表推导式的相同理念应用到字典中。在文本编辑器窗口中，编写如下代码：
- en: '[PRE40]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice how this code doesn’t (yet!) use any comprehensions. Instead, it follows
    the same paradigms we have seen before.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意此代码（目前！）没有使用任何推导式。相反，它遵循我们之前看到的相同范例。
- en: 'We can now apply dictionary comprehensions by modifying our code as follows:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以通过修改我们的代码来应用字典推导式：
- en: '[PRE41]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice how all the prior code is simplified into a single line where the structure
    of the dictionary is provided for each `student` in `students`.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意所有之前的代码是如何简化成一行，其中为`students`中的每个`student`提供了字典的结构。
- en: 'We can even simplify further as follows:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们甚至可以进一步简化如下：
- en: '[PRE42]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice how the dictionary will be constructed with key-value pairs.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意字典将使用键值对构建。
- en: '`enumerate`'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`enumerate`'
- en: 'We may wish to provide some ranking of each student. In the text editor window,
    code as follows:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能希望为每个学生提供一些排名。在文本编辑器窗口中，编写如下代码：
- en: '[PRE43]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice how each student is enumerated when running this code.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意运行此代码时每个学生是如何被列举的。
- en: 'Utilizing enumeration, we can do the same:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用枚举，我们可以做到相同：
- en: '[PRE44]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice how enumerate presents the index and the value of each `student`.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`enumerate`如何展示每个`student`的索引和值。
- en: You can learn more in Python’s documentation of [`enumerate`](https://docs.python.org/3/library/functions.html#enumerate).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的`enumerate`函数文档中了解更多信息[《enumerate》](https://docs.python.org/3/library/functions.html#enumerate)。
- en: Generators and Iterators
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器和迭代器
- en: In Python, there is a way to protect against your system running out of resources
    the problems they are addressing become too large.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，有一种方法可以防止系统资源耗尽，当它们解决的问题变得太大时。
- en: In the United States, it’s customary to “count sheep” in one’s mind when one
    is having a hard time falling asleep.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在美国，当人们难以入睡时，习惯于在心中“数绵羊”。
- en: 'In the text editor window, type `code sleep.py` and code as follows:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本编辑器窗口中，输入`code sleep.py`并编写如下代码：
- en: '[PRE45]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice how this program will count the number of sheep you ask of it.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这个程序将如何计数你要求其数绵羊的数量。
- en: 'We can make our program more sophisticated by adding a `main` function by coding
    as follows:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个`main`函数来使我们的程序更加复杂，如下所示：
- en: '[PRE46]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice how a `main` function is provided.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意提供了一个`main`函数。
- en: We have been getting into the habit of abstracting away parts of our code.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经养成了抽象代码部分的习惯。
- en: 'We can call a sheep function by modifying our code as follows:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过修改我们的代码来调用绵羊函数：
- en: '[PRE47]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice how the `main` function does the iteration.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`main`函数是如何进行迭代的。
- en: 'We can provide the `sheep` function more abilities. In the text editor window,
    code as follows:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以给`sheep`函数提供更多功能。在文本编辑器窗口中，编写如下代码：
- en: '[PRE48]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice how we create a flock of sheep and return the `flock`.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何创建一群绵羊并返回`flock`。
- en: Executing our code, you might try different numbers of sheep such as `10`, `1000`,
    and `10000`. What if you asked for `1000000` sheep, your program might completely
    hang or crash. Because you have attempted to generate a massive list of sheep,
    your computer may be struggling to complete the computation.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行我们的代码时，你可以尝试不同的绵羊数量，例如`10`、`1000`和`10000`。如果你要求`1000000`只绵羊，你的程序可能会完全挂起或崩溃。因为你试图生成一个庞大的绵羊列表，你的电脑可能难以完成计算。
- en: 'The `yield` generator can solve this problem by returning a small bit of the
    results at a time. In the text editor window, code as follows:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield`生成器可以通过一次返回一小部分结果来解决这个问题。在文本编辑器窗口中，编写如下代码：'
- en: '[PRE49]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice how `yield` provides only one value at a time while the `for` loop keeps
    working.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`yield`一次只提供单个值，而`for`循环则持续工作。
- en: You can learn more in Python’s documentation of [generators](https://docs.python.org/3/howto/functional.html#generators).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的[生成器](https://docs.python.org/3/howto/functional.html#generators)文档中了解更多信息。
- en: You can learn more in Python’s documentation of [iterators](https://docs.python.org/3/howto/functional.html#iterators).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python的[迭代器](https://docs.python.org/3/howto/functional.html#iterators)文档中了解更多信息。
- en: Congratulations!
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恭喜你！
- en: As you exit from this course, you have more of a mental model and toolbox to
    address programming-related problems.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你从这门课程退出时，你拥有更多的心理模型和工具箱来解决编程相关的问题。
- en: First, you learned about functions and variables.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你学习了函数和变量。
- en: Second, you learned about conditionals.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，你学习了条件语句。
- en: Third, you learned about loops.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，你学习了循环。
- en: Fourth, you learned about exceptions.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四，你学习了异常。
- en: Fifth, you learned about libraries.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五，你学习了库。
- en: Sixth, you learned about unit tests.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六，你学习了单元测试。
- en: Seventh, you learned about file I/O.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第七，你学习了文件I/O。
- en: Eighth, you learned about regular expressions.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第八，你学习了正则表达式。
- en: Most recently, you learned about object-oriented programming.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近，你学习了面向对象编程。
- en: Today, you learned about many other tools you can use.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天，你学习了你可以使用的许多其他工具。
- en: This was CS50!
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这就是CS50！
- en: 'Creating a final program together, type `code say.py` in your terminal window
    and code as follows:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一起创建一个最终程序，在你的终端窗口中输入`code say.py`，并编写如下代码：
- en: '[PRE50]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice how running this program provides you with a spirited send-off.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到运行这个程序为你提供了一个充满活力的告别。
- en: Our great hope is that you will use what you learned in this course to address
    real problems in the world, making our globe a better place.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们伟大的希望是，你将利用在这门课程中学到的知识来解决世界上的实际问题，使我们的地球变得更美好。
- en: This was CS50!
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是CS50！
