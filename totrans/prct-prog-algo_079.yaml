- en: 4.3 Stacks and Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 栈和队列
- en: 原文：[https://introcs.cs.princeton.edu/python/43stack](https://introcs.cs.princeton.edu/python/43stack)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://introcs.cs.princeton.edu/python/43stack](https://introcs.cs.princeton.edu/python/43stack)
- en: <title>4.3 Stacks and Queues</title>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <title>4.3 栈和队列</title>
- en: 'In this section, we introduce two closely-related data types for manipulating
    arbitrarily large collections of objects: the *stack* and the *queue*. Each is
    defined by two basic operations: *insert* a new item, and *remove* an item. When
    we insert an item, our intent is clear. But when we remove an item, which one
    do we choose? The rule used for a queue is to always remove the item that has
    been in the collection the *most* amount of time. This policy is known as *first-in-first-out*
    or *FIFO*. The rule used for a stack is to always remove the item that has been
    in the collection the *least* amount of time. This policy is known as *last-in
    first-out* or LIFO.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了两种密切相关的数据类型，用于操作任意大的对象集合：*栈*和*队列*。每种类型都由两个基本操作定义：*插入*一个新项和*移除*一个项。当我们插入一个项时，我们的意图是明确的。但当我们移除一个项时，我们应该选择哪一个？队列使用的规则是始终移除在集合中存在时间*最长*的项。这个策略被称为*先进先出*或*FIFO*。栈使用的规则是始终移除在集合中存在时间*最短*的项。这个策略被称为*后进先出*或*LIFO*。
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Pushdown Stacks
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推入栈
- en: '![Operations on a pushdown stack](../Images/15e8d56c1c189ab01164b1f7b69a6d09.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![推入栈的操作](../Images/15e8d56c1c189ab01164b1f7b69a6d09.png)'
- en: A *pushdown stack* (or just a *stack*) is a collection that is based on the
    last-in-first-out (LIFO) policy. When you click a hyperlink, your browser displays
    the new page (and inserts it onto a stack). You can keep clicking on hyperlinks
    to visit new pages. You can always revisit the previous page by clicking the back
    button (remove it from a stack). The last-in-first-out policy offered by a pushdown
    stack provides just the behavior that you expect.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*推入栈*（或简称*栈*）是基于后进先出（LIFO）策略的集合。当你点击一个超链接时，你的浏览器会显示新页面（并将其插入到栈中）。你可以继续点击超链接访问新页面。你可以通过点击返回按钮（从栈中移除）来重新访问上一页。推入栈提供了你期望的行���。
- en: 'By tradition, we name the stack *insert* operation *push* and the stack *remove*
    operation *pop*. We also include a method to test whether the stack is empty.
    The following API summarizes the operations:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 按照传统，我们将栈的*插入*操作称为*push*，将栈的*移除*操作称为*pop*。我们还包括一个方法来测试栈是否为空。以下 API 总结了这些操作：
- en: '![Stack API](../Images/1c97b64f5357430036732c1aafef38a7.png)'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![栈 API](../Images/1c97b64f5357430036732c1aafef38a7.png)'
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Python List (Resizing Array) Implementation of a Stack
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 列表（调整大小数组）实现的栈
- en: Representing a stack with a Python list is a natural idea, but before reading
    further, it is worthwhile for you to think for a moment about how you would do
    so.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 用 Python 列表表示栈是一个自然的想法，但在继续阅读之前，值得你花一点时间考虑如何实现。
- en: '![Using a Python list to represent a stack](../Images/21e435f1dd6935aeda859ce31dab0a37.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Python 列表表示栈](../Images/21e435f1dd6935aeda859ce31dab0a37.png)'
- en: Naturally, you need an instance variable `a[]` to hold the stack items in a
    Python list. For efficiency, we store the items in order of their insertion because
    inserting and deleting from the end of a Python list takes constant amortized
    time per operation (whereas inserting and deleting from the front takes linear
    time per operation).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，你需要一个实例变量`a[]`来在 Python 列表中保存栈项。为了效率，我们按照插入顺序存储项，因为在 Python 列表的末尾插入和删除每次操作都需要恒定的摊销时间（而在开头插入和删除每次操作都需要线性时间）。
- en: 'We could hardly hope for a simpler implementation of the Stack API than [arraystack.py](arraystack.py.html)
    — all of the methods are one-liners! The instance variable is a Python list `_a[]`
    that hold the items in the stack in order of their insertion. To push an item,
    we append it to the end of the list using the `+=` operator; to pop an item, we
    call the `pop()` method, which removes and returns the item from the end of the
    list; to determine the size of the stack, we call the built-in `len()` function.
    These operations preserve the following properties:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎无法希望有比[arraystack.py](arraystack.py.html)更简单的栈 API 实现了 — 所有的方法都是一行代码！实例变量是一个
    Python 列表`_a[]`，按照插入顺序保存栈中的项。要推入一个项，我们使用`+=`运算符将其附加到列表的末尾；要弹出一个项，我们调用`pop()`方法，它会从列表的末尾移除并返回该项；要确定栈的大小，我们调用内置的`len()`函数。这些操作保持以下属性：
- en: The stack contains `len(_a)` items.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈包含`len(_a)`项。
- en: The stack is empty when `len(_a)` is 0.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`len(_a)`为 0 时，栈为空。
- en: The list `_a[]` contains the stack items, in order of their insertion.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表`_a[]`包含栈项，按照插入顺序排列。
- en: The item most recently inserted onto the stack (if nonempty) is `_a[len(_a)
    - 1]`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈中最近插入的项（如果非空）是`_a[len(_a) - 1]`。
- en: 'The test client in [arraystack.py](arraystack.py.html) allows for testing with
    an arbitrary sequence of operations: it does a `push()` for each string on standard
    input except the string consisting of a minus sign, for which it does a `pop()`.
    The diagram at right is a trace for the test file [tobe.txt](tobe.txt).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[arraystack.py](arraystack.py.html) 中的测试客户端允许使用任意序列的操作进行测试：对于标准输入中的每个字符串，它执行一个`push()`操作，除了由减号组成的字符串，对于该字符串，它执行一个`pop()`操作。右侧的图表是测试文件[tobe.txt](tobe.txt)的跟踪。'
- en: '![Trace of arraystack.py test client](../Images/12d13b11c25f82b894a6ea7d748c9c0a.png)'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![arraystack.py 测试客户端的跟踪](../Images/12d13b11c25f82b894a6ea7d748c9c0a.png)'
- en: The primary characteristics of this implementation are that it uses space linear
    in the number of items in the stack and that the *the push and pop operations
    take constant amortized time*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的主要特点是它使用的空间与栈中的项数成线性关系，并且*推入和弹出操作需要恒定的摊销时间*。
- en: '* * *'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Linked-List Implementation of a Stack
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用链表实现的栈
- en: Next, we consider a completely different way to implement a stack, using a fundamental
    data structure known as a *linked list*. Reuse of the word "list" here is a bit
    confusing, but we have no choice — linked lists have been around much longer than
    Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑一种完全不同的实现栈的方式，使用一种称为*链表*的基本数据结构。在这里重复使用“列表”这个词有点令人困惑，但我们别无选择 — 链表比 Python
    存在的时间更长。
- en: 'A linked list is a recursive data structure defined as follows: it is either
    empty (null) or a reference to a node having a reference to a linked list. The
    node in this definition is an abstract entity that might hold any kind of data,
    in addition to the node reference that characterizes its role in building linked
    lists.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是一种递归数据结构，定义如下：它要么为空（null），要么是一个指向具有指向链表的节点的引用。在这个定义中，节点是一个抽象实体，除了表征其在构建链表中的角色的节点引用外，还可能包含任何类型的数据。
- en: 'With object-oriented programming, implementing linked lists is not difficult.
    We start with a class for the node abstraction:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 利用面向对象编程，实现链表并不困难。我们从节点抽象的类开始：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An object of type `Node` has two instance variables: `item` (a reference to
    an item) and `next` (a reference to another `Node` object). The next instance
    variable characterizes the linked nature of the data structure. To emphasize that
    we are just using the Node class to structure the data, we define no methods other
    than the constructor. We also omit leading underscores from the names of the instance
    variables, thus indicating that it is permissible for code external to the data
    type (but still within our Stack implementation) to access those instance variables.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`Node`的对象有两个实例变量：`item`（指向一个项目的引用）和`next`（指向另一个`Node`对象的引用）。`next`实例变量表征了数据结构的链式特性。为了强调我们只是使用`Node`类来组织数据，我们除了构造函数外不定义任何方法。我们还从实例变量的名称中省略了前导下划线，这表明允许外部代码（但仍在我们的Stack实现内部）访问这些实例变量。
- en: Now, from the recursive definition, we can represent a linked list with a reference
    to a `Node` object, which contains a reference to an item and a reference to another
    `Node` object, which contains a reference to an item and a reference to another
    `Node` object, and so forth. The final `Node` object in the linked list must indicate
    that it is, indeed, the final Node object. In Python, we accomplish that by assigning
    `None` to the next instance variable of the final `Node` object. Recall that `None`
    is a Python keyword — a variable assigned the value `None` references no object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据递归定义，我们可以用一个指向`Node`对象的引用来表示一个链表，该对象包含一个指向项目的引用和另一个`Node`对象的引用，该对象包含一个指向项目的引用和另一个`Node`对象的引用，依此类推。链表中的最后一个`Node`对象必须指示它确实是最后一个Node对象。在Python中，我们通过将最后一个`Node`对象的`next`实例变量赋值为`None`来实现这一点。请记住，`None`是Python的一个关键字
    — 赋值为`None`的变量不引用任何对象。
- en: '![Linking together a linked list](../Images/6709a7930e01779723b5ea70b5cda1db.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![将链表连接在一起](../Images/6709a7930e01779723b5ea70b5cda1db.png)'
- en: 'For example, to build a linked list that contains the items `''to''`, `''be''`,
    and `''or''`, we execute this code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要构建一个包含项目`'to'`、`'be'`和`'or'`的链表，我们执行以下代码：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For economy, we use the term *link* to refer to a `Node` reference. For simplicity,
    when the item is a string (as in our examples), we put it within the node rectangle
    (rather than using the more accurate rendition in which the node holds a reference
    to a string object, which is external to the node). This visual representation
    allows us to focus on the links.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们使用术语*link*来指代`Node`引用。为了简单起见，当项目是一个字符串时（如我们的示例中），我们将其放在节点矩形内（而不是使用更准确的表达方式，即节点持有对外部字符串对象的引用）。这种视觉表示让我们可以专注于链接。
- en: '![Removing the first node in a linked list](../Images/b61a321b80ecf2bb927fbabc352cac43.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![在链表中删除第一个节点](../Images/b61a321b80ecf2bb927fbabc352cac43.png)'
- en: 'Suppose that you want to *remove* the first node from a linked list. This operation
    is easy: simply assign to `first` the value `first.next`. Normally, you would
    retrieve the item (by assigning it to some variable) before doing this assignment,
    because once you change the variable `first`, you may lose any access to the node
    to which it was referring previously. Typically, the `Node` object becomes an
    orphan, and Python''s memory management system eventually reclaims it.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要从���表中*删除*第一个节点。这个操作很简单：只需将`first`赋值为`first.next`。通常，在执行此赋值之前，你会先检索项目（通过将其赋值给某个变量），因为一旦更改变量`first`，你可能会失去对先前引用的节点的任何访问权限。通常，`Node`对象变成孤立的，Python的内存管理系统最终会回收它。
- en: '![Inserting a new node at the beginning of a linked list](../Images/74222d8688e1f51bff1917d1b3db9942.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![在链表开头插入新节点](../Images/74222d8688e1f51bff1917d1b3db9942.png)'
- en: Now, suppose that you want to *insert* a new node into a linked list. The easiest
    place to do so is at the beginning of the linked list. For example, to insert
    the string `'not'` at the beginning of a given linked list whose first node is
    `first`, we save `first` in a variable `oldFirst`; create a new `Node` whose item
    instance variable is `'not'` and whose `next` instance variable is `oldFirst`;
    and assign first to refer to that new `Node`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想要在链表中*插入*一个新节点。最容易的地方是在链表的开头插入。例如，要在第一个节点为`first`的给定链表中的开头插入字符串`'not'`，我们将`first`保存在变量`oldFirst`中；创建一个新的`Node`，其`item`实例变量为`'not'`，`next`实例变量为`oldFirst`；然后将`first`指向该新的`Node`。
- en: Those two operations take constant time; their efficiency is independent of
    the length of the list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作的时间复杂度是常数时间；它们的效率与链表的长度无关。
- en: Implementing stacks with linked lists.
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用链表实现栈。
- en: '![Trace of linkedstack.py test client](../Images/1b2e38d9b6b2de23a46eaf939428b5af.png)
    Program [linkedstack.py](linkedstack.py) uses a linked list to implement a stack.
    The implementation is based on a private `_Node` class that is identical to the
    `Node` class that we have been using. We make the class private because clients
    of the `Stack` data type do not need to know any of the details of the linked
    lists. As usual, we give the class a name that begins with a leading underscore
    to emphasize to `Stack` clients that they should not access the `_Node` class
    directly.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![linkedstack.py测试客户端的跟踪](../Images/1b2e38d9b6b2de23a46eaf939428b5af.png) 程序[linkedstack.py](linkedstack.py)使用链表来实现栈。该实现基于一个私有的`_Node`类，该类与我们一直在使用的`Node`类相同。我们将该类设为私有，因为`Stack`数据类型的客户端不需要知道链表的任何细节。通常，我们给类名加上前导下划线以强调`Stack`客户端不应直接访问`_Node`类。'
- en: Linked list traversal.
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链表遍历。
- en: Many linked-list applications need to iterate over the items in a linked list.
    To do so, we first initialize a loop index variable `cur` that references the
    first `Node` of the linked list. Next, we get the item associated with `cur` by
    accessing `cur.item`, and then update `cur` to refer to the next `Node` in the
    linked list, assigning to it the value of `cur.next` and repeating this process
    until `cur` is `None` (which indicates that we have reached the end of the linked
    list). This process is known as *traversing the list*. The `__str__()` method
    defined in [linkedstack.py](linkedstack.py.html) does a list traversal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 许多链表应用需要遍历链表中的项目。为此，我们首先初始化一个循环索引变量`cur`，引用链表的第一个`Node`。接下来，我们通过访问`cur.item`获取与`cur`关联的项目，然后更新`cur`以引用链表中的下一个`Node`，将`cur.next`的值赋给它，并重复此过程，直到`cur`为`None`（表示已到达链表的末尾）。这个过程称为*遍历列表*。在[linkedstack.py](linkedstack.py.html)中定义的`__str__()`方法执行列表遍历。
- en: For stacks, linked lists are significant because they allow us to implement
    the `push()` and `pop()` methods in constant time in the worst case, while using
    only a small constant factor of extra space (for the links). Still, Python programmers
    usually prefer Python lists (resizing arrays), primarily because of the substantial
    Python overhead for user-defined types like our linked-list `Node`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于栈来说，链表很重要，因为它们允许我们在最坏情况下以常数时间实现`push()`和`pop()`方法，同时仅使用很小的额外空间常数因子（用于链接）。然而，Python程序员通常更喜欢Python列表（调整大小的数组），主要是因为用户定义类型（如我们的链表`Node`）的Python开销很大。
- en: '* * *'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Stack Applications
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈应用
- en: Pushdown stacks play an essential role in computation. Some examples illustrate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 推入栈在计算中起着至关重要的作用。一些示例进行说明。
- en: Arithmetic expressions.
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术表达式。
- en: 'Some of the first programs that we considered in Chapter 1 involved computing
    the value of arithmetic expressions like this one:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中考虑的一些最初的程序涉及计算类似于这样的算术表达式的值：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'How does Python do this calculation? We can address the essential ideas just
    by composing a Python program that can take a string as input (the expression)
    and produce the number represented by the expression as output. For simplicity,
    we begin with the following explicit recursive definition: an arithmetic expression
    is either a number or a left parenthesis followed by an arithmetic expression
    followed by an operator followed by another arithmetic expression followed by
    a right parenthesis. For simplicity, this definition applies to fully parenthesized
    arithmetic expressions, which specifies precisely which operators apply to which
    operands. For specificity, we support the familiar binary operators *, +, and
    -, as well as a square-root operator `sqrt` that takes only one argument.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python如何进行这种计算？我们可以通过编写一个Python程序来解决基本思想，该程序可以接受字符串作为输入（表达式）并将表达式表示的数字作为输出。为简单起见，我们从以下明确的递归定义开始：算术表达式是一个数字或一个左括号，后跟一个算术表达式，后跟一个运算符，后跟另一个算术表达式，后跟一个右括号。为简单起见，此定义适用于完全括号化的算术表达式，其中明确指定了哪些运算符适用于哪些操作数。为了具体性，我们支持熟悉的二元运算符*、+和-，以及一个仅接受一个参数的平方根运算符`sqrt`。
- en: Arithmetic expression evaluation.
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术表达式求值。
- en: 'Precisely how can we convert an arithmetic expression — a string of characters
    — to the value that it represents? A remarkably simple algorithm that was developed
    by Edsgar Dijkstra in the 1960s uses two pushdown stacks (one for operands and
    one for operators) to do this job. An expression consists of parentheses, operators,
    and operands (numbers). Proceeding from left to right and taking these entities
    one at a time, we manipulate the stacks according to four possible cases, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将算术表达式（一串字符）转换为它表示的值？Edsgar Dijkstra在1960年代开发的一个非常简单的算法使用两个推入栈（一个用于操作数，一个用于运算符）来执行此任务。表达式由括号、运算符和操作数（数字）组成。从左到右进行，并逐个处理这些实体，我们根据四种可能情况操作栈，如下所示：
- en: Push *operands* onto the operand stack.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*操作数*推送到操作数栈上。
- en: Push *operators* onto the operator stack.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*运算符*推送到运算符栈上。
- en: Ignore *left* parentheses.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略*左*括号。
- en: On encountering a *right* parenthesis, pop an operator, pop the requisite number
    of operands, and push onto the operand stack the result of applying that operator
    to those operands.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到*右*括号时，弹出一个运算符，弹出所需数量的操作数，并将将该运算符应用于这些操作数的结果推送到操作数栈上。
- en: After the final right parenthesis has been processed, there is one value on
    the stack, which is the value of the expression. The program [evaluate.py](evaluate.py.html)
    is an implementation of this algorithm. Try running it with [expression1.txt](expression1.txt)
    and [expression2.txt](expression2.txt).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完最后一个右括号后，栈上有一个值，即表达式的值。程序[evaluate.py](evaluate.py.html)是此算法的实现。尝试使用[expression1.txt](expression1.txt)和[expression2.txt](expression2.txt)运行它。
- en: Stack-based programming languages.
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于栈的编程语言。
- en: 'Remarkably, Dijkstra''s two-stack algorithm also computes the same value as
    in our example for this expression:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，Dijkstra的双栈算法也计算出与我们示例中此表达式相同的值：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In other words, we can put each operator after its two operands instead of
    between them. In such an expression, each right parenthesis immediately follows
    an operator so we can ignore both kinds of parentheses, writing the expressions
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以将每个运算符放在其两个操作数之后，而不是在它们之间。在这种表达式中，每个右括号紧跟在一个运算符后面，因此我们可以忽略这两种括号，将表达式写成如下形式：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This notation is known as *reverse Polish notation*, or *postfix*. To evaluate
    a postfix expression, we use one stack. Proceeding from left to right, taking
    these entities one at a time, we manipulate the stacks according to just two possible
    cases:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法称为*逆波兰表示法*，或*后缀*。要评估后缀表达式，我们使用一个栈。从左到右进行，逐个处理这些实体，我们根据只有两种可能情况操作栈：
- en: Push operands onto the operand stack.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将操作数推送到操作数栈上。
- en: On encountering an operator, pop the requisite number of operands and push onto
    the operand stack the result of applying the operator to those operands.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到运算符时，弹出所需数量的操作数，并将应用运算符到这些操作数的结果推送到操作数栈上。
- en: Again, this process leaves one value on the stack, which is the value of the
    expression. This representation is so simple that some programming languages,
    such as Forth (a scientific programming language) and PostScript (a page description
    language that is used on most printers) use explicit stacks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个过程在栈上留下一个值，这个值是表达式的值。这种表示方法是如此简单，以至于一些编程语言，比如Forth（一种科学编程语言）和PostScript（一种用于大多数打印机的页面描述语言）使用显式栈。
- en: Function-call abstraction.
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数调用抽象。
- en: When the flow of control enters a function, Python creates the function's parameter
    variables on top of the other variables that might already exist. As the function
    executes, Python creates the function's local variables — again on top of the
    other variables that might already exist. When flow of control returns from a
    function, Python destroys that function's local and parameter variables. In that
    sense Python creates and destroys parameter and local variables in stack-like
    fashion. Indeed, most programs use stacks implicitly because they support a natural
    way to implement function calls
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制流进入函数时，Python会在可能已经存在的其他变量之上创建函数的参数变量。随着函数的执行，Python会创建函数的局部变量 — 再次在可能已经存在的其他变量之上。当控制流从函数返回时，Python会销毁该函数的局部和参数变量。从这个意义上说，Python以类似栈的方式创建和销毁参数和局部变量。事实上，大多数程序隐式使用栈，因为它们支持实现函数调用的自然方式
- en: '* * *'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: FIFO Queues
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FIFO队列
- en: A FIFO queue (or just a queue) is a collection that is based on the first-in
    first-out (FIFO) policy. Queues are a natural model for so many everyday phenomena
    that their properties were studied in detail even before the advent of computers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个FIFO队列（或者只是一个队列）是基于先进先出（FIFO）策略的集合。队列是如此多日常现象的自然模型，以至于在计算机出现之前就已经详细研究了它们的属性。
- en: As usual, we begin by articulating an API. Again by tradition, we name the queue
    insert operation *enqueue* and the remove operation *dequeue*, as indicated in
    the API below.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先明确API。再次按照传统，我们将队列插入操作命名为*enqueue*，将移除操作命名为*dequeue*，如下所示的API。
- en: '![Queue API](../Images/27d1aaba1faf78fafb740cb5e51d9e51.png)'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![队列API](../Images/27d1aaba1faf78fafb740cb5e51d9e51.png)'
- en: Applying our knowledge from stacks, we can use either Python lists (resizing
    arrays) or linked lists to develop implementations where the operations take constant
    time and the memory associated with the queue grows and shrinks with the number
    of elements in the queue.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们从栈中学到的知识，我们可以使用Python列表（调整大小的数组）或链表来开发实现，其中操作需要常数时间，与队列中的元素数量一起增长和缩小的内存。
- en: Linked-list implementation.
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链表实现。
- en: 'To implement a queue with a linked list, we keep the items in order of their
    arrival (the reverse of the order that we used in [linkedstack.py](linkedstack.py)).
    The implementation of `dequeue()` is the same as the `pop()` implementation in
    [linkedstack.py](linkedstack.py) (save the item in the first node, remove the
    first node from the queue, and return the saved item). Implementing `enqueue()`,
    however, is a bit more challenging: how do we add a node to the end of a linked
    list? To do so, we need a link to the last node in the list, because that node''s
    link has to be changed to reference a new node containing the item to be inserted.
    So we maintain a second instance variable that always references the last node
    in the linked list.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用链表实现队列，我们按照它们到达的顺序保留项目（与我们在[linkedstack.py](linkedstack.py)中使用的顺序相反）。`dequeue()`的实现与[linkedstack.py](linkedstack.py)中的`pop()`实现相同（保存第一个节点中的项目，从队列中移除第一个节点，并返回保存的项目）。然而，实现`enqueue()`会更具挑战性：我们如何将一个节点添加到链表的末尾？为此，我们需要一个链接到链表中最后一个节点的链接，因为该节点的链接必须更改为引用包含要插入的项目的新节点。因此，我们维护第二个实例变量，它始终引用链表中的最后一个节点。
- en: 'The program [linkedqueue.py](linkedqueue.py) is a linked-list implementation
    of `Queue` that has the same performance properties as `Stack`: all of the methods
    are constant-time operations, and space usage is linear in the number of items
    on the queue.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[linkedqueue.py](linkedqueue.py)是一个`Queue`的链表实现，具有与`Stack`相同的性能特性：所有方法都是常数时间操作，并且空间使用量与队列中的项目数量成线性关系。
- en: Resizing array implementation.
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整大小的数组实现。
- en: It is also possible to develop a FIFO queue implementation that is based on
    an explicit resizing array representation that has the same performance characteristics
    as those that we developed for a stack in [arraystack.py](arraystack.py.html).
    This implementation is a worthy and classic programming exercise that you are
    encouraged to pursue further in the exercises at the end of this section. It might
    be tempting to use one-line calls on Python `list` methods, as in [arraystack.py](arraystack.py.html).
    However, the methods for inserting or deleting items at the front of a Python
    list will not fill the bill, as they take linear time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以开发一个基于显式��整大小数组表示的FIFO队列实现，其性能特征与我们在[arraystack.py](arraystack.py.html)中为栈开发的性能特征相同。这种实现是一个值得的经典编程练习，鼓励您在本节末尾的练习中进一步探索。可能会诱人地使用Python
    `list`方法的一行调用，就像在[arraystack.py](arraystack.py.html)中一样。然而，在Python列表的前端插入或删除项目的方法不符合要求，因为它们需要线性时间。
- en: Random queues.
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机队列。
- en: Even though they are widely applicable, there is nothing sacred about the FIFO
    and LIFO disciplines. It makes perfect sense to consider other rules for removing
    items. One of the most important to consider is a data type for which `dequeue()`
    removes a *random* item (sampling without replacement) and `sample()` returns
    a random item without removing it from the queue (sampling with replacement).
    Such actions are precisely called for in numerous applications, some of which
    we have already considered, starting with [sample.py](../14array/sample.py.html)
    from Section 1.4\. With a Python list (resizing array) representation, implementing
    `sample()` is straightforward, and we can use the same idea as in [sample.py](../14array/sample.py.html)
    to implement `dequeue()` (exchange a random item with the last item before removing
    it). We use the name `RandomQueue` to refer to this data type (see the "Random
    queue" creative exercise at the end of this section).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们具有广泛的适用性，但FIFO和LIFO规则并非神圣不可侵犯。考虑其他规则来移除项目是完全有道理的。其中最重要的之一是考虑一个数据类型，其中`dequeue()`移除一个*随机*项目（无替换抽样），而`sample()`返回一个随机项目而不从队列中移除它（有替换抽样）。这些操作在许多应用中被精确调用，其中一些我们已经考虑过，从第1.4节开始，例如[sample.py](../14array/sample.py.html)。使用Python列表（调整大小的数组）表示，实现`sample()`是直接的，我们可以使用与[sample.py](../14array/sample.py.html)相同的思路来实现`dequeue()`（在删除之前将一个随机项目与最后一个项目交��）。我们使用名称`RandomQueue`来引用这种数据类型（请参阅本节末尾的“随机队列”创意练习）。
- en: '* * *'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Queue Applications
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列应用
- en: In the past century, FIFO queues proved to be accurate and useful models in
    a broad variety of applications. A field of mathematics known as *queuing theory*
    has been used with great success to help understand and control complex systems
    of all kinds. Understanding and controlling such a complex system involves solid
    implementations of the queue abstraction, application of mathematical results
    of queueing theory, and simulation studies involving both. We consider next a
    classic example to give a flavor of this process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的一个世纪里，先进先出队列被证明是准确和有用的模型，在各种应用中广泛使用。一个被称为*排队理论*的数学领域已被广泛成功地用于帮助理解和控制各种复杂系统。理解和控制这样一个复杂系统涉及对队列抽象的坚实实现，应用排队理论的数学结果以及涉及两者的模拟研究。接下来我们考虑一个经典示例，以了解这个过程的味道。
- en: M/M/1 queue.
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: M/M/1队列。
- en: 'One of the most important queueing models is known as an *M/M/1 queue*, which
    has been shown to accurately model many real-world situations, such as a single
    line of cars entering a toll booth or patients entering an emergency room. The
    *M* stands for *Markovian* or *memoryless* and indicates that both arrivals and
    services are *Poisson processes*: both the interarrival times and service times
    obey an exponential distribution (see Exercise 2.2.12) and the 1 indicates that
    there is one server. An M/M/1 queue is parameterized by its arrival rate λ (for
    example, the number of cars per minute arriving at the toll booth) and its service
    rate μ (for example, the number of cars per minute that can pass through the toll
    booth) and is characterized by three properties:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的排队模型之一被称为*M/M/1队列*，已被证明可以准确地模拟许多现实情况，例如一条汽车排队进入收费站或患者进入急诊室。 *M*代表*马尔可夫*或*无记忆*，表示到达和服务都是*泊松过程*：到达时间和服务时间都服从指数分布（参见练习2.2.12），而1表示只有一个服务器。
    M/M/1队列由到达率λ（例如，每分钟到达收费站的汽车数量）和服务率μ（例如，每分钟可以通过收费站的汽车数量）参数化，并具有三个特性：
- en: There is one server — a FIFO queue.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个服务器 — 先进先出队列。
- en: Interarrival times to a queue obey an exponential distribution with rate λ per
    minute.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入队列的到达时间服从每分钟率为λ的指数分布。
- en: Service times from a nonempty queue obey an exponential distribution with rate
    μ per minute.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非空队列的服务时间服从每分钟率为μ的指数分布。
- en: The average time between arrivals is 1/λ minutes and the average time between
    services (when the queue is nonempty) is 1/μ minutes. So, the queue will grow
    without bound unless μ > λ; otherwise, customers enter and leave the queue in
    an interesting dynamic process.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到达之间的平均时间为1/λ分钟，服务之间的平均时间（当队列非空时）为1/μ分钟。因此，除非μ > λ，否则队列将无限增长；否则，顾客将以有趣的动态过程进入和离开队列。
- en: 'In practical applications, people are interested in the effect of the parameters
    λ and μ on various properties of the queue. For M/M/1 queues, it is known that
    the average number of customers in the system *L* is λ / (μ - λ), and the average
    time a customer spends in the system *W* is 1 / (μ - λ). These formulas confirm
    that the wait time (and queue length) grows without bound as λ approaches μ. They
    also obey a general rule known as [Little''s law](https://en.wikipedia.org/wiki/Little%27s_law):
    the average number of customers in the system is λ times the average time a customer
    spends in the system (*L* - λ*W*) for many types of queues.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，人们对参数λ和μ对队列各种属性的影响感兴趣。对于M/M/1队列，已知系统中平均顾客数*L*为λ / (μ - λ)，顾客在系统中平均等待时间*W*为1
    / (μ - λ)。这些公式证实，当λ接近μ时，等待时间（和队列长度）会无限增长。它们还遵守一个被称为[利特尔定律](https://en.wikipedia.org/wiki/Little%27s_law)的一般规则：系统中平均顾客数是λ乘以顾客在系统中平均等待时间（*L*
    - λ*W*）对于许多类型的队列。
- en: 'The program [mm1queue.py](mm1queue.py.html) is a `Queue` client that you can
    use to validate these sorts of mathematical results. It is a simple example of
    an *event-based simulation*: we generate *events* that take place at particular
    times and adjust our data structures accordingly for the events, simulating what
    happens at the time they occur. See the textbook for details. From a practical
    point of view, one of the most important characteristics of the process, which
    you can discover for yourself by running [mm1queue.py](mm1queue.py.html) for various
    values of the parameters λ and μ, is that the average time a customer spends in
    the system (and the average number of customers in the system) can increase dramatically
    when the service rate approaches the arrival rate.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[mm1queue.py](mm1queue.py.html)是一个`Queue`客户端，您可以使用它来验证这些数学结果。这是一个*基于事件的模拟*的简单示例：我们生成在特定时间发生的*事件*，并相应地调整我们的数据结构以进行事件，模拟它们发生时发生的情况。有关详细信息，请参阅教科书。从实际角度来看，您可以通过运行[mm1queue.py](mm1queue.py.html)来发现参数λ和μ的各种值时，过程的最重要特征之一是，当服务速率接近到达速率时，顾客在系统中的平均停留时间（以及系统中的平均顾客数量）可能会急剧增加。
- en: '| `% python mm1queue.py .167 .25` | `% python mm1queue.py .167 .20` |'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python mm1queue.py .167 .25` | `% python mm1queue.py .167 .20` |'
- en: '| ![mm1queue.py output 1](../Images/3ecd40de309487836dacff66b32ee1a6.png) |
    ![mm1queue.py output 2](../Images/826c73c325929be435e8a3e403896cd5.png) |'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![mm1queue.py输出1](../Images/3ecd40de309487836dacff66b32ee1a6.png) | ![mm1queue.py输出2](../Images/826c73c325929be435e8a3e403896cd5.png)
    |'
- en: Resource allocation.
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源分配。
- en: A *resource-sharing system* involves a large number of loosely cooperating servers
    that want to share resources. Each server agrees to maintain a queue of items
    for sharing, and a central authority distributes the items to the servers (and
    informs users where they may be found). We will consider the kind of program that
    the central authority might use to distribute the items, ignoring the dynamics
    of deleting items from the systems, adding and deleting servers, and so forth.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*资源共享系统*涉及大量松散合作的服务器，它们希望共享资源。每个服务器同意维护一个用于共享的项目队列，一个中央机构将项目分发给服务器（并告知用户它们可以在哪里找到）。我们将考虑中央机构可能用来分发项目的程序类型，忽略从系统中删除项目的动态，添加和删除服务器等等。
- en: Central authorities often use a *random* policy, where the assignments are based
    on random choice. An even better policy is to choose a random sample of servers
    and assign a new item to the one that has smallest number of items. But how big
    a sample should we take?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 中央机构通常使用*随机*策略，其中分配基于随机选择。一个更好的策略是选择一组服务器的随机样本，并将新项目分配给具有最少项目数量的服务器。但我们应该取多大的样本呢？
- en: The program [loadbalance.py](loadbalance.py.html) is a simulation of the sampling
    policy, which we can use to study this question. This program makes good use of
    the `RandomQueue` data type (see the "Random queue" creative exercise at the end
    of this section) to provide an easily understood program that we can use for experimentation.
    The simulation maintains a random queue of queues and builds the computation around
    an inner loop where each new request for service goes on the smallest of a sample
    of queues, using the `sample()` method from `RandomQueue` to randomly sample queues.
    The surprising end result is that samples of size 2 lead to near-perfect balancing,
    so there is no point in taking larger samples.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 程序[loadbalance.py](loadbalance.py.html)是一个采样策略的模拟，我们可以用来研究这个问题。这个程序很好地利用了`RandomQueue`数据类型（请参阅本节末尾的“随机队列”创意练习），提供了一个易于理解的程序，我们可以用来进行实验。该模拟维护一个随机队列的队列，并围绕一个内部循环构建计算，在该循环中，每个新的服务请求都放在一个队列样本中最小的队列上，使用`RandomQueue`的`sample()`方法随机抽样队列。令人惊讶的最终结果是，大小为2的样本导致几乎完美的平衡，因此没有必要进行更大的样本。
- en: '| `% python loadbalance.py 50 500 1` | `% python loadbalance.py 50 500 2` |'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| `% python loadbalance.py 50 500 1` | `% python loadbalance.py 50 500 2` |'
- en: '| ![loadbalance.py output 1](../Images/3e6739b9bc9d3d87e3cd14627bcaf347.png)
    | ![loadbalance.py output 2](../Images/b17fa916e4a8c71376ddab1109bad00c.png) |'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ![loadbalance.py输出1](../Images/3e6739b9bc9d3d87e3cd14627bcaf347.png) | ![loadbalance.py输出2](../Images/b17fa916e4a8c71376ddab1109bad00c.png)
    |'
- en: '* * *'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Q & A
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问答
- en: '**Q.** When should I call the `_Node` constructor?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 何时应该调用`_Node`构造函数？'
- en: '**A.** Just as with any other class, you should call the `_Node` constructor
    when you want to create a new `_Node` object (a new node in the linked list).
    You should not use it to create a new reference to an existing `_Node` object.
    For example, the code'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 就像任何其他类一样，当你想要创建一个新的`_Node`对象（链表中的新节点）时，应该调用`_Node`构造函数。你不应该用它来创建对现有`_Node`对象的新引用。例如，下面的代码'
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: creates a new `_Node` object, then immediately loses track of the only reference
    to it. This code does not result in an error, but it is a bit untidy to create
    orphans for no reason.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`_Node`对象，然后立即失去对它唯一引用的跟踪。这段代码不会导致错误，但是没有理由创建孤立的对象有点凌乱。
- en: '**Q.** Why not define `Node` as a stand-alone class in a separate file named
    `node.py`?'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么不将`Node`定义为一个独立的类，在名为`node.py`的单独文件中？'
- en: '**A.** By defining `_Node` in the same file as [linkedstack.py](linkedstack.py.html)
    or [linkedqueue.py](linkedqueue.py.html) and giving it a name that begins with
    an underscore, we encourage clients of the `Stack` or `Queue` classes not to use
    the `_Node` class directly. Our intention is that the `_Node` objects be used
    only in the [linkedstack.py](linkedstack.py.html) or [linkedqueue.py](linkedqueue.py.html)
    implementations, not in other clients.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 通过在[linkedstack.py](linkedstack.py.html)或[linkedqueue.py](linkedqueue.py.html)中定义`_Node`，并以下划线开头的名称，我们鼓励`Stack`或`Queue`类的客户端不直接使用`_Node`类。我们的意图是，`_Node`对象仅���[linkedstack.py](linkedstack.py.html)或[linkedqueue.py](linkedqueue.py.html)实现中使用，而不在其他客户端中使用。'
- en: '**Q.** Should a client be allowed to insert the item `None` onto a stack or
    queue?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 客户是否允许将项目`None`插入堆栈或队列？'
- en: '**A.** This question arises frequently when implementing collections in Python.
    Our implementations do permit the insertion of any object, including `None`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 在Python中实现集合时，这个问题经常出现。我们的实现允许插入任何对象，包括`None`。'
- en: '**Q.** Are there standard Python modules for stacks and queues?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 是否有用于栈和队列的标准Python模块？'
- en: '**A.** Not really. As noted earlier in this section, Python''s built-in `list`
    data type has operations that make it is easy to efficiently implement a stack
    using a list. But the `list` data type also needs many additional methods that
    are not normally associated with a stack, such as indexed access and deleting
    an arbitrary item. The prime advantage of restricting ourselves to the set of
    operations that we need (and only those operations) is that it makes it easier
    to develop an implementation that can provide the best possible performance guarantees
    for those operations. Python also includes a data type `collections.deque` that
    implements a mutable sequence of items with efficient insertion and deletion to
    either the front or the back.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 实际上并没有。正如本节前面提到的，Python内置的`list`数据类型具有使得使用列表轻松实现栈的操作。但`list`数据类型还需要许多额外的方法，这些方法通常与栈不相关，比如索引访问和删除任意项目。将自己限制在我们需要的操作集合（仅限于这些操作）的优势在于，它使���更容易开发一个可以为这些操作提供最佳性能保证的实现。Python还包括一个名为`collections.deque`的数据类型，它实现了一个可变序列，具有向前或向后高效插入和删除的功能。'
- en: '**Q.** Why not have a single data type that implements methods to insert an
    item, remove the most recently inserted item, remove the least recently inserted
    item, remove a random item, iterate over the items, return the number of items
    in the collection, and whatever other operations we might desire? Then we could
    get them all implemented in a single class that could be used by many clien'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 为什么不使用一个单一的数据类型来实现插入项目、删除最近插入的项目、删除最近插入的项目、删除随机项目、遍历项目、返回集合中项目数量以及我们可能需要的其他操作的方法？然后我们可以将它们全部实现在一个类中，可以被许多客户端使用。'
- en: ts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ts。
- en: '**A.** This is an example of a *wide interface*, which, as we pointed out in
    Section 3.3, should be avoided. As just mentioned, one reason to avoid wide interfaces
    is that it is difficult to construct implementations that are efficient for all
    operations. A more important reason is that narrow interfaces enforce a certain
    discipline on your programs, which makes client code much easier to understand.
    If one client uses `Stack` and another uses `Queue`, we have a good idea that
    the LIFO discipline is important to the first and the FIFO discipline is important
    to the second. Another approach is to use inheritance to try to encapsulate operations
    that are common to all collections. However, such implementations are best left
    for experts, whereas any programmer can learn to build implementations such as
    `Stack` and `Queue`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 这是一个*宽接口*的示例，正如我们在第3.3节中指出的那样，应该避免使用。正如刚才提到的，避免使用宽接口的一个原因是很难构建对所有操作都有效率的实现。更重要的原因是窄接口对程序施加了一定的纪律，使客户端代码更容易理解。如果一个客户端使用`Stack`，另一个使用`Queue`，我们可以很好地了解到LIFO纪律对第一个客户端很重要，而FIFO纪律对第二个客户端很重要。另一种方法是使用继承来尝试封装所有集合共有的操作。然而，这样的实现最好留给专家，而任何程序员都可以学会构建`Stack`和`Queue`等实现。'
- en: '**Q.** Is there any way that I can compose a client that uses both [arraystack.py](arraystack.py.html)
    and [linkedstack.py](linkedstack.py.html) in the same program?'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** 是否有办法编写一个客户端，同时在同一个程序中使用[arraystack.py](arraystack.py.html)和[linkedstack.py](linkedstack.py.html)？'
- en: '**A.** Yes, the easiest way is to add an `as` clause to the `import` statement,
    as below. In effect, this kind of `import` statement creates an alias for the
    name of the class and your code can then use that alias instead of the name of
    the class.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**A.** 是的，最简单的方法是在`import`语句中添加一个`as`子句，如下所示。实际上，这种类型的`import`语句为类的名称创建了一个别名，然后你的代码可以使用该别名而不是类的名称。'
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '* * *'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Exercises
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习
- en: 'Give the output written by [arraystack.py](arraystack.py.html) for the following
    input:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出[arraystack.py](arraystack.py.html)对以下输入的输出：
- en: '[PRE7]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Give the contents and length of the array for [arraystack.py](arraystack.py.html)
    after each operation for the following input:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出[arraystack.py](arraystack.py.html)在以下输入的每个操作后的数组内容和长度：
- en: '[PRE8]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Suppose that a client performs an intermixed sequence of *push* and *pop* operations
    on a `Stack`. The push operations put the integers 0 through 9 in order onto the
    stack; the pop operations write the return value. Which of the following sequence(s)
    could not occur?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一个客户端在`Stack`上执行一系列交错的*push*和*pop*操作。push操作按顺序将整数0到9放入栈中；pop操作写入返回值。以下哪个序列可能不会发生？
- en: '`4 3 2 1 0 9 8 7 6 5`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4 3 2 1 0 9 8 7 6 5`'
- en: '`4 6 8 7 5 3 2 9 0 1`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4 6 8 7 5 3 2 9 0 1`'
- en: '`2 5 6 7 4 8 9 3 1 0`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2 5 6 7 4 8 9 3 1 0`'
- en: '`4 3 2 1 0 5 6 7 8 9`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4 3 2 1 0 5 6 7 8 9`'
- en: '`1 2 3 4 5 6 9 8 7 0`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1 2 3 4 5 6 9 8 7 0`'
- en: '`0 4 6 5 3 8 1 7 2 9`'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0 4 6 5 3 8 1 7 2 9`'
- en: '`1 4 7 9 8 6 5 3 0 2`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1 4 7 9 8 6 5 3 0 2`'
- en: '`2 1 4 3 6 5 8 7 9 0`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2 1 4 3 6 5 8 7 9 0`'
- en: Compose a stack client `reverse.py` that reads in strings from standard input
    and writes them in reverse order to standard output. Compose a stack client `parentheses.py`
    that reads in a text stream from standard input and uses a stack to determine
    whether its parentheses are properly balanced. For example, your program should
    write `True` for `[()]{}{[()()]()}` and `False` for `[(])`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`reverse.py`的栈客户端，从标准输入读取字符串，并以相反顺序写入标准输出。编写一个名为`parentheses.py`的栈客户端，从标准输入读取文本流，并使用栈来确定其括号是否正确平衡。例如，你的程序应该对`[()]{}{[()()]()}`写入`True`，对`[(])`写入`False`。
- en: Add the method `__len__()` to the `Stack` class in [linkedstack.py](linkedstack.py.html).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[linkedstack.py](linkedstack.py.html)的`Stack`类中添加方法`__len__()`。
- en: Add a method `peek()` to the `Stack` class in [arraystack.py](arraystack.py.html)
    that returns the most recently inserted item on the stack (without popping it).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[arraystack.py](arraystack.py.html)的`Stack`类中添加一个名为`peek()`的方法，该方法返回栈上最近插入的项目（不弹出）。
- en: What does the following code fragment write when `n` is 50? Give a high-level
    description of what the code fragment does for a given positive integer `n`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`n`为50时，以下代码片段会写入什么？为给定的正整数`n`提供代码片段的高级描述。
- en: '[PRE9]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Solution*: It writes the binary representation of `n` (`110010` when `n` is
    50).'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：它写出`n`的二进制表示（当`n`为50时为`110010`）。'
- en: What does the following code fragment do to the queue `queue`?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段对队列`queue`做了什么？
- en: '[PRE10]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Draw an object-level trace diagram for the three-node example used to introduce
    linked lists in this section.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为介绍本节中链表的三节点示例绘制一个对象级别的跟踪图。
- en: Compose a program that takes from standard input an expression without left
    parentheses and writes the equivalent infix expression with the parentheses inserted.
    For example, given the input
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，从标准输入接收一个没有左括号的表达式，并将插入了等效中缀表达式的括号的结果写入。例如，给定输入
- en: '[PRE11]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: your program should write
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的程序应该写
- en: '[PRE12]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compose a filter `infixtopostfix.py` that converts a fully parenthesized arithmetic
    expression from infix to postfix.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个过滤器`infixtopostfix.py`，将完全括号化的中缀算术表达式从中缀转换为后缀。
- en: Compose a program `evaluatepostfix.py` that reads a postfix expression from
    standard input, evaluates it, and writes the value to standard output. (Piping
    the output of your program from the previous exercise to this program gives equivalent
    behavior to [evaluate.py](evaluate.py.html).)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序`evaluatepostfix.py`，从标准输入读取后缀表达式，对其进行评估，并将值写入标准输出。（将上一个练习的程序输出通过管道传递给此程序，可以实现与[evaluate.py](evaluate.py.html)相同的行为。）
- en: Suppose that a client performs an intermixed sequence of *enqueue* and *dequeue*
    operations on a `Queue`. The enqueue operations put the integers 0 through 9 in
    order onto the queue; the dequeue operations write the return value. Which of
    the following sequence(s) could not occur?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设客户端对`Queue`执行一系列交错的*enqueue*和*dequeue*操作。*enqueue*操作按顺序将整数0到9放入队列；*dequeue*操作写入返回值。以下序列中哪个序列不能发生？
- en: '`0 1 2 3 4 5 6 7 8 9`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0 1 2 3 4 5 6 7 8 9`'
- en: '`4 6 8 7 5 3 2 9 0 1`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4 6 8 7 5 3 2 9 0 1`'
- en: '`2 5 6 7 4 8 9 3 1 0`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2 5 6 7 4 8 9 3 1 0`'
- en: '`4 3 2 1 0 5 6 7 8 9`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4 3 2 1 0 5 6 7 8 9`'
- en: Compose a `Queue` client that takes a command-line argument `k` writes the `k`th
    from the last string found on standard input.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`Queue`客户端，它接受一个命令行参数`k`，并将从标准输入中找到的倒数第`k`个字符串写入。
- en: Give the running time of each operation in the following `Queue` class, where
    the item least recently inserted is at `_a[0]`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出以下`Queue`类中每个操作的运行时间，其中最近插入的项位于`_a[0]`。
- en: '[PRE13]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Give the running time of each operation in the following `Queue` class, where
    the item most recently inserted is at `_a[0]`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出以下`Queue`类中每个操作的运行时间，其中最近插入的项位于`_a[0]`。
- en: '[PRE14]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Modify [mm1queue.py](mm1queue.py.html) to make a program `md1queue.py` that
    simulates a queue for which the service times are fixed (deterministic) at rate
    of μ. Verify Little's law empirically for this model.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[mm1queue.py](mm1queue.py.html)以创建一个程序`md1queue.py`，该程序模拟服务时间固定（确定性）为速率μ的队列。通过这个模型经验性地验证Little's定律。
- en: '* * *'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Linked List Exercises
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链表练习
- en: '*The following exercises are intended to give you experience in working with
    linked lists. The easiest way to work them is to make drawings using the visual
    representation described in the text.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下练习旨在让您熟练处理链表。解决它们的最简单方法是使用文本中描述的可视化表示法进行绘图。*'
- en: Suppose `x` is a linked-list node. What is the effect of the following code
    fragment?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`x`是一个链表节点。以下代码片段的效果是什么��
- en: '[PRE15]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Solution*: Deletes from the list the node immediately following `x`.'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：删除列表中紧随`x`之后的节点。'
- en: Compose a function `find()` that takes the first node in a linked list and an
    object `key` as arguments and returns `True` if some node in the list has `key`
    as its item field, and `False` otherwise.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`find()`，它以链表中的第一个节点和对象`key`作为参数，并在列表中的某个节点的项字段为`key`时返回`True`，否则返回`False`。
- en: Compose a function `delete()` that takes the first node in a linked list and
    an integer `k` as arguments and deletes the `k`th element in a linked list, if
    it exists.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`delete()`，它以链表中的第一个节点和整数`k`作为参数，并删除链表中的第`k`个元素（如果存在）。
- en: Suppose that `x` is a linked-list node. What is the effect of the following
    code fragment?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`x`是一个链表节点。以下代码片段的效果是什么？
- en: '[PRE16]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Solution*: Inserts node `t` immediately after node `x`.'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：在节点`x`之后立即插入节点`t`。'
- en: Why does the following code fragment not have the same effect as the code fragment
    in the previous question?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下代码片段的效果与上一个问题中的代码片段不同？
- en: '[PRE17]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Solution*: When it comes time to update `t.next`, `x.next` is no longer the
    original node following `x`, but is instead `t` itself!'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*解决方案*：当更新`t.next`时，`x.next`不再是跟在`x`后面的原始节点，而是`t`本身！'
- en: Compose a function `removeAfter()` that takes a linked-list node as an argument
    and removes the node following the given one (and does nothing if the argument
    or the next field in the argument node is `None`).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`removeAfter()`，它以链表节点作为参数，并删除给定节点后面的节点（如果参数或参数节点中的下一个字段为`None`，则不执行任何操作）。
- en: Compose a function `copy()` that takes a linked-list node as an argument and
    creates a new linked list with the same sequence of items, without destroying
    the original linked list.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`copy()`，它以一个链表节点作为参数，并创建一个具有相同项目序列的新链表，而不破坏原始链表。
- en: Compose a function `remove()` that takes a linked-list node and an object item
    as arguments and removes every node in the list whose item is item.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`remove()`，它以链表节点和对象项作为参数，并删除列表中每个项目为项的节点。
- en: Compose a function `listmax()` that takes the first node in a linked list as
    an argument and returns the value of the maximum item in the list. Assume that
    the items are comparable, and return `None` if the list is empty.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数`listmax()`，它以链表中的第一个节点作为参数，并返回列表中最大项目的值。假设项目是可比较的，并且如果列表为空，则返回`None`。
- en: Develop a recursive solution to the previous question.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个递归解决方案来回答上一个问题。
- en: Compose a function that takes the first node in a linked list as an argument
    and reverses the list, returning the first node in the result.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，它以链表中的第一个节点作为参数，并反转列表，返回结果中的第一个节点。
- en: '*Iterative solution*: To accomplish this task, we maintain references to three
    consecutive nodes in the linked list: `reverse`, `first`, and `second`. At each
    iteration, we extract the node `first` from the original linked list and insert
    it at the beginning of the reversed list. We maintain the invariant that `first`
    is the first node of what''s left of the original list, `second` is the second
    node of what''s left of the original list, and `reverse` is the first node of
    the resulting reversed list.'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When composing code involving linked lists, we must always be careful to properly
    handle the exceptional cases (when the linked list is empty, when the list has
    only one or two nodes) and the boundary cases (dealing with the first or last
    items). This is usually much trickier than handling the normal cases.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compose a recursive function to write the elements of a linked list in reverse
    order. Do not modify any of the links. *Easy*: Use quadratic time, constant extra
    space. *Also easy*: Use linear time, linear extra space. *Not so easy*: Develop
    a divide-and-conquer algorithm that uses linearithmic time and logarithmic extra
    space.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Quadratic time, constant space solution*: We recursively reverse the part
    of the list starting at the second node, and then carefully append the first element
    to the end.'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compose a recursive function to randomly shuffle the elements of a linked list
    by modifying the links. *Easy*: Use quadratic time, constant extra space. *Not
    so easy*: Develop a divide-and-conquer algorithm that takes linearithmic time
    and uses logarithmic extra memory. For the "merging" step, see the "Riffle shuffle"
    creative exercise at the end of Section 1.4.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Creative Exercises
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Deque.** A double-ended queue or *deque* (pronounced "deck") is a combination
    of a stack and a queue. Compose a class `Deque` that uses a linked list to implement
    this API:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Deque API](../Images/143c8cce33b94ba1ea51c10973ea32a0.png)'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '**Josephus problem.** In the Josephus problem from antiquity, *n* people are
    in dire straits and agree to the following strategy to reduce the population.
    They arrange themselves in a circle (at positions numbered from 0 to *n*-1) and
    proceed around the circle, eliminating every *m* person until only one person
    is left. Legend has it that Josephus figured out where to sit to avoid being eliminated.
    Compose a `Queue` client `josephus.py` that takes *n* and *m* from the command
    line and writes the order in which people are eliminated (and thus would show
    Josephus where to sit in the circle).'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Merging two sorted queues.** Given two queues with strings in ascending order,
    move all of the strings to a third queue so that the third queue ends up with
    the strings in ascending order.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Nonrecursive mergesort.** Given *n* strings, create *n* queues, each containing
    one of the strings. Create a queue of the *n* queues. Then, repeatedly apply the
    sorted merging operation to the first two queues and reinsert the merged queue
    at the end. Repeat until the queue of queues contains only one queue.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Delete ith element.** Implement a class that supports the following API:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![GeneralizedQueue API](../Images/882cc09a421e0039bdf2ffe604b029df.png)'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: First, develop an implementation that uses a Python list (resizing array) implementation,
    and then develop one that uses a linked-list implementation. (See the "Generalized
    queue" creative exercise at the end of Section 4.4 for a more efficient implementation
    that uses a binary search tree.)
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Queue with two stacks.** Show how to implement a queue using two stacks (and
    only a constant amount of extra memory) so that each queue operations uses a constant
    amortized number of stack operations.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ring buffer.** A ring buffer, or circular queue, is a FIFO data structure
    of a fixed capacity *n*. It is useful for transferring data between asynchronous
    processes or for storing log files. When the buffer is empty, the consumer waits
    until data is deposited; when the buffer is full, the producer waits to deposit
    data. Develop an API for a ring buffer and an implementation that uses an array
    representation (with circular wrap-around).'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Move-to-front.** Read in a sequence of characters from standard input and
    maintain the characters in a linked list with no duplicates. When you read in
    a previously unseen character, insert it at the front of the list. When you read
    in a duplicate character, delete it from the list and reinsert it at the beginning.
    Name your program `movetofront.py`: it implements the well known *move-to-front*
    strategy, which is useful for caching, data compression, and many other applications
    where items that have been recently accessed are more likely to be reaccessed.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Random queue.** A random queue stores a collection of items as per this API:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![RandomQueue API](../Images/ffbe8da226a6ee91a53b29923e9e7dd7.png)'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: 'Compose a class `RandomQueue` that implements this API. *Hint*: Use a Python
    list (resizing array) representation, as in [arraystack.py](arraystack.py.html).
    To remove an item, swap one at a random position (indexed 0 through *n*-1) with
    the one at the last position (index *n*-1). Then delete and return the last object.
    Compose a client that writes a deck of cards in random order using `RandomQueue`.'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Solution*: See [randomqueue.py](randomqueue.py.html).'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Topological sort.** You have to sequence the order of `n` jobs that are numbered
    from 0 to `n`-1 on a server. Some of the jobs must complete before others can
    begin. Compose a program `topologicalsorter.py` that takes `n` as a command-line
    argument and a sequence on standard input of ordered pairs of jobs `i j`, and
    then writes a sequence of integers such that for each pair `i j` in the input,
    job `i` appears before job `j`. Use the following algorithm: First, from the input,
    build, for each job, (1) a queue of the jobs that must follow it and (2) its indegree
    (the number of jobs that must come before it). Then, build a queue of all nodes
    whose indegree is 0 and repeatedly delete some job with zero indegree, maintaining
    all the data structures. This process has many applications; for example, you
    can use it to model course prerequisites for your major so that you can find a
    sequence of courses to take so that you can graduate.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text editor buffer.** Develop a data type for a buffer in a text editor that
    implements the following API:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Buffer API](../Images/fb4541823e15dcb8a3d77b41c99d3f22.png)'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_IMG
- en: '*Hint*: Use two stacks.'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Copy a stack.** Create a `copy()` method for the linked-list implementation
    of `Stack` so that'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: makes `stack2` a reference to a new and independent copy of the stack `stack1`.
    You should be able to push and pop from either `stack1` or `stack2` without influencing
    the other.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Copy a queue.** Create a `copy()` method for the linked-list implementation
    of Queue so that'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'makes `queue2` a reference to a new and independent copy of the queue `queue1`.
    *Hint*: Delete all of the items from `queue1` and add these items to both `queue1`
    and `queue2`.'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Stack with explicit resizing array.** Implement a stack using an explicit
    resizing array: initialize an empty stack by using an array of length 1 as an
    instance variable; double the length of the array when it becomes full and halve
    the length of the array when it becomes one-fourth full.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Solution*:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Queue with explicit resizing array.** Implement a queue using an explicit
    resizing array so that all operations take constant amortized time. *Hint*: The
    challenge is that the items will "crawl across" the array as items are added to
    and removed from the queue. Use modular arithmetic to maintain the array indices
    of the items at the front and back of the queue.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| stdin | stdout | n | lo | hi | a[0] | a[1] | a[2] | a[3] | a[4] | a[5] |
    a[6] | a[7] |'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '|  |  | 0 | 0 | 0 | None |  |  |  |  |  |  |  |'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| to |  | 1 | 0 | 1 | to | None |  |  |  |  |  |  |'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| be |  | 2 | 0 | 2 | to | be |  |  |  |  |  |  |'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| or |  | 3 | 0 | 3 | to | be | or | None |  |  |  |  |'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| not |  | 4 | 0 | 4 | to | be | or | not |  |  |  |  |'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| to |  | 5 | 0 | 5 | to | be | or | not | to | None | None | None |'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| - | to | 4 | 1 | 4 | None | be | or | not | to | None | None | None |'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| be |  | 5 | 1 | 6 | None | be | or | not | to | be | None | None |'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| - | be | 4 | 2 | 6 | None | None | or | not | to | be | None | None |'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| - | or | 3 | 3 | 6 | None | None | None | not | to | be | None | None |'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '| that |  | 4 | 3 | 7 | None | None | None | not | to | be | that | None |'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: '*Solution*: See [arrayqueue.py](arrayqueue.py.html).'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Queue simulations.** Study what happens when you modify [mm1queue.py](mm1queue.py.html)
    to use a stack instead of a queue. Does Little''s law hold? Answer the same question
    for a random queue. Plot histograms and compare the standard deviations of the
    waiting times.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Load-balancing simulations.** Revise [loadbalance.py](loadbalance.py.html)
    to write the average queue length and the maximum queue length instead of plotting
    the histogram, and use it to run simulations for 1 million items on 100000 queues.
    Write the average value of the maximum queue length for 100 trials each with sample
    sizes 1, 2, 3, and 4\. Do your experiments validate the conclusion drawn in the
    text about using a sample of size 2?'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Listing files.** A folder is a list of files and subfolders. Compose a program
    that takes the name of a folder as a command-line argument and writes all of the
    file names contained in that folder, with the contents of each folder recursively
    listed (indented) under that folder''s name. *Hint*: Use a queue, and see the
    `listdir()` function defined in Python''s `os` module.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
